# The file was automatically generated by Lark v1.1.8
__version__ = "1.1.8"

#
#
#   Lark Stand-alone Generator Tool
# ----------------------------------
# Generates a stand-alone LALR(1) parser
#
# Git:    https://github.com/erezsh/lark
# Author: Erez Shinan (erezshin@gmail.com)
#
#
#    >>> LICENSE
#
#    This tool and its generated code use a separate license from Lark,
#    and are subject to the terms of the Mozilla Public License, v. 2.0.
#    If a copy of the MPL was not distributed with this
#    file, You can obtain one at https://mozilla.org/MPL/2.0/.
#
#    If you wish to purchase a commercial license for this tool and its
#    generated code, you may contact me via email or otherwise.
#
#    If MPL2 is incompatible with your free or open-source project,
#    contact me and we'll work it out.
#
#

from copy import deepcopy
from abc import ABC, abstractmethod
from types import ModuleType
from typing import (
    TypeVar,
    Generic,
    Type,
    Tuple,
    List,
    Dict,
    Iterator,
    Collection,
    Callable,
    Optional,
    FrozenSet,
    Any,
    Union,
    Iterable,
    IO,
    TYPE_CHECKING,
    overload,
    Sequence,
    Pattern as REPattern,
    ClassVar,
    Set,
    Mapping,
)




class LarkError(Exception):
    pass


class ConfigurationError(LarkError, ValueError):
    pass


def assert_config(value, options: Collection, msg="Got %r, expected one of %s"):
    if value not in options:
        raise ConfigurationError(msg % (value, options))


class GrammarError(LarkError):
    pass


class ParseError(LarkError):
    pass


class LexError(LarkError):
    pass


T = TypeVar("T")


class UnexpectedInput(LarkError):
    #--

    line: int
    column: int
    pos_in_stream = None
    state: Any
    _terminals_by_name = None
    interactive_parser: "InteractiveParser"

    def get_context(self, text: str, span: int = 40) -> str:
        #--
        assert self.pos_in_stream is not None, self
        pos = self.pos_in_stream
        start = max(pos - span, 0)
        end = pos + span
        if not isinstance(text, bytes):
            before = text[start:pos].rsplit("\n", 1)[-1]
            after = text[pos:end].split("\n", 1)[0]
            return before + after + "\n" + " " * len(before.expandtabs()) + "^\n"
        else:
            before = text[start:pos].rsplit(b"\n", 1)[-1]
            after = text[pos:end].split(b"\n", 1)[0]
            return (
                before + after + b"\n" + b" " * len(before.expandtabs()) + b"^\n"
            ).decode("ascii", "backslashreplace")

    def match_examples(
        self,
        parse_fn: "Callable[[str], Tree]",
        examples: Union[Mapping[T, Iterable[str]], Iterable[Tuple[T, Iterable[str]]]],
        token_type_match_fallback: bool = False,
        use_accepts: bool = True,
    ) -> Optional[T]:
        #--
        assert self.state is not None, "Not supported for this exception"

        if isinstance(examples, Mapping):
            examples = examples.items()

        candidate = (None, False)
        for i, (label, example) in enumerate(examples):
            assert not isinstance(example, str), "Expecting a list"

            for j, malformed in enumerate(example):
                try:
                    parse_fn(malformed)
                except UnexpectedInput as ut:
                    if ut.state == self.state:
                        if (
                            use_accepts
                            and isinstance(self, UnexpectedToken)
                            and isinstance(ut, UnexpectedToken)
                            and ut.accepts != self.accepts
                        ):
                            logger.debug(
                                "Different accepts with same state[%d]: %s != %s at example [%s][%s]"
                                % (self.state, self.accepts, ut.accepts, i, j)
                            )
                            continue
                        if isinstance(
                            self, (UnexpectedToken, UnexpectedEOF)
                        ) and isinstance(ut, (UnexpectedToken, UnexpectedEOF)):
                            if ut.token == self.token:  ##

                                logger.debug("Exact Match at example [%s][%s]" % (i, j))
                                return label

                            if token_type_match_fallback:
                                ##

                                if (ut.token.type == self.token.type) and not candidate[
                                    -1
                                ]:
                                    logger.debug(
                                        "Token Type Fallback at example [%s][%s]"
                                        % (i, j)
                                    )
                                    candidate = label, True

                        if candidate[0] is None:
                            logger.debug(
                                "Same State match at example [%s][%s]" % (i, j)
                            )
                            candidate = label, False

        return candidate[0]

    def _format_expected(self, expected):
        if self._terminals_by_name:
            d = self._terminals_by_name
            expected = [
                d[t_name].user_repr() if t_name in d else t_name for t_name in expected
            ]
        return "Expected one of: \n\t* %s\n" % "\n\t* ".join(expected)


class UnexpectedEOF(ParseError, UnexpectedInput):
    #--

    expected: "List[Token]"

    def __init__(self, expected, state=None, terminals_by_name=None):
        super(UnexpectedEOF, self).__init__()

        self.expected = expected
        self.state = state
        from .lexer import Token

        self.token = Token("<EOF>", "")  ##

        self.pos_in_stream = -1
        self.line = -1
        self.column = -1
        self._terminals_by_name = terminals_by_name

    def __str__(self):
        message = "Unexpected end-of-input. "
        message += self._format_expected(self.expected)
        return message


class UnexpectedCharacters(LexError, UnexpectedInput):
    #--

    allowed: Set[str]
    considered_tokens: Set[Any]

    def __init__(
        self,
        seq,
        lex_pos,
        line,
        column,
        allowed=None,
        considered_tokens=None,
        state=None,
        token_history=None,
        terminals_by_name=None,
        considered_rules=None,
    ):
        super(UnexpectedCharacters, self).__init__()

        ##

        self.line = line
        self.column = column
        self.pos_in_stream = lex_pos
        self.state = state
        self._terminals_by_name = terminals_by_name

        self.allowed = allowed
        self.considered_tokens = considered_tokens
        self.considered_rules = considered_rules
        self.token_history = token_history

        if isinstance(seq, bytes):
            self.char = seq[lex_pos : lex_pos + 1].decode("ascii", "backslashreplace")
        else:
            self.char = seq[lex_pos]
        self._context = self.get_context(seq)

    def __str__(self):
        message = (
            "No terminal matches '%s' in the current parser context, at line %d col %d"
            % (self.char, self.line, self.column)
        )
        message += "\n\n" + self._context
        if self.allowed:
            message += self._format_expected(self.allowed)
        if self.token_history:
            message += "\nPrevious tokens: %s\n" % ", ".join(
                repr(t) for t in self.token_history
            )
        return message


class UnexpectedToken(ParseError, UnexpectedInput):
    #--

    expected: Set[str]
    considered_rules: Set[str]

    def __init__(
        self,
        token,
        expected,
        considered_rules=None,
        state=None,
        interactive_parser=None,
        terminals_by_name=None,
        token_history=None,
    ):
        super(UnexpectedToken, self).__init__()

        ##

        self.line = getattr(token, "line", "?")
        self.column = getattr(token, "column", "?")
        self.pos_in_stream = getattr(token, "start_pos", None)
        self.state = state

        self.token = token
        self.expected = expected  ##

        self._accepts = NO_VALUE
        self.considered_rules = considered_rules
        self.interactive_parser = interactive_parser
        self._terminals_by_name = terminals_by_name
        self.token_history = token_history

    @property
    def accepts(self) -> Set[str]:
        if self._accepts is NO_VALUE:
            self._accepts = (
                self.interactive_parser and self.interactive_parser.accepts()
            )
        return self._accepts

    def __str__(self):
        message = "Unexpected token %r at line %s, column %s.\n%s" % (
            self.token,
            self.line,
            self.column,
            self._format_expected(self.accepts or self.expected),
        )
        if self.token_history:
            message += "Previous tokens: %r\n" % self.token_history

        return message


class VisitError(LarkError):
    #--

    obj: "Union[Tree, Token]"
    orig_exc: Exception

    def __init__(self, rule, obj, orig_exc):
        message = 'Error trying to process rule "%s":\n\n%s' % (rule, orig_exc)
        super(VisitError, self).__init__(message)

        self.rule = rule
        self.obj = obj
        self.orig_exc = orig_exc


class MissingVariableError(LarkError):
    pass



import sys, re
import logging

logger: logging.Logger = logging.getLogger("lark")
logger.addHandler(logging.StreamHandler())
##

##

logger.setLevel(logging.CRITICAL)


NO_VALUE = object()

T = TypeVar("T")


def classify(
    seq: Iterable, key: Optional[Callable] = None, value: Optional[Callable] = None
) -> Dict:
    d: Dict[Any, Any] = {}
    for item in seq:
        k = key(item) if (key is not None) else item
        v = value(item) if (value is not None) else item
        try:
            d[k].append(v)
        except KeyError:
            d[k] = [v]
    return d


def _deserialize(data: Any, namespace: Dict[str, Any], memo: Dict) -> Any:
    if isinstance(data, dict):
        if "__type__" in data:  ##

            class_ = namespace[data["__type__"]]
            return class_.deserialize(data, memo)
        elif "@" in data:
            return memo[data["@"]]
        return {
            key: _deserialize(value, namespace, memo) for key, value in data.items()
        }
    elif isinstance(data, list):
        return [_deserialize(value, namespace, memo) for value in data]
    return data


_T = TypeVar("_T", bound="Serialize")


class Serialize:
    #--

    def memo_serialize(self, types_to_memoize: List) -> Any:
        memo = SerializeMemoizer(types_to_memoize)
        return self.serialize(memo), memo.serialize()

    def serialize(self, memo=None) -> Dict[str, Any]:
        if memo and memo.in_types(self):
            return {"@": memo.memoized.get(self)}

        fields = getattr(self, "__serialize_fields__")
        res = {f: _serialize(getattr(self, f), memo) for f in fields}
        res["__type__"] = type(self).__name__
        if hasattr(self, "_serialize"):
            self._serialize(res, memo)  ##

        return res

    @classmethod
    def deserialize(cls: Type[_T], data: Dict[str, Any], memo: Dict[int, Any]) -> _T:
        namespace = getattr(cls, "__serialize_namespace__", [])
        namespace = {c.__name__: c for c in namespace}

        fields = getattr(cls, "__serialize_fields__")

        if "@" in data:
            return memo[data["@"]]

        inst = cls.__new__(cls)
        for f in fields:
            try:
                setattr(inst, f, _deserialize(data[f], namespace, memo))
            except KeyError as e:
                raise KeyError("Cannot find key for class", cls, e)

        if hasattr(inst, "_deserialize"):
            inst._deserialize()  ##


        return inst


class SerializeMemoizer(Serialize):
    #--

    __serialize_fields__ = ("memoized",)

    def __init__(self, types_to_memoize: List) -> None:
        self.types_to_memoize = tuple(types_to_memoize)
        self.memoized = Enumerator()

    def in_types(self, value: Serialize) -> bool:
        return isinstance(value, self.types_to_memoize)

    def serialize(self) -> Dict[int, Any]:  ##

        return _serialize(self.memoized.reversed(), None)

    @classmethod
    def deserialize(cls, data: Dict[int, Any], namespace: Dict[str, Any], memo: Dict[Any, Any]) -> Dict[int, Any]:  ##

        return _deserialize(data, namespace, memo)


try:
    import regex

    _has_regex = True
except ImportError:
    _has_regex = False

if sys.version_info >= (3, 11):
    import re._parser as sre_parse
    import re._constants as sre_constants
else:
    import sre_parse
    import sre_constants

categ_pattern = re.compile(r"\\p{[A-Za-z_]+}")


def get_regexp_width(expr: str) -> Union[Tuple[int, int], List[int]]:
    if _has_regex:
        ##

        ##

        ##

        regexp_final = re.sub(categ_pattern, "A", expr)
    else:
        if re.search(categ_pattern, expr):
            raise ImportError(
                "`regex` module must be installed in order to use Unicode categories.",
                expr,
            )
        regexp_final = expr
    try:
        ##

        return [int(x) for x in sre_parse.parse(regexp_final).getwidth()]  ##

    except sre_constants.error:
        if not _has_regex:
            raise ValueError(expr)
        else:
            ##

            ##

            c = regex.compile(regexp_final)
            if c.match("") is None:
                ##

                return 1, int(sre_constants.MAXREPEAT)
            else:
                return 0, int(sre_constants.MAXREPEAT)



from collections import OrderedDict


class Meta:
    empty: bool
    line: int
    column: int
    start_pos: int
    end_line: int
    end_column: int
    end_pos: int
    orig_expansion: "List[TerminalDef]"
    match_tree: bool

    def __init__(self):
        self.empty = True


_Leaf_T = TypeVar("_Leaf_T")
Branch = Union[_Leaf_T, "Tree[_Leaf_T]"]


class Tree(Generic[_Leaf_T]):
    #--

    data: str
    children: "List[Branch[_Leaf_T]]"

    def __init__(
        self, data: str, children: "List[Branch[_Leaf_T]]", meta: Optional[Meta] = None
    ) -> None:
        self.data = data
        self.children = children
        self._meta = meta

    @property
    def meta(self) -> Meta:
        if self._meta is None:
            self._meta = Meta()
        return self._meta

    def __repr__(self):
        return "Tree(%r, %r)" % (self.data, self.children)

    def _pretty_label(self):
        return self.data

    def _pretty(self, level, indent_str):
        yield f"{indent_str*level}{self._pretty_label()}"
        if len(self.children) == 1 and not isinstance(self.children[0], Tree):
            yield f"\t{self.children[0]}\n"
        else:
            yield "\n"
            for n in self.children:
                if isinstance(n, Tree):
                    yield from n._pretty(level + 1, indent_str)
                else:
                    yield f"{indent_str*(level+1)}{n}\n"

    def pretty(self, indent_str: str = "  ") -> str:
        #--
        return "".join(self._pretty(0, indent_str))

    def __rich__(self, parent: Optional["rich.tree.Tree"] = None) -> "rich.tree.Tree":
        #--
        return self._rich(parent)

    def _rich(self, parent):
        if parent:
            tree = parent.add(f"[bold]{self.data}[/bold]")
        else:
            import rich.tree

            tree = rich.tree.Tree(self.data)

        for c in self.children:
            if isinstance(c, Tree):
                c._rich(tree)
            else:
                tree.add(f"[green]{c}[/green]")

        return tree

    def __eq__(self, other):
        try:
            return self.data == other.data and self.children == other.children
        except AttributeError:
            return False

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self) -> int:
        return hash((self.data, tuple(self.children)))

    def iter_subtrees(self) -> "Iterator[Tree[_Leaf_T]]":
        #--
        queue = [self]
        subtrees = OrderedDict()
        for subtree in queue:
            subtrees[id(subtree)] = subtree
            ##

            queue += [
                c
                for c in reversed(subtree.children)  ##

                if isinstance(c, Tree) and id(c) not in subtrees
            ]

        del queue
        return reversed(list(subtrees.values()))

    def iter_subtrees_topdown(self):
        #--
        stack = [self]
        stack_append = stack.append
        stack_pop = stack.pop
        while stack:
            node = stack_pop()
            if not isinstance(node, Tree):
                continue
            yield node
            for child in reversed(node.children):
                stack_append(child)

    def find_pred(
        self, pred: "Callable[[Tree[_Leaf_T]], bool]"
    ) -> "Iterator[Tree[_Leaf_T]]":
        #--
        return filter(pred, self.iter_subtrees())

    def find_data(self, data: str) -> "Iterator[Tree[_Leaf_T]]":
        #--
        return self.find_pred(lambda t: t.data == data)


from functools import wraps, update_wrapper
from inspect import getmembers, getmro

_Return_T = TypeVar("_Return_T")
_Return_V = TypeVar("_Return_V")
_Leaf_T = TypeVar("_Leaf_T")
_Leaf_U = TypeVar("_Leaf_U")
_R = TypeVar("_R")
_FUNC = Callable[..., _Return_T]
_DECORATED = Union[_FUNC, type]


class _DiscardType:
    #--

    def __repr__(self):
        return "lark.visitors.Discard"


Discard = _DiscardType()

##



class _Decoratable:
    #--

    @classmethod
    def _apply_v_args(cls, visit_wrapper):
        mro = getmro(cls)
        assert mro[0] is cls
        libmembers = {name for _cls in mro[1:] for name, _ in getmembers(_cls)}
        for name, value in getmembers(cls):
            ##

            if name.startswith("_") or (
                name in libmembers and name not in cls.__dict__
            ):
                continue
            if not callable(value):
                continue

            ##

            if isinstance(cls.__dict__[name], _VArgsWrapper):
                continue

            setattr(cls, name, _VArgsWrapper(cls.__dict__[name], visit_wrapper))
        return cls

    def __class_getitem__(cls, _):
        return cls


class Transformer(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    #--

    __visit_tokens__ = True  ##


    def __init__(self, visit_tokens: bool = True) -> None:
        self.__visit_tokens__ = visit_tokens

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            try:
                wrapper = getattr(f, "visit_wrapper", None)
                if wrapper is not None:
                    return f.visit_wrapper(f, tree.data, children, tree.meta)
                else:
                    return f(children)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(tree.data, tree, e)

    def _call_userfunc_token(self, token):
        try:
            f = getattr(self, token.type)
        except AttributeError:
            return self.__default_token__(token)
        else:
            try:
                return f(token)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(token.type, token, e)

    def _transform_children(self, children):
        for c in children:
            if isinstance(c, Tree):
                res = self._transform_tree(c)
            elif self.__visit_tokens__ and isinstance(c, Token):
                res = self._call_userfunc_token(c)
            else:
                res = c

            if res is not Discard:
                yield res

    def _transform_tree(self, tree):
        children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree, children)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        #--
        return self._transform_tree(tree)

    def __mul__(
        self: "Transformer[_Leaf_T, Tree[_Leaf_U]]",
        other: "Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V,]]",
    ) -> "TransformerChain[_Leaf_T, _Return_V]":
        #--
        return TransformerChain(self, other)

    def __default__(self, data, children, meta):
        #--
        return Tree(data, children, meta)

    def __default_token__(self, token):
        #--
        return token


def merge_transformers(base_transformer=None, **transformers_to_merge):
    #--
    if base_transformer is None:
        base_transformer = Transformer()
    for prefix, transformer in transformers_to_merge.items():
        for method_name in dir(transformer):
            method = getattr(transformer, method_name)
            if not callable(method):
                continue
            if method_name.startswith("_") or method_name == "transform":
                continue
            prefixed_method = prefix + "__" + method_name
            if hasattr(base_transformer, prefixed_method):
                raise AttributeError(
                    "Cannot merge: method '%s' appears more than once" % prefixed_method
                )

            setattr(base_transformer, prefixed_method, method)

    return base_transformer


class InlineTransformer(Transformer):  ##

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            return f(*children)


class TransformerChain(Generic[_Leaf_T, _Return_T]):
    transformers: "Tuple[Union[Transformer, TransformerChain], ...]"

    def __init__(self, *transformers: "Union[Transformer, TransformerChain]") -> None:
        self.transformers = transformers

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for t in self.transformers:
            tree = t.transform(tree)
        return cast(_Return_T, tree)

    def __mul__(
        self: "TransformerChain[_Leaf_T, Tree[_Leaf_U]]",
        other: "Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V]]",
    ) -> "TransformerChain[_Leaf_T, _Return_V]":
        return TransformerChain(*self.transformers + (other,))


class Transformer_InPlace(Transformer[_Leaf_T, _Return_T]):
    #--

    def _transform_tree(self, tree):  ##

        return self._call_userfunc(tree)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for subtree in tree.iter_subtrees():
            subtree.children = list(self._transform_children(subtree.children))

        return self._transform_tree(tree)


class Transformer_NonRecursive(Transformer[_Leaf_T, _Return_T]):
    #--

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        rev_postfix = []
        q: List[Branch[_Leaf_T]] = [tree]
        while q:
            t = q.pop()
            rev_postfix.append(t)
            if isinstance(t, Tree):
                q += t.children

        ##

        stack: List = []
        for x in reversed(rev_postfix):
            if isinstance(x, Tree):
                size = len(x.children)
                if size:
                    args = stack[-size:]
                    del stack[-size:]
                else:
                    args = []

                res = self._call_userfunc(x, args)
                if res is not Discard:
                    stack.append(res)

            elif self.__visit_tokens__ and isinstance(x, Token):
                res = self._call_userfunc_token(x)
                if res is not Discard:
                    stack.append(res)
            else:
                stack.append(x)

        (result,) = stack  ##

        ##

        ##

        ##

        return cast(_Return_T, result)


class Transformer_InPlaceRecursive(Transformer):
    #--

    def _transform_tree(self, tree):
        tree.children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree)


##



class VisitorBase:
    def _call_userfunc(self, tree):
        return getattr(self, tree.data, self.__default__)(tree)

    def __default__(self, tree):
        #--
        return tree

    def __class_getitem__(cls, _):
        return cls


class Visitor(VisitorBase, ABC, Generic[_Leaf_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for subtree in tree.iter_subtrees():
            self._call_userfunc(subtree)
        return tree

    def visit_topdown(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for subtree in tree.iter_subtrees_topdown():
            self._call_userfunc(subtree)
        return tree


class Visitor_Recursive(VisitorBase, Generic[_Leaf_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for child in tree.children:
            if isinstance(child, Tree):
                self.visit(child)

        self._call_userfunc(tree)
        return tree

    def visit_topdown(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        self._call_userfunc(tree)

        for child in tree.children:
            if isinstance(child, Tree):
                self.visit_topdown(child)

        return tree


class Interpreter(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        ##

        ##

        return self._visit_tree(tree)

    def _visit_tree(self, tree: Tree[_Leaf_T]):
        f = getattr(self, tree.data)
        wrapper = getattr(f, "visit_wrapper", None)
        if wrapper is not None:
            return f.visit_wrapper(f, tree.data, tree.children, tree.meta)
        else:
            return f(tree)

    def visit_children(self, tree: Tree[_Leaf_T]) -> List:
        return [
            self._visit_tree(child) if isinstance(child, Tree) else child
            for child in tree.children
        ]

    def __getattr__(self, name):
        return self.__default__

    def __default__(self, tree):
        return self.visit_children(tree)


_InterMethod = Callable[[Type[Interpreter], _Return_T], _R]


def visit_children_decor(func: _InterMethod) -> _InterMethod:
    #--

    @wraps(func)
    def inner(cls, tree):
        values = cls.visit_children(tree)
        return func(cls, values)

    return inner


##



def _apply_v_args(obj, visit_wrapper):
    try:
        _apply = obj._apply_v_args
    except AttributeError:
        return _VArgsWrapper(obj, visit_wrapper)
    else:
        return _apply(visit_wrapper)


class _VArgsWrapper:
    #--

    base_func: Callable

    def __init__(
        self, func: Callable, visit_wrapper: Callable[[Callable, str, list, Any], Any]
    ):
        if isinstance(func, _VArgsWrapper):
            func = func.base_func
        ##

        self.base_func = func  ##

        self.visit_wrapper = visit_wrapper
        update_wrapper(self, func)

    def __call__(self, *args, **kwargs):
        return self.base_func(*args, **kwargs)

    def __get__(self, instance, owner=None):
        try:
            ##

            ##

            g = type(self.base_func).__get__
        except AttributeError:
            return self
        else:
            return _VArgsWrapper(g(self.base_func, instance, owner), self.visit_wrapper)

    def __set_name__(self, owner, name):
        try:
            f = type(self.base_func).__set_name__
        except AttributeError:
            return
        else:
            f(self.base_func, owner, name)


def _vargs_inline(f, _data, children, _meta):
    return f(*children)


def _vargs_meta_inline(f, _data, children, meta):
    return f(meta, *children)


def _vargs_meta(f, _data, children, meta):
    return f(meta, children)


def _vargs_tree(f, data, children, meta):
    return f(Tree(data, children, meta))


def v_args(
    inline: bool = False,
    meta: bool = False,
    tree: bool = False,
    wrapper: Optional[Callable] = None,
) -> Callable[[_DECORATED], _DECORATED]:
    #--
    if tree and (meta or inline):
        raise ValueError(
            "Visitor functions cannot combine 'tree' with 'meta' or 'inline'."
        )

    func = None
    if meta:
        if inline:
            func = _vargs_meta_inline
        else:
            func = _vargs_meta
    elif inline:
        func = _vargs_inline
    elif tree:
        func = _vargs_tree

    if wrapper is not None:
        if func is not None:
            raise ValueError(
                "Cannot use 'wrapper' along with 'tree', 'meta' or 'inline'."
            )
        func = wrapper

    def _visitor_args_dec(obj):
        return _apply_v_args(obj, func)

    return _visitor_args_dec



TOKEN_DEFAULT_PRIORITY = 0


class Symbol(Serialize):
    __slots__ = ("name",)

    name: str
    is_term: ClassVar[bool] = NotImplemented

    def __init__(self, name: str) -> None:
        self.name = name

    def __eq__(self, other):
        assert isinstance(other, Symbol), other
        return self.is_term == other.is_term and self.name == other.name

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self):
        return hash(self.name)

    def __repr__(self):
        return "%s(%r)" % (type(self).__name__, self.name)

    fullrepr = property(__repr__)

    def renamed(self, f):
        return type(self)(f(self.name))


class Terminal(Symbol):
    __serialize_fields__ = "name", "filter_out"

    is_term: ClassVar[bool] = True

    def __init__(self, name, filter_out=False):
        self.name = name
        self.filter_out = filter_out

    @property
    def fullrepr(self):
        return "%s(%r, %r)" % (type(self).__name__, self.name, self.filter_out)

    def renamed(self, f):
        return type(self)(f(self.name), self.filter_out)


class NonTerminal(Symbol):
    __serialize_fields__ = ("name",)

    is_term: ClassVar[bool] = False


class RuleOptions(Serialize):
    __serialize_fields__ = (
        "keep_all_tokens",
        "expand1",
        "priority",
        "template_source",
        "empty_indices",
    )

    keep_all_tokens: bool
    expand1: bool
    priority: Optional[int]
    template_source: Optional[str]
    empty_indices: Tuple[bool, ...]

    def __init__(
        self,
        keep_all_tokens: bool = False,
        expand1: bool = False,
        priority: Optional[int] = None,
        template_source: Optional[str] = None,
        empty_indices: Tuple[bool, ...] = (),
    ) -> None:
        self.keep_all_tokens = keep_all_tokens
        self.expand1 = expand1
        self.priority = priority
        self.template_source = template_source
        self.empty_indices = empty_indices

    def __repr__(self):
        return "RuleOptions(%r, %r, %r, %r)" % (
            self.keep_all_tokens,
            self.expand1,
            self.priority,
            self.template_source,
        )


class Rule(Serialize):
    #--

    __slots__ = ("origin", "expansion", "alias", "options", "order", "_hash")

    __serialize_fields__ = "origin", "expansion", "order", "alias", "options"
    __serialize_namespace__ = Terminal, NonTerminal, RuleOptions

    origin: NonTerminal
    expansion: Sequence[Symbol]
    order: int
    alias: Optional[str]
    options: RuleOptions
    _hash: int

    def __init__(
        self,
        origin: NonTerminal,
        expansion: Sequence[Symbol],
        order: int = 0,
        alias: Optional[str] = None,
        options: Optional[RuleOptions] = None,
    ):
        self.origin = origin
        self.expansion = expansion
        self.alias = alias
        self.order = order
        self.options = options or RuleOptions()
        self._hash = hash((self.origin, tuple(self.expansion)))

    def _deserialize(self):
        self._hash = hash((self.origin, tuple(self.expansion)))

    def __str__(self):
        return "<%s : %s>" % (
            self.origin.name,
            " ".join(x.name for x in self.expansion),
        )

    def __repr__(self):
        return "Rule(%r, %r, %r, %r)" % (
            self.origin,
            self.expansion,
            self.alias,
            self.options,
        )

    def __hash__(self):
        return self._hash

    def __eq__(self, other):
        if not isinstance(other, Rule):
            return False
        return self.origin == other.origin and self.expansion == other.expansion



from copy import copy

try:  ##

    has_interegular = bool(interegular)
except NameError:
    has_interegular = False


class Pattern(Serialize, ABC):
    #--

    value: str
    flags: Collection[str]
    raw: Optional[str]
    type: ClassVar[str]

    def __init__(
        self, value: str, flags: Collection[str] = (), raw: Optional[str] = None
    ) -> None:
        self.value = value
        self.flags = frozenset(flags)
        self.raw = raw

    def __repr__(self):
        return repr(self.to_regexp())

    ##

    def __hash__(self):
        return hash((type(self), self.value, self.flags))

    def __eq__(self, other):
        return (
            type(self) == type(other)
            and self.value == other.value
            and self.flags == other.flags
        )

    @abstractmethod
    def to_regexp(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def min_width(self) -> int:
        raise NotImplementedError()

    @property
    @abstractmethod
    def max_width(self) -> int:
        raise NotImplementedError()

    def _get_flags(self, value):
        for f in self.flags:
            value = "(?%s:%s)" % (f, value)
        return value


class PatternStr(Pattern):
    __serialize_fields__ = "value", "flags", "raw"

    type: ClassVar[str] = "str"

    def to_regexp(self) -> str:
        return self._get_flags(re.escape(self.value))

    @property
    def min_width(self) -> int:
        return len(self.value)

    @property
    def max_width(self) -> int:
        return len(self.value)


class PatternRE(Pattern):
    __serialize_fields__ = "value", "flags", "raw", "_width"

    type: ClassVar[str] = "re"

    def to_regexp(self) -> str:
        return self._get_flags(self.value)

    _width = None

    def _get_width(self):
        if self._width is None:
            self._width = get_regexp_width(self.to_regexp())
        return self._width

    @property
    def min_width(self) -> int:
        return self._get_width()[0]

    @property
    def max_width(self) -> int:
        return self._get_width()[1]


class TerminalDef(Serialize):
    #--
    __serialize_fields__ = "name", "pattern", "priority"
    __serialize_namespace__ = PatternStr, PatternRE

    name: str
    pattern: Pattern
    priority: int

    def __init__(
        self, name: str, pattern: Pattern, priority: int = TOKEN_DEFAULT_PRIORITY
    ) -> None:
        assert isinstance(pattern, Pattern), pattern
        self.name = name
        self.pattern = pattern
        self.priority = priority

    def __repr__(self):
        return "%s(%r, %r)" % (type(self).__name__, self.name, self.pattern)

    def user_repr(self) -> str:
        if self.name.startswith("__"):  ##

            return self.pattern.raw or self.name
        else:
            return self.name


_T = TypeVar("_T", bound="Token")


class Token(str):
    #--

    __slots__ = (
        "type",
        "start_pos",
        "value",
        "line",
        "column",
        "end_line",
        "end_column",
        "end_pos",
    )

    __match_args__ = ("type", "value")

    type: str
    start_pos: Optional[int]
    value: Any
    line: Optional[int]
    column: Optional[int]
    end_line: Optional[int]
    end_column: Optional[int]
    end_pos: Optional[int]

    @overload
    def __new__(
        cls,
        type: str,
        value: Any,
        start_pos: Optional[int] = None,
        line: Optional[int] = None,
        column: Optional[int] = None,
        end_line: Optional[int] = None,
        end_column: Optional[int] = None,
        end_pos: Optional[int] = None,
    ) -> "Token":
        ...

    @overload
    def __new__(
        cls,
        type_: str,
        value: Any,
        start_pos: Optional[int] = None,
        line: Optional[int] = None,
        column: Optional[int] = None,
        end_line: Optional[int] = None,
        end_column: Optional[int] = None,
        end_pos: Optional[int] = None,
    ) -> "Token":
        ...

    def __new__(cls, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn(
                "`type_` is deprecated use `type` instead", DeprecationWarning
            )

            if "type" in kwargs:
                raise TypeError(
                    "Error: using both 'type' and the deprecated 'type_' as arguments."
                )
            kwargs["type"] = kwargs.pop("type_")

        return cls._future_new(*args, **kwargs)

    @classmethod
    def _future_new(
        cls,
        type,
        value,
        start_pos=None,
        line=None,
        column=None,
        end_line=None,
        end_column=None,
        end_pos=None,
    ):
        inst = super(Token, cls).__new__(cls, value)

        inst.type = type
        inst.start_pos = start_pos
        inst.value = value
        inst.line = line
        inst.column = column
        inst.end_line = end_line
        inst.end_column = end_column
        inst.end_pos = end_pos
        return inst

    @overload
    def update(
        self, type: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        ...

    @overload
    def update(
        self, type_: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        ...

    def update(self, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn(
                "`type_` is deprecated use `type` instead", DeprecationWarning
            )

            if "type" in kwargs:
                raise TypeError(
                    "Error: using both 'type' and the deprecated 'type_' as arguments."
                )
            kwargs["type"] = kwargs.pop("type_")

        return self._future_update(*args, **kwargs)

    def _future_update(
        self, type: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        return Token.new_borrow_pos(
            type if type is not None else self.type,
            value if value is not None else self.value,
            self,
        )

    @classmethod
    def new_borrow_pos(cls: Type[_T], type_: str, value: Any, borrow_t: "Token") -> _T:
        return cls(
            type_,
            value,
            borrow_t.start_pos,
            borrow_t.line,
            borrow_t.column,
            borrow_t.end_line,
            borrow_t.end_column,
            borrow_t.end_pos,
        )

    def __reduce__(self):
        return (
            self.__class__,
            (self.type, self.value, self.start_pos, self.line, self.column),
        )

    def __repr__(self):
        return "Token(%r, %r)" % (self.type, self.value)

    def __deepcopy__(self, memo):
        return Token(self.type, self.value, self.start_pos, self.line, self.column)

    def __eq__(self, other):
        if isinstance(other, Token) and self.type != other.type:
            return False

        return str.__eq__(self, other)

    __hash__ = str.__hash__


class LineCounter:
    #--

    __slots__ = "char_pos", "line", "column", "line_start_pos", "newline_char"

    def __init__(self, newline_char):
        self.newline_char = newline_char
        self.char_pos = 0
        self.line = 1
        self.column = 1
        self.line_start_pos = 0

    def __eq__(self, other):
        if not isinstance(other, LineCounter):
            return NotImplemented

        return (
            self.char_pos == other.char_pos and self.newline_char == other.newline_char
        )

    def feed(self, token: Token, test_newline=True):
        #--
        if test_newline:
            newlines = token.count(self.newline_char)
            if newlines:
                self.line += newlines
                self.line_start_pos = (
                    self.char_pos + token.rindex(self.newline_char) + 1
                )

        self.char_pos += len(token)
        self.column = self.char_pos - self.line_start_pos + 1


class UnlessCallback:
    def __init__(self, scanner):
        self.scanner = scanner

    def __call__(self, t):
        res = self.scanner.match(t.value, 0)
        if res:
            _value, t.type = res
        return t


class CallChain:
    def __init__(self, callback1, callback2, cond):
        self.callback1 = callback1
        self.callback2 = callback2
        self.cond = cond

    def __call__(self, t):
        t2 = self.callback1(t)
        return self.callback2(t) if self.cond(t2) else t2


def _get_match(re_, regexp, s, flags):
    m = re_.match(regexp, s, flags)
    if m:
        return m.group(0)


def _create_unless(terminals, g_regex_flags, re_, use_bytes):
    tokens_by_type = classify(terminals, lambda t: type(t.pattern))
    assert len(tokens_by_type) <= 2, tokens_by_type.keys()
    embedded_strs = set()
    callback = {}
    for retok in tokens_by_type.get(PatternRE, []):
        unless = []
        for strtok in tokens_by_type.get(PatternStr, []):
            if strtok.priority != retok.priority:
                continue
            s = strtok.pattern.value
            if s == _get_match(re_, retok.pattern.to_regexp(), s, g_regex_flags):
                unless.append(strtok)
                if strtok.pattern.flags <= retok.pattern.flags:
                    embedded_strs.add(strtok)
        if unless:
            callback[retok.name] = UnlessCallback(
                Scanner(
                    unless, g_regex_flags, re_, match_whole=True, use_bytes=use_bytes
                )
            )

    new_terminals = [t for t in terminals if t not in embedded_strs]
    return new_terminals, callback


class Scanner:
    def __init__(self, terminals, g_regex_flags, re_, use_bytes, match_whole=False):
        self.terminals = terminals
        self.g_regex_flags = g_regex_flags
        self.re_ = re_
        self.use_bytes = use_bytes
        self.match_whole = match_whole

        self.allowed_types = {t.name for t in self.terminals}

        self._mres = self._build_mres(terminals, len(terminals))

    def _build_mres(self, terminals, max_size):
        ##

        ##

        ##

        postfix = "$" if self.match_whole else ""
        mres = []
        while terminals:
            pattern = "|".join(
                "(?P<%s>%s)" % (t.name, t.pattern.to_regexp() + postfix)
                for t in terminals[:max_size]
            )
            if self.use_bytes:
                pattern = pattern.encode("latin-1")
            try:
                mre = self.re_.compile(pattern, self.g_regex_flags)
            except AssertionError:  ##

                return self._build_mres(terminals, max_size // 2)

            mres.append(mre)
            terminals = terminals[max_size:]
        return mres

    def match(self, text, pos):
        for mre in self._mres:
            m = mre.match(text, pos)
            if m:
                return m.group(0), m.lastgroup


def _regexp_has_newline(r: str):
    #--
    return (
        "\n" in r or "\\n" in r or "\\s" in r or "[^" in r or ("(?s" in r and "." in r)
    )


class LexerState:
    #--

    __slots__ = "text", "line_ctr", "last_token"

    text: str
    line_ctr: LineCounter
    last_token: Optional[Token]

    def __init__(
        self,
        text: str,
        line_ctr: Optional[LineCounter] = None,
        last_token: Optional[Token] = None,
    ):
        self.text = text
        self.line_ctr = line_ctr or LineCounter(
            b"\n" if isinstance(text, bytes) else "\n"
        )
        self.last_token = last_token

    def __eq__(self, other):
        if not isinstance(other, LexerState):
            return NotImplemented

        return (
            self.text is other.text
            and self.line_ctr == other.line_ctr
            and self.last_token == other.last_token
        )

    def __copy__(self):
        return type(self)(self.text, copy(self.line_ctr), self.last_token)


class LexerThread:
    #--

    def __init__(self, lexer: "Lexer", lexer_state: LexerState):
        self.lexer = lexer
        self.state = lexer_state

    @classmethod
    def from_text(cls, lexer: "Lexer", text: str) -> "LexerThread":
        return cls(lexer, LexerState(text))

    def lex(self, parser_state):
        return self.lexer.lex(self.state, parser_state)

    def __copy__(self):
        return type(self)(self.lexer, copy(self.state))

    _Token = Token


_Callback = Callable[[Token], Token]


class Lexer(ABC):
    #--

    @abstractmethod
    def lex(self, lexer_state: LexerState, parser_state: Any) -> Iterator[Token]:
        return NotImplemented

    def make_lexer_state(self, text):
        #--
        return LexerState(text)


def _check_regex_collisions(
    terminal_to_regexp: Dict[TerminalDef, str],
    comparator,
    strict_mode,
    max_collisions_to_show=8,
):
    if not comparator:
        comparator = interegular.Comparator.from_regexes(terminal_to_regexp)

    ##

    ##

    max_time = 2 if strict_mode else 0.2

    ##

    if comparator.count_marked_pairs() >= max_collisions_to_show:
        return
    for group in classify(terminal_to_regexp, lambda t: t.priority).values():
        for a, b in comparator.check(group, skip_marked=True):
            assert a.priority == b.priority
            ##

            comparator.mark(a, b)

            ##

            message = f"Collision between Terminals {a.name} and {b.name}. "
            try:
                example = comparator.get_example_overlap(
                    a, b, max_time
                ).format_multiline()
            except ValueError:
                ##

                example = "No example could be found fast enough. However, the collision does still exists"
            if strict_mode:
                raise LexError(f"{message}\n{example}")
            logger.warning(
                "%s The lexer will choose between them arbitrarily.\n%s",
                message,
                example,
            )
            if comparator.count_marked_pairs() >= max_collisions_to_show:
                logger.warning("Found 8 regex collisions, will not check for more.")
                return


class AbstractBasicLexer(Lexer):
    terminals_by_name: Dict[str, TerminalDef]

    @abstractmethod
    def __init__(self, conf: "LexerConf", comparator=None) -> None:
        ...

    @abstractmethod
    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token:
        ...

    def lex(self, state: LexerState, parser_state: Any) -> Iterator[Token]:
        with suppress(EOFError):
            while True:
                yield self.next_token(state, parser_state)


class BasicLexer(AbstractBasicLexer):
    terminals: Collection[TerminalDef]
    ignore_types: FrozenSet[str]
    newline_types: FrozenSet[str]
    user_callbacks: Dict[str, _Callback]
    callback: Dict[str, _Callback]
    re: ModuleType

    def __init__(self, conf: "LexerConf", comparator=None) -> None:
        terminals = list(conf.terminals)
        assert all(isinstance(t, TerminalDef) for t in terminals), terminals

        self.re = conf.re_module

        if not conf.skip_validation:
            ##

            terminal_to_regexp = {}
            for t in terminals:
                regexp = t.pattern.to_regexp()
                try:
                    self.re.compile(regexp, conf.g_regex_flags)
                except self.re.error:
                    raise LexError("Cannot compile token %s: %s" % (t.name, t.pattern))

                if t.pattern.min_width == 0:
                    raise LexError(
                        "Lexer does not allow zero-width terminals. (%s: %s)"
                        % (t.name, t.pattern)
                    )
                if t.pattern.type == "re":
                    terminal_to_regexp[t] = regexp

            if not (set(conf.ignore) <= {t.name for t in terminals}):
                raise LexError(
                    "Ignore terminals are not defined: %s"
                    % (set(conf.ignore) - {t.name for t in terminals})
                )

            if has_interegular:
                _check_regex_collisions(terminal_to_regexp, comparator, conf.strict)
            elif conf.strict:
                raise LexError(
                    "interegular must be installed for strict mode. Use `pip install 'lark[interegular]'`."
                )

        ##

        self.newline_types = frozenset(
            t.name for t in terminals if _regexp_has_newline(t.pattern.to_regexp())
        )
        self.ignore_types = frozenset(conf.ignore)

        terminals.sort(
            key=lambda x: (
                -x.priority,
                -x.pattern.max_width,
                -len(x.pattern.value),
                x.name,
            )
        )
        self.terminals = terminals
        self.user_callbacks = conf.callbacks
        self.g_regex_flags = conf.g_regex_flags
        self.use_bytes = conf.use_bytes
        self.terminals_by_name = conf.terminals_by_name

        self._scanner = None

    def _build_scanner(self):
        terminals, self.callback = _create_unless(
            self.terminals, self.g_regex_flags, self.re, self.use_bytes
        )
        assert all(self.callback.values())

        for type_, f in self.user_callbacks.items():
            if type_ in self.callback:
                ##

                self.callback[type_] = CallChain(
                    self.callback[type_], f, lambda t: t.type == type_
                )
            else:
                self.callback[type_] = f

        self._scanner = Scanner(terminals, self.g_regex_flags, self.re, self.use_bytes)

    @property
    def scanner(self):
        if self._scanner is None:
            self._build_scanner()
        return self._scanner

    def match(self, text, pos):
        return self.scanner.match(text, pos)

    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token:
        line_ctr = lex_state.line_ctr
        while line_ctr.char_pos < len(lex_state.text):
            res = self.match(lex_state.text, line_ctr.char_pos)
            if not res:
                allowed = self.scanner.allowed_types - self.ignore_types
                if not allowed:
                    allowed = {"<END-OF-FILE>"}
                raise UnexpectedCharacters(
                    lex_state.text,
                    line_ctr.char_pos,
                    line_ctr.line,
                    line_ctr.column,
                    allowed=allowed,
                    token_history=lex_state.last_token and [lex_state.last_token],
                    state=parser_state,
                    terminals_by_name=self.terminals_by_name,
                )

            value, type_ = res

            ignored = type_ in self.ignore_types
            t = None
            if not ignored or type_ in self.callback:
                t = Token(
                    type_, value, line_ctr.char_pos, line_ctr.line, line_ctr.column
                )
            line_ctr.feed(value, type_ in self.newline_types)
            if t is not None:
                t.end_line = line_ctr.line
                t.end_column = line_ctr.column
                t.end_pos = line_ctr.char_pos
                if t.type in self.callback:
                    t = self.callback[t.type](t)
                if not ignored:
                    if not isinstance(t, Token):
                        raise LexError(
                            "Callbacks must return a token (returned %r)" % t
                        )
                    lex_state.last_token = t
                    return t

        ##

        raise EOFError(self)


class ContextualLexer(Lexer):
    lexers: Dict[int, AbstractBasicLexer]
    root_lexer: AbstractBasicLexer

    BasicLexer: Type[AbstractBasicLexer] = BasicLexer

    def __init__(
        self,
        conf: "LexerConf",
        states: Dict[int, Collection[str]],
        always_accept: Collection[str] = (),
    ) -> None:
        terminals = list(conf.terminals)
        terminals_by_name = conf.terminals_by_name

        trad_conf = copy(conf)
        trad_conf.terminals = terminals

        if has_interegular and not conf.skip_validation:
            comparator = interegular.Comparator.from_regexes(
                {t: t.pattern.to_regexp() for t in terminals}
            )
        else:
            comparator = None
        lexer_by_tokens: Dict[FrozenSet[str], AbstractBasicLexer] = {}
        self.lexers = {}
        for state, accepts in states.items():
            key = frozenset(accepts)
            try:
                lexer = lexer_by_tokens[key]
            except KeyError:
                accepts = set(accepts) | set(conf.ignore) | set(always_accept)
                lexer_conf = copy(trad_conf)
                lexer_conf.terminals = [
                    terminals_by_name[n] for n in accepts if n in terminals_by_name
                ]
                lexer = self.BasicLexer(lexer_conf, comparator)
                lexer_by_tokens[key] = lexer

            self.lexers[state] = lexer

        assert trad_conf.terminals is terminals
        trad_conf.skip_validation = True  ##

        self.root_lexer = self.BasicLexer(trad_conf, comparator)

    def lex(
        self, lexer_state: LexerState, parser_state: "ParserState"
    ) -> Iterator[Token]:
        try:
            while True:
                lexer = self.lexers[parser_state.position]
                yield lexer.next_token(lexer_state, parser_state)
        except EOFError:
            pass
        except UnexpectedCharacters as e:
            ##

            ##

            try:
                last_token = (
                    lexer_state.last_token
                )  ##

                token = self.root_lexer.next_token(lexer_state, parser_state)
                raise UnexpectedToken(
                    token,
                    e.allowed,
                    state=parser_state,
                    token_history=[last_token],
                    terminals_by_name=self.root_lexer.terminals_by_name,
                )
            except UnexpectedCharacters:
                raise e  ##





_ParserArgType: "TypeAlias" = 'Literal["earley", "lalr", "cyk", "auto"]'
_LexerArgType: "TypeAlias" = 'Union[Literal["auto", "basic", "contextual", "dynamic", "dynamic_complete"], Type[Lexer]]'
_LexerCallback = Callable[[Token], Token]
ParserCallbacks = Dict[str, Callable]


class LexerConf(Serialize):
    __serialize_fields__ = (
        "terminals",
        "ignore",
        "g_regex_flags",
        "use_bytes",
        "lexer_type",
    )
    __serialize_namespace__ = (TerminalDef,)

    terminals: Collection[TerminalDef]
    re_module: ModuleType
    ignore: Collection[str]
    postlex: "Optional[PostLex]"
    callbacks: Dict[str, _LexerCallback]
    g_regex_flags: int
    skip_validation: bool
    use_bytes: bool
    lexer_type: Optional[_LexerArgType]
    strict: bool

    def __init__(
        self,
        terminals: Collection[TerminalDef],
        re_module: ModuleType,
        ignore: Collection[str] = (),
        postlex: "Optional[PostLex]" = None,
        callbacks: Optional[Dict[str, _LexerCallback]] = None,
        g_regex_flags: int = 0,
        skip_validation: bool = False,
        use_bytes: bool = False,
        strict: bool = False,
    ):
        self.terminals = terminals
        self.terminals_by_name = {t.name: t for t in self.terminals}
        assert len(self.terminals) == len(self.terminals_by_name)
        self.ignore = ignore
        self.postlex = postlex
        self.callbacks = callbacks or {}
        self.g_regex_flags = g_regex_flags
        self.re_module = re_module
        self.skip_validation = skip_validation
        self.use_bytes = use_bytes
        self.strict = strict
        self.lexer_type = None

    def _deserialize(self):
        self.terminals_by_name = {t.name: t for t in self.terminals}

    def __deepcopy__(self, memo=None):
        return type(self)(
            deepcopy(self.terminals, memo),
            self.re_module,
            deepcopy(self.ignore, memo),
            deepcopy(self.postlex, memo),
            deepcopy(self.callbacks, memo),
            deepcopy(self.g_regex_flags, memo),
            deepcopy(self.skip_validation, memo),
            deepcopy(self.use_bytes, memo),
        )


class ParserConf(Serialize):
    __serialize_fields__ = "rules", "start", "parser_type"

    rules: List["Rule"]
    callbacks: ParserCallbacks
    start: List[str]
    parser_type: _ParserArgType

    def __init__(
        self, rules: List["Rule"], callbacks: ParserCallbacks, start: List[str]
    ):
        assert isinstance(start, list)
        self.rules = rules
        self.callbacks = callbacks
        self.start = start



from functools import partial, wraps
from itertools import product


class ExpandSingleChild:
    def __init__(self, node_builder):
        self.node_builder = node_builder

    def __call__(self, children):
        if len(children) == 1:
            return children[0]
        else:
            return self.node_builder(children)


class PropagatePositions:
    def __init__(self, node_builder, node_filter=None):
        self.node_builder = node_builder
        self.node_filter = node_filter

    def __call__(self, children):
        res = self.node_builder(children)

        if isinstance(res, Tree):
            ##

            ##

            ##

            ##


            res_meta = res.meta

            first_meta = self._pp_get_meta(children)
            if first_meta is not None:
                if not hasattr(res_meta, "line"):
                    ##

                    res_meta.line = getattr(
                        first_meta, "container_line", first_meta.line
                    )
                    res_meta.column = getattr(
                        first_meta, "container_column", first_meta.column
                    )
                    res_meta.start_pos = getattr(
                        first_meta, "container_start_pos", first_meta.start_pos
                    )
                    res_meta.empty = False

                res_meta.container_line = getattr(
                    first_meta, "container_line", first_meta.line
                )
                res_meta.container_column = getattr(
                    first_meta, "container_column", first_meta.column
                )
                res_meta.container_start_pos = getattr(
                    first_meta, "container_start_pos", first_meta.start_pos
                )

            last_meta = self._pp_get_meta(reversed(children))
            if last_meta is not None:
                if not hasattr(res_meta, "end_line"):
                    res_meta.end_line = getattr(
                        last_meta, "container_end_line", last_meta.end_line
                    )
                    res_meta.end_column = getattr(
                        last_meta, "container_end_column", last_meta.end_column
                    )
                    res_meta.end_pos = getattr(
                        last_meta, "container_end_pos", last_meta.end_pos
                    )
                    res_meta.empty = False

                res_meta.container_end_line = getattr(
                    last_meta, "container_end_line", last_meta.end_line
                )
                res_meta.container_end_column = getattr(
                    last_meta, "container_end_column", last_meta.end_column
                )
                res_meta.container_end_pos = getattr(
                    last_meta, "container_end_pos", last_meta.end_pos
                )

        return res

    def _pp_get_meta(self, children):
        for c in children:
            if self.node_filter is not None and not self.node_filter(c):
                continue
            if isinstance(c, Tree):
                if not c.meta.empty:
                    return c.meta
            elif isinstance(c, Token):
                return c
            elif hasattr(c, "__lark_meta__"):
                return c.__lark_meta__()


def make_propagate_positions(option):
    if callable(option):
        return partial(PropagatePositions, node_filter=option)
    elif option is True:
        return PropagatePositions
    elif option is False:
        return None

    raise ConfigurationError("Invalid option for propagate_positions: %r" % option)


class ChildFilter:
    def __init__(self, to_include, append_none, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include
        self.append_none = append_none

    def __call__(self, children):
        filtered = []

        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                filtered += children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR(ChildFilter):
    #--

    def __call__(self, children):
        filtered = []
        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:  ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR_NoPlaceholders(ChildFilter):
    #--

    def __init__(self, to_include, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include

    def __call__(self, children):
        filtered = []
        for i, to_expand in self.to_include:
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:  ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])
        return self.node_builder(filtered)


def _should_expand(sym):
    return not sym.is_term and sym.name.startswith("_")


def maybe_create_child_filter(
    expansion, keep_all_tokens, ambiguous, _empty_indices: List[bool]
):
    ##

    if _empty_indices:
        assert _empty_indices.count(False) == len(expansion)
        s = "".join(str(int(b)) for b in _empty_indices)
        empty_indices = [len(ones) for ones in s.split("0")]
        assert len(empty_indices) == len(expansion) + 1, (empty_indices, len(expansion))
    else:
        empty_indices = [0] * (len(expansion) + 1)

    to_include = []
    nones_to_add = 0
    for i, sym in enumerate(expansion):
        nones_to_add += empty_indices[i]
        if keep_all_tokens or not (sym.is_term and sym.filter_out):
            to_include.append((i, _should_expand(sym), nones_to_add))
            nones_to_add = 0

    nones_to_add += empty_indices[len(expansion)]

    if (
        _empty_indices
        or len(to_include) < len(expansion)
        or any(to_expand for i, to_expand, _ in to_include)
    ):
        if _empty_indices or ambiguous:
            return partial(
                ChildFilter if ambiguous else ChildFilterLALR, to_include, nones_to_add
            )
        else:
            ##

            return partial(
                ChildFilterLALR_NoPlaceholders, [(i, x) for i, x, _ in to_include]
            )


class AmbiguousExpander:
    #--

    def __init__(self, to_expand, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class
        self.to_expand = to_expand

    def __call__(self, children):
        def _is_ambig_tree(t):
            return hasattr(t, "data") and t.data == "_ambig"

        ##

        ##

        ##

        ##

        ambiguous = []
        for i, child in enumerate(children):
            if _is_ambig_tree(child):
                if i in self.to_expand:
                    ambiguous.append(i)

                child.expand_kids_by_data("_ambig")

        if not ambiguous:
            return self.node_builder(children)

        expand = [
            child.children if i in ambiguous else (child,)
            for i, child in enumerate(children)
        ]
        return self.tree_class(
            "_ambig", [self.node_builder(list(f)) for f in product(*expand)]
        )


def maybe_create_ambiguous_expander(tree_class, expansion, keep_all_tokens):
    to_expand = [
        i
        for i, sym in enumerate(expansion)
        if keep_all_tokens
        or ((not (sym.is_term and sym.filter_out)) and _should_expand(sym))
    ]
    if to_expand:
        return partial(AmbiguousExpander, to_expand, tree_class)


class AmbiguousIntermediateExpander:
    #--

    def __init__(self, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class

    def __call__(self, children):
        def _is_iambig_tree(child):
            return hasattr(child, "data") and child.data == "_iambig"

        def _collapse_iambig(children):
            #--

            ##

            ##

            if children and _is_iambig_tree(children[0]):
                iambig_node = children[0]
                result = []
                for grandchild in iambig_node.children:
                    collapsed = _collapse_iambig(grandchild.children)
                    if collapsed:
                        for child in collapsed:
                            child.children += children[1:]
                        result += collapsed
                    else:
                        new_tree = self.tree_class(
                            "_inter", grandchild.children + children[1:]
                        )
                        result.append(new_tree)
                return result

        collapsed = _collapse_iambig(children)
        if collapsed:
            processed_nodes = [self.node_builder(c.children) for c in collapsed]
            return self.tree_class("_ambig", processed_nodes)

        return self.node_builder(children)


def inplace_transformer(func):
    @wraps(func)
    def f(children):
        ##

        tree = Tree(func.__name__, children)
        return func(tree)

    return f


def apply_visit_wrapper(func, name, wrapper):
    if wrapper is _vargs_meta or wrapper is _vargs_meta_inline:
        raise NotImplementedError("Meta args not supported for internal transformer")

    @wraps(func)
    def f(children):
        return wrapper(func, name, children, None)

    return f


class ParseTreeBuilder:
    def __init__(
        self,
        rules,
        tree_class,
        propagate_positions=False,
        ambiguous=False,
        maybe_placeholders=False,
    ):
        self.tree_class = tree_class
        self.propagate_positions = propagate_positions
        self.ambiguous = ambiguous
        self.maybe_placeholders = maybe_placeholders

        self.rule_builders = list(self._init_builders(rules))

    def _init_builders(self, rules):
        propagate_positions = make_propagate_positions(self.propagate_positions)

        for rule in rules:
            options = rule.options
            keep_all_tokens = options.keep_all_tokens
            expand_single_child = options.expand1

            wrapper_chain = list(
                filter(
                    None,
                    [
                        (expand_single_child and not rule.alias) and ExpandSingleChild,
                        maybe_create_child_filter(
                            rule.expansion,
                            keep_all_tokens,
                            self.ambiguous,
                            options.empty_indices if self.maybe_placeholders else None,
                        ),
                        propagate_positions,
                        self.ambiguous
                        and maybe_create_ambiguous_expander(
                            self.tree_class, rule.expansion, keep_all_tokens
                        ),
                        self.ambiguous
                        and partial(AmbiguousIntermediateExpander, self.tree_class),
                    ],
                )
            )

            yield rule, wrapper_chain

    def create_callback(self, transformer=None):
        callbacks = {}

        default_handler = getattr(transformer, "__default__", None)
        if default_handler:

            def default_callback(data, children):
                return default_handler(data, children, None)

        else:
            default_callback = self.tree_class

        for rule, wrapper_chain in self.rule_builders:
            user_callback_name = (
                rule.alias or rule.options.template_source or rule.origin.name
            )
            try:
                f = getattr(transformer, user_callback_name)
                wrapper = getattr(f, "visit_wrapper", None)
                if wrapper is not None:
                    f = apply_visit_wrapper(f, user_callback_name, wrapper)
                elif isinstance(transformer, Transformer_InPlace):
                    f = inplace_transformer(f)
            except AttributeError:
                f = partial(default_callback, user_callback_name)

            for w in wrapper_chain:
                f = w(f)

            if rule in callbacks:
                raise GrammarError("Rule '%s' already exists" % (rule,))

            callbacks[rule] = f

        return callbacks





class Action:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

    def __repr__(self):
        return str(self)


Shift = Action("Shift")
Reduce = Action("Reduce")

StateT = TypeVar("StateT")


class ParseTableBase(Generic[StateT]):
    states: Dict[StateT, Dict[str, Tuple]]
    start_states: Dict[str, StateT]
    end_states: Dict[str, StateT]

    def __init__(self, states, start_states, end_states):
        self.states = states
        self.start_states = start_states
        self.end_states = end_states

    def serialize(self, memo):
        tokens = Enumerator()

        states = {
            state: {
                tokens.get(token): (
                    (1, arg.serialize(memo)) if action is Reduce else (0, arg)
                )
                for token, (action, arg) in actions.items()
            }
            for state, actions in self.states.items()
        }

        return {
            "tokens": tokens.reversed(),
            "states": states,
            "start_states": self.start_states,
            "end_states": self.end_states,
        }

    @classmethod
    def deserialize(cls, data, memo):
        tokens = data["tokens"]
        states = {
            state: {
                tokens[token]: (
                    (Reduce, Rule.deserialize(arg, memo))
                    if action == 1
                    else (Shift, arg)
                )
                for token, (action, arg) in actions.items()
            }
            for state, actions in data["states"].items()
        }
        return cls(states, data["start_states"], data["end_states"])


class ParseTable(ParseTableBase["State"]):
    #--

    pass


class IntParseTable(ParseTableBase[int]):
    #--

    @classmethod
    def from_ParseTable(cls, parse_table: ParseTable):
        enum = list(parse_table.states)
        state_to_idx: Dict["State", int] = {s: i for i, s in enumerate(enum)}
        int_states = {}

        for s, la in parse_table.states.items():
            la = {
                k: (v[0], state_to_idx[v[1]]) if v[0] is Shift else v
                for k, v in la.items()
            }
            int_states[state_to_idx[s]] = la

        start_states = {
            start: state_to_idx[s] for start, s in parse_table.start_states.items()
        }
        end_states = {
            start: state_to_idx[s] for start, s in parse_table.end_states.items()
        }
        return cls(int_states, start_states, end_states)





class ParseConf(Generic[StateT]):
    __slots__ = (
        "parse_table",
        "callbacks",
        "start",
        "start_state",
        "end_state",
        "states",
    )

    parse_table: ParseTableBase[StateT]
    callbacks: ParserCallbacks
    start: str

    start_state: StateT
    end_state: StateT
    states: Dict[StateT, Dict[str, tuple]]

    def __init__(
        self,
        parse_table: ParseTableBase[StateT],
        callbacks: ParserCallbacks,
        start: str,
    ):
        self.parse_table = parse_table

        self.start_state = self.parse_table.start_states[start]
        self.end_state = self.parse_table.end_states[start]
        self.states = self.parse_table.states

        self.callbacks = callbacks
        self.start = start


class ParserState(Generic[StateT]):
    __slots__ = "parse_conf", "lexer", "state_stack", "value_stack"

    parse_conf: ParseConf[StateT]
    lexer: LexerThread
    state_stack: List[StateT]
    value_stack: list

    def __init__(
        self,
        parse_conf: ParseConf[StateT],
        lexer: LexerThread,
        state_stack=None,
        value_stack=None,
    ):
        self.parse_conf = parse_conf
        self.lexer = lexer
        self.state_stack = state_stack or [self.parse_conf.start_state]
        self.value_stack = value_stack or []

    @property
    def position(self) -> StateT:
        return self.state_stack[-1]

    ##

    def __eq__(self, other) -> bool:
        if not isinstance(other, ParserState):
            return NotImplemented
        return (
            len(self.state_stack) == len(other.state_stack)
            and self.position == other.position
        )

    def __copy__(self):
        return type(self)(
            self.parse_conf,
            self.lexer,  ##

            copy(self.state_stack),
            deepcopy(self.value_stack),
        )

    def copy(self) -> "ParserState[StateT]":
        return copy(self)

    def feed_token(self, token: Token, is_end=False) -> Any:
        state_stack = self.state_stack
        value_stack = self.value_stack
        states = self.parse_conf.states
        end_state = self.parse_conf.end_state
        callbacks = self.parse_conf.callbacks

        while True:
            state = state_stack[-1]
            try:
                action, arg = states[state][token.type]
            except KeyError:
                expected = {s for s in states[state].keys() if s.isupper()}
                raise UnexpectedToken(
                    token, expected, state=self, interactive_parser=None
                )

            assert arg != end_state

            if action is Shift:
                ##

                assert not is_end
                state_stack.append(arg)
                value_stack.append(
                    token
                    if token.type not in callbacks
                    else callbacks[token.type](token)
                )
                return
            else:
                ##

                rule = arg
                size = len(rule.expansion)
                if size:
                    s = value_stack[-size:]
                    del state_stack[-size:]
                    del value_stack[-size:]
                else:
                    s = []

                value = callbacks[rule](s) if callbacks else s

                _action, new_state = states[state_stack[-1]][rule.origin.name]
                assert _action is Shift
                state_stack.append(new_state)
                value_stack.append(value)

                if is_end and state_stack[-1] == end_state:
                    return value_stack[-1]





class LALR_Parser(Serialize):
    def __init__(
        self, parser_conf: ParserConf, debug: bool = False, strict: bool = False
    ):
        analysis = LALR_Analyzer(parser_conf, debug=debug, strict=strict)
        analysis.compute_lalr()
        callbacks = parser_conf.callbacks

        self._parse_table = analysis.parse_table
        self.parser_conf = parser_conf
        self.parser = _Parser(analysis.parse_table, callbacks, debug)

    @classmethod
    def deserialize(cls, data, memo, callbacks, debug=False):
        inst = cls.__new__(cls)
        inst._parse_table = IntParseTable.deserialize(data, memo)
        inst.parser = _Parser(inst._parse_table, callbacks, debug)
        return inst

    def serialize(self, memo: Any = None) -> Dict[str, Any]:
        return self._parse_table.serialize(memo)

    def parse_interactive(self, lexer: LexerThread, start: str):
        return self.parser.parse(lexer, start, start_interactive=True)

    def parse(self, lexer, start, on_error=None):
        try:
            return self.parser.parse(lexer, start)
        except UnexpectedInput as e:
            if on_error is None:
                raise

            while True:
                if isinstance(e, UnexpectedCharacters):
                    s = e.interactive_parser.lexer_thread.state
                    p = s.line_ctr.char_pos

                if not on_error(e):
                    raise e

                if isinstance(e, UnexpectedCharacters):
                    ##

                    if p == s.line_ctr.char_pos:
                        s.line_ctr.feed(s.text[p : p + 1])

                try:
                    return e.interactive_parser.resume_parse()
                except UnexpectedToken as e2:
                    if (
                        isinstance(e, UnexpectedToken)
                        and e.token.type == e2.token.type == "$END"
                        and e.interactive_parser == e2.interactive_parser
                    ):
                        ##

                        raise e2
                    e = e2
                except UnexpectedCharacters as e2:
                    e = e2


class _Parser:
    parse_table: ParseTableBase
    callbacks: ParserCallbacks
    debug: bool

    def __init__(
        self,
        parse_table: ParseTableBase,
        callbacks: ParserCallbacks,
        debug: bool = False,
    ):
        self.parse_table = parse_table
        self.callbacks = callbacks
        self.debug = debug

    def parse(
        self,
        lexer: LexerThread,
        start: str,
        value_stack=None,
        state_stack=None,
        start_interactive=False,
    ):
        parse_conf = ParseConf(self.parse_table, self.callbacks, start)
        parser_state = ParserState(parse_conf, lexer, state_stack, value_stack)
        if start_interactive:
            return InteractiveParser(self, parser_state, parser_state.lexer)
        return self.parse_from_state(parser_state)

    def parse_from_state(self, state: ParserState, last_token: Optional[Token] = None):
        #--
        try:
            token = last_token
            for token in state.lexer.lex(state):
                assert token is not None
                state.feed_token(token)

            end_token = (
                Token.new_borrow_pos("$END", "", token)
                if token
                else Token("$END", "", 0, 1, 1)
            )
            return state.feed_token(end_token, True)
        except UnexpectedInput as e:
            try:
                e.interactive_parser = InteractiveParser(self, state, state.lexer)
            except NameError:
                pass
            raise e
        except Exception as e:
            if self.debug:
                print("")
                print("STATE STACK DUMP")
                print("----------------")
                for i, s in enumerate(state.state_stack):
                    print("%d)" % i, s)
                print("")

            raise





class InteractiveParser:
    #--

    def __init__(self, parser, parser_state, lexer_thread: LexerThread):
        self.parser = parser
        self.parser_state = parser_state
        self.lexer_thread = lexer_thread
        self.result = None

    @property
    def lexer_state(self) -> LexerThread:
        warnings.warn(
            "lexer_state will be removed in subsequent releases. Use lexer_thread instead.",
            DeprecationWarning,
        )
        return self.lexer_thread

    def feed_token(self, token: Token):
        #--
        return self.parser_state.feed_token(token, token.type == "$END")

    def iter_parse(self) -> Iterator[Token]:
        #--
        for token in self.lexer_thread.lex(self.parser_state):
            yield token
            self.result = self.feed_token(token)

    def exhaust_lexer(self) -> List[Token]:
        #--
        return list(self.iter_parse())

    def feed_eof(self, last_token=None):
        #--
        eof = (
            Token.new_borrow_pos("$END", "", last_token)
            if last_token is not None
            else self.lexer_thread._Token("$END", "", 0, 1, 1)
        )
        return self.feed_token(eof)

    def __copy__(self):
        #--
        return type(self)(
            self.parser,
            copy(self.parser_state),
            copy(self.lexer_thread),
        )

    def copy(self):
        return copy(self)

    def __eq__(self, other):
        if not isinstance(other, InteractiveParser):
            return False

        return (
            self.parser_state == other.parser_state
            and self.lexer_thread == other.lexer_thread
        )

    def as_immutable(self):
        #--
        p = copy(self)
        return ImmutableInteractiveParser(p.parser, p.parser_state, p.lexer_thread)

    def pretty(self):
        #--
        out = ["Parser choices:"]
        for k, v in self.choices().items():
            out.append("\t- %s -> %r" % (k, v))
        out.append("stack size: %s" % len(self.parser_state.state_stack))
        return "\n".join(out)

    def choices(self):
        #--
        return self.parser_state.parse_conf.parse_table.states[
            self.parser_state.position
        ]

    def accepts(self):
        #--
        accepts = set()
        conf_no_callbacks = copy(self.parser_state.parse_conf)
        ##

        ##

        conf_no_callbacks.callbacks = {}
        for t in self.choices():
            if t.isupper():  ##

                new_cursor = copy(self)
                new_cursor.parser_state.parse_conf = conf_no_callbacks
                try:
                    new_cursor.feed_token(self.lexer_thread._Token(t, ""))
                except UnexpectedToken:
                    pass
                else:
                    accepts.add(t)
        return accepts

    def resume_parse(self):
        #--
        return self.parser.parse_from_state(
            self.parser_state, last_token=self.lexer_thread.state.last_token
        )


class ImmutableInteractiveParser(InteractiveParser):
    #--

    result = None

    def __hash__(self):
        return hash((self.parser_state, self.lexer_thread))

    def feed_token(self, token):
        c = copy(self)
        c.result = InteractiveParser.feed_token(c, token)
        return c

    def exhaust_lexer(self):
        #--
        cursor = self.as_mutable()
        cursor.exhaust_lexer()
        return cursor.as_immutable()

    def as_mutable(self):
        #--
        p = copy(self)
        return InteractiveParser(p.parser, p.parser_state, p.lexer_thread)





def _wrap_lexer(lexer_class):
    future_interface = getattr(lexer_class, "__future_interface__", False)
    if future_interface:
        return lexer_class
    else:

        class CustomLexerWrapper(Lexer):
            def __init__(self, lexer_conf):
                self.lexer = lexer_class(lexer_conf)

            def lex(self, lexer_state, parser_state):
                return self.lexer.lex(lexer_state.text)

        return CustomLexerWrapper


def _deserialize_parsing_frontend(data, memo, lexer_conf, callbacks, options):
    parser_conf = ParserConf.deserialize(data["parser_conf"], memo)
    cls = (options and options._plugins.get("LALR_Parser")) or LALR_Parser
    parser = cls.deserialize(data["parser"], memo, callbacks, options.debug)
    parser_conf.callbacks = callbacks
    return ParsingFrontend(lexer_conf, parser_conf, options, parser=parser)


_parser_creators: "Dict[str, Callable[[LexerConf, Any, Any], Any]]" = {}


class ParsingFrontend(Serialize):
    __serialize_fields__ = "lexer_conf", "parser_conf", "parser"

    lexer_conf: LexerConf
    parser_conf: ParserConf
    options: Any

    def __init__(
        self, lexer_conf: LexerConf, parser_conf: ParserConf, options, parser=None
    ):
        self.parser_conf = parser_conf
        self.lexer_conf = lexer_conf
        self.options = options

        ##

        if parser:  ##

            self.parser = parser
        else:
            create_parser = _parser_creators.get(parser_conf.parser_type)
            assert (
                create_parser is not None
            ), "{} is not supported in standalone mode".format(parser_conf.parser_type)
            self.parser = create_parser(lexer_conf, parser_conf, options)

        ##

        lexer_type = lexer_conf.lexer_type
        self.skip_lexer = False
        if lexer_type in ("dynamic", "dynamic_complete"):
            assert lexer_conf.postlex is None
            self.skip_lexer = True
            return

        if isinstance(lexer_type, type):
            assert issubclass(lexer_type, Lexer)
            self.lexer = _wrap_lexer(lexer_type)(lexer_conf)
        elif isinstance(lexer_type, str):
            create_lexer = {
                "basic": create_basic_lexer,
                "contextual": create_contextual_lexer,
            }[lexer_type]
            self.lexer = create_lexer(
                lexer_conf, self.parser, lexer_conf.postlex, options
            )
        else:
            raise TypeError("Bad value for lexer_type: {lexer_type}")

        if lexer_conf.postlex:
            self.lexer = PostLexConnector(self.lexer, lexer_conf.postlex)

    def _verify_start(self, start=None):
        if start is None:
            start_decls = self.parser_conf.start
            if len(start_decls) > 1:
                raise ConfigurationError(
                    "Lark initialized with more than 1 possible start rule. Must specify which start rule to parse",
                    start_decls,
                )
            (start,) = start_decls
        elif start not in self.parser_conf.start:
            raise ConfigurationError(
                "Unknown start rule %s. Must be one of %r"
                % (start, self.parser_conf.start)
            )
        return start

    def _make_lexer_thread(self, text: str) -> Union[str, LexerThread]:
        cls = (self.options and self.options._plugins.get("LexerThread")) or LexerThread
        return text if self.skip_lexer else cls.from_text(self.lexer, text)

    def parse(self, text: str, start=None, on_error=None):
        chosen_start = self._verify_start(start)
        kw = {} if on_error is None else {"on_error": on_error}
        stream = self._make_lexer_thread(text)
        return self.parser.parse(stream, chosen_start, **kw)

    def parse_interactive(self, text: Optional[str] = None, start=None):
        ##

        ##

        chosen_start = self._verify_start(start)
        if self.parser_conf.parser_type != "lalr":
            raise ConfigurationError(
                "parse_interactive() currently only works with parser='lalr' "
            )
        stream = self._make_lexer_thread(text)  ##

        return self.parser.parse_interactive(stream, chosen_start)


def _validate_frontend_args(parser, lexer) -> None:
    assert_config(parser, ("lalr", "earley", "cyk"))
    if not isinstance(lexer, type):  ##

        expected = {
            "lalr": ("basic", "contextual"),
            "earley": ("basic", "dynamic", "dynamic_complete"),
            "cyk": ("basic",),
        }[parser]
        assert_config(
            lexer,
            expected,
            "Parser %r does not support lexer %%r, expected one of %%s" % parser,
        )


def _get_lexer_callbacks(transformer, terminals):
    result = {}
    for terminal in terminals:
        callback = getattr(transformer, terminal.name, None)
        if callback is not None:
            result[terminal.name] = callback
    return result


class PostLexConnector:
    def __init__(self, lexer, postlexer):
        self.lexer = lexer
        self.postlexer = postlexer

    def lex(self, lexer_state, parser_state):
        i = self.lexer.lex(lexer_state, parser_state)
        return self.postlexer.process(i)


def create_basic_lexer(lexer_conf, parser, postlex, options) -> BasicLexer:
    cls = (options and options._plugins.get("BasicLexer")) or BasicLexer
    return cls(lexer_conf)


def create_contextual_lexer(
    lexer_conf: LexerConf, parser, postlex, options
) -> ContextualLexer:
    cls = (options and options._plugins.get("ContextualLexer")) or ContextualLexer
    parse_table: ParseTableBase[int] = parser._parse_table
    states: Dict[int, Collection[str]] = {
        idx: list(t.keys()) for idx, t in parse_table.states.items()
    }
    always_accept: Collection[str] = postlex.always_accept if postlex else ()
    return cls(lexer_conf, states, always_accept=always_accept)


def create_lalr_parser(
    lexer_conf: LexerConf, parser_conf: ParserConf, options=None
) -> LALR_Parser:
    debug = options.debug if options else False
    strict = options.strict if options else False
    cls = (options and options._plugins.get("LALR_Parser")) or LALR_Parser
    return cls(parser_conf, debug=debug, strict=strict)


_parser_creators["lalr"] = create_lalr_parser




class PostLex(ABC):
    @abstractmethod
    def process(self, stream: Iterator[Token]) -> Iterator[Token]:
        return stream

    always_accept: Iterable[str] = ()


class LarkOptions(Serialize):
    #--

    start: List[str]
    debug: bool
    strict: bool
    transformer: "Optional[Transformer]"
    propagate_positions: Union[bool, str]
    maybe_placeholders: bool
    cache: Union[bool, str]
    regex: bool
    g_regex_flags: int
    keep_all_tokens: bool
    tree_class: Optional[Callable[[str, List], Any]]
    parser: _ParserArgType
    lexer: _LexerArgType
    ambiguity: 'Literal["auto", "resolve", "explicit", "forest"]'
    postlex: Optional[PostLex]
    priority: 'Optional[Literal["auto", "normal", "invert"]]'
    lexer_callbacks: Dict[str, Callable[[Token], Token]]
    use_bytes: bool
    ordered_sets: bool
    edit_terminals: Optional[Callable[[TerminalDef], TerminalDef]]
    import_paths: "List[Union[str, Callable[[Union[None, str, PackageResource], str], Tuple[str, str]]]]"
    source_path: Optional[str]

    OPTIONS_DOC = r"""
    **===  General Options  ===**

    start
            The start symbol. Either a string, or a list of strings for multiple possible starts (Default: "start")
    debug
            Display debug information and extra warnings. Use only when debugging (Default: ``False``)
            When used with Earley, it generates a forest graph as "sppf.png", if 'dot' is installed.
    strict
            Throw an exception on any potential ambiguity, including shift/reduce conflicts, and regex collisions.
    transformer
            Applies the transformer to every parse tree (equivalent to applying it after the parse, but faster)
    propagate_positions
            Propagates positional attributes into the 'meta' attribute of all tree branches.
            Sets attributes: (line, column, end_line, end_column, start_pos, end_pos,
                              container_line, container_column, container_end_line, container_end_column)
            Accepts ``False``, ``True``, or a callable, which will filter which nodes to ignore when propagating.
    maybe_placeholders
            When ``True``, the ``[]`` operator returns ``None`` when not matched.
            When ``False``,  ``[]`` behaves like the ``?`` operator, and returns no value at all.
            (default= ``True``)
    cache
            Cache the results of the Lark grammar analysis, for x2 to x3 faster loading. LALR only for now.

            - When ``False``, does nothing (default)
            - When ``True``, caches to a temporary file in the local directory
            - When given a string, caches to the path pointed by the string
    regex
            When True, uses the ``regex`` module instead of the stdlib ``re``.
    g_regex_flags
            Flags that are applied to all terminals (both regex and strings)
    keep_all_tokens
            Prevent the tree builder from automagically removing "punctuation" tokens (Default: ``False``)
    tree_class
            Lark will produce trees comprised of instances of this class instead of the default ``lark.Tree``.

    **=== Algorithm Options ===**

    parser
            Decides which parser engine to use. Accepts "earley" or "lalr". (Default: "earley").
            (there is also a "cyk" option for legacy)
    lexer
            Decides whether or not to use a lexer stage

            - "auto" (default): Choose for me based on the parser
            - "basic": Use a basic lexer
            - "contextual": Stronger lexer (only works with parser="lalr")
            - "dynamic": Flexible and powerful (only with parser="earley")
            - "dynamic_complete": Same as dynamic, but tries *every* variation of tokenizing possible.
    ambiguity
            Decides how to handle ambiguity in the parse. Only relevant if parser="earley"

            - "resolve": The parser will automatically choose the simplest derivation
              (it chooses consistently: greedy for tokens, non-greedy for rules)
            - "explicit": The parser will return all derivations wrapped in "_ambig" tree nodes (i.e. a forest).
            - "forest": The parser will return the root of the shared packed parse forest.

    **=== Misc. / Domain Specific Options ===**

    postlex
            Lexer post-processing (Default: ``None``) Only works with the basic and contextual lexers.
    priority
            How priorities should be evaluated - "auto", ``None``, "normal", "invert" (Default: "auto")
    lexer_callbacks
            Dictionary of callbacks for the lexer. May alter tokens during lexing. Use with caution.
    use_bytes
            Accept an input of type ``bytes`` instead of ``str``.
    ordered_sets
            Should Earley use ordered-sets to achieve stable output (~10% slower than regular sets. Default: True)
    edit_terminals
            A callback for editing the terminals before parse.
    import_paths
            A List of either paths or loader functions to specify from where grammars are imported
    source_path
            Override the source of from where the grammar was loaded. Useful for relative imports and unconventional grammar loading
    **=== End of Options ===**
    """
    if __doc__:
        __doc__ += OPTIONS_DOC

    ##

    ##

    ##

    ##

    ##

    ##

    _defaults: Dict[str, Any] = {
        "debug": False,
        "strict": False,
        "keep_all_tokens": False,
        "tree_class": None,
        "cache": False,
        "postlex": None,
        "parser": "earley",
        "lexer": "auto",
        "transformer": None,
        "start": "start",
        "priority": "auto",
        "ambiguity": "auto",
        "regex": False,
        "propagate_positions": False,
        "lexer_callbacks": {},
        "maybe_placeholders": True,
        "edit_terminals": None,
        "g_regex_flags": 0,
        "use_bytes": False,
        "ordered_sets": True,
        "import_paths": [],
        "source_path": None,
        "_plugins": {},
    }

    def __init__(self, options_dict: Dict[str, Any]) -> None:
        o = dict(options_dict)

        options = {}
        for name, default in self._defaults.items():
            if name in o:
                value = o.pop(name)
                if isinstance(default, bool) and name not in (
                    "cache",
                    "use_bytes",
                    "propagate_positions",
                ):
                    value = bool(value)
            else:
                value = default

            options[name] = value

        if isinstance(options["start"], str):
            options["start"] = [options["start"]]

        self.__dict__["options"] = options

        assert_config(self.parser, ("earley", "lalr", "cyk", None))

        if self.parser == "earley" and self.transformer:
            raise ConfigurationError(
                "Cannot specify an embedded transformer when using the Earley algorithm. "
                "Please use your transformer on the resulting parse tree, or use a different algorithm (i.e. LALR)"
            )

        if o:
            raise ConfigurationError("Unknown options: %s" % o.keys())

    def __getattr__(self, name: str) -> Any:
        try:
            return self.__dict__["options"][name]
        except KeyError as e:
            raise AttributeError(e)

    def __setattr__(self, name: str, value: str) -> None:
        assert_config(
            name, self.options.keys(), "%r isn't a valid option. Expected one of: %s"
        )
        self.options[name] = value

    def serialize(self, memo=None) -> Dict[str, Any]:
        return self.options

    @classmethod
    def deserialize(
        cls, data: Dict[str, Any], memo: Dict[int, Union[TerminalDef, Rule]]
    ) -> "LarkOptions":
        return cls(data)


##

##

_LOAD_ALLOWED_OPTIONS = {
    "postlex",
    "transformer",
    "lexer_callbacks",
    "use_bytes",
    "debug",
    "g_regex_flags",
    "regex",
    "propagate_positions",
    "tree_class",
    "_plugins",
}

_VALID_PRIORITY_OPTIONS = ("auto", "normal", "invert", None)
_VALID_AMBIGUITY_OPTIONS = ("auto", "resolve", "explicit", "forest")


_T = TypeVar("_T", bound="Lark")


class Lark(Serialize):
    #--

    source_path: str
    source_grammar: str
    grammar: "Grammar"
    options: LarkOptions
    lexer: Lexer
    parser: "ParsingFrontend"
    terminals: Collection[TerminalDef]

    def __init__(self, grammar: "Union[Grammar, str, IO[str]]", **options) -> None:
        self.options = LarkOptions(options)
        re_module: types.ModuleType

        ##

        use_regex = self.options.regex
        if use_regex:
            if _has_regex:
                re_module = regex
            else:
                raise ImportError(
                    "`regex` module must be installed if calling `Lark(regex=True)`."
                )
        else:
            re_module = re

        ##

        if self.options.source_path is None:
            try:
                self.source_path = grammar.name  ##

            except AttributeError:
                self.source_path = "<string>"
        else:
            self.source_path = self.options.source_path

        ##

        try:
            read = grammar.read  ##

        except AttributeError:
            pass
        else:
            grammar = read()

        cache_fn = None
        cache_sha256 = None
        if isinstance(grammar, str):
            self.source_grammar = grammar
            if self.options.use_bytes:
                if not isascii(grammar):
                    raise ConfigurationError(
                        "Grammar must be ascii only, when use_bytes=True"
                    )

            if self.options.cache:
                if self.options.parser != "lalr":
                    raise ConfigurationError(
                        "cache only works with parser='lalr' for now"
                    )

                unhashable = (
                    "transformer",
                    "postlex",
                    "lexer_callbacks",
                    "edit_terminals",
                    "_plugins",
                )
                options_str = "".join(
                    k + str(v) for k, v in options.items() if k not in unhashable
                )
                from . import __version__

                s = grammar + options_str + __version__ + str(sys.version_info[:2])
                cache_sha256 = sha256_digest(s)

                if isinstance(self.options.cache, str):
                    cache_fn = self.options.cache
                else:
                    if self.options.cache is not True:
                        raise ConfigurationError("cache argument must be bool or str")

                    try:
                        username = getpass.getuser()
                    except Exception:
                        ##

                        ##

                        ##

                        username = "unknown"

                    cache_fn = (
                        tempfile.gettempdir()
                        + "/.lark_cache_%s_%s_%s_%s.tmp"
                        % (username, cache_sha256, *sys.version_info[:2])
                    )

                old_options = self.options
                try:
                    with FS.open(cache_fn, "rb") as f:
                        logger.debug("Loading grammar from cache: %s", cache_fn)
                        ##

                        for name in set(options) - _LOAD_ALLOWED_OPTIONS:
                            del options[name]
                        file_sha256 = f.readline().rstrip(b"\n")
                        cached_used_files = pickle.load(f)
                        if file_sha256 == cache_sha256.encode(
                            "utf8"
                        ) and verify_used_files(cached_used_files):
                            cached_parser_data = pickle.load(f)
                            self._load(cached_parser_data, **options)
                            return
                except FileNotFoundError:
                    ##

                    pass
                except (
                    Exception
                ):  ##

                    logger.exception(
                        "Failed to load Lark from cache: %r. We will try to carry on.",
                        cache_fn,
                    )

                    ##

                    ##

                    self.options = old_options

            ##

            self.grammar, used_files = load_grammar(
                grammar,
                self.source_path,
                self.options.import_paths,
                self.options.keep_all_tokens,
            )
        else:
            assert isinstance(grammar, Grammar)
            self.grammar = grammar

        if self.options.lexer == "auto":
            if self.options.parser == "lalr":
                self.options.lexer = "contextual"
            elif self.options.parser == "earley":
                if self.options.postlex is not None:
                    logger.info(
                        "postlex can't be used with the dynamic lexer, so we use 'basic' instead. "
                        "Consider using lalr with contextual instead of earley"
                    )
                    self.options.lexer = "basic"
                else:
                    self.options.lexer = "dynamic"
            elif self.options.parser == "cyk":
                self.options.lexer = "basic"
            else:
                assert False, self.options.parser
        lexer = self.options.lexer
        if isinstance(lexer, type):
            assert issubclass(
                lexer, Lexer
            )  ##

        else:
            assert_config(lexer, ("basic", "contextual", "dynamic", "dynamic_complete"))
            if self.options.postlex is not None and "dynamic" in lexer:
                raise ConfigurationError(
                    "Can't use postlex with a dynamic lexer. Use basic or contextual instead"
                )

        if self.options.ambiguity == "auto":
            if self.options.parser == "earley":
                self.options.ambiguity = "resolve"
        else:
            assert_config(
                self.options.parser,
                ("earley", "cyk"),
                "%r doesn't support disambiguation. Use one of these parsers instead: %s",
            )

        if self.options.priority == "auto":
            self.options.priority = "normal"

        if self.options.priority not in _VALID_PRIORITY_OPTIONS:
            raise ConfigurationError(
                "invalid priority option: %r. Must be one of %r"
                % (self.options.priority, _VALID_PRIORITY_OPTIONS)
            )
        if self.options.ambiguity not in _VALID_AMBIGUITY_OPTIONS:
            raise ConfigurationError(
                "invalid ambiguity option: %r. Must be one of %r"
                % (self.options.ambiguity, _VALID_AMBIGUITY_OPTIONS)
            )

        if self.options.parser is None:
            terminals_to_keep = "*"
        elif self.options.postlex is not None:
            terminals_to_keep = set(self.options.postlex.always_accept)
        else:
            terminals_to_keep = set()

        ##

        self.terminals, self.rules, self.ignore_tokens = self.grammar.compile(
            self.options.start, terminals_to_keep
        )

        if self.options.edit_terminals:
            for t in self.terminals:
                self.options.edit_terminals(t)

        self._terminals_dict = {t.name: t for t in self.terminals}

        ##

        if self.options.priority == "invert":
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = -rule.options.priority
            for term in self.terminals:
                term.priority = -term.priority
        ##

        ##

        ##

        elif self.options.priority is None:
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = None
            for term in self.terminals:
                term.priority = 0

        ##

        self.lexer_conf = LexerConf(
            self.terminals,
            re_module,
            self.ignore_tokens,
            self.options.postlex,
            self.options.lexer_callbacks,
            self.options.g_regex_flags,
            use_bytes=self.options.use_bytes,
            strict=self.options.strict,
        )

        if self.options.parser:
            self.parser = self._build_parser()
        elif lexer:
            self.lexer = self._build_lexer()

        if cache_fn:
            logger.debug("Saving grammar to cache: %s", cache_fn)
            try:
                with FS.open(cache_fn, "wb") as f:
                    assert cache_sha256 is not None
                    f.write(cache_sha256.encode("utf8") + b"\n")
                    pickle.dump(used_files, f)
                    self.save(f, _LOAD_ALLOWED_OPTIONS)
            except IOError as e:
                logger.exception("Failed to save Lark to cache: %r.", cache_fn, e)

    if __doc__:
        __doc__ += "\n\n" + LarkOptions.OPTIONS_DOC

    __serialize_fields__ = "parser", "rules", "options"

    def _build_lexer(self, dont_ignore: bool = False) -> BasicLexer:
        lexer_conf = self.lexer_conf
        if dont_ignore:
            from copy import copy

            lexer_conf = copy(lexer_conf)
            lexer_conf.ignore = ()
        return BasicLexer(lexer_conf)

    def _prepare_callbacks(self) -> None:
        self._callbacks = {}
        ##

        if self.options.ambiguity != "forest":
            self._parse_tree_builder = ParseTreeBuilder(
                self.rules,
                self.options.tree_class or Tree,
                self.options.propagate_positions,
                self.options.parser != "lalr" and self.options.ambiguity == "explicit",
                self.options.maybe_placeholders,
            )
            self._callbacks = self._parse_tree_builder.create_callback(
                self.options.transformer
            )
        self._callbacks.update(
            _get_lexer_callbacks(self.options.transformer, self.terminals)
        )

    def _build_parser(self) -> "ParsingFrontend":
        self._prepare_callbacks()
        _validate_frontend_args(self.options.parser, self.options.lexer)
        parser_conf = ParserConf(self.rules, self._callbacks, self.options.start)
        return _construct_parsing_frontend(
            self.options.parser,
            self.options.lexer,
            self.lexer_conf,
            parser_conf,
            options=self.options,
        )

    def save(self, f, exclude_options: Collection[str] = ()) -> None:
        #--
        if self.options.parser != "lalr":
            raise NotImplementedError(
                "Lark.save() is only implemented for the LALR(1) parser."
            )
        data, m = self.memo_serialize([TerminalDef, Rule])
        if exclude_options:
            data["options"] = {
                n: v for n, v in data["options"].items() if n not in exclude_options
            }
        pickle.dump({"data": data, "memo": m}, f, protocol=pickle.HIGHEST_PROTOCOL)

    @classmethod
    def load(cls: Type[_T], f) -> _T:
        #--
        inst = cls.__new__(cls)
        return inst._load(f)

    def _deserialize_lexer_conf(
        self,
        data: Dict[str, Any],
        memo: Dict[int, Union[TerminalDef, Rule]],
        options: LarkOptions,
    ) -> LexerConf:
        lexer_conf = LexerConf.deserialize(data["lexer_conf"], memo)
        lexer_conf.callbacks = options.lexer_callbacks or {}
        lexer_conf.re_module = regex if options.regex else re
        lexer_conf.use_bytes = options.use_bytes
        lexer_conf.g_regex_flags = options.g_regex_flags
        lexer_conf.skip_validation = True
        lexer_conf.postlex = options.postlex
        return lexer_conf

    def _load(self: _T, f: Any, **kwargs) -> _T:
        if isinstance(f, dict):
            d = f
        else:
            d = pickle.load(f)
        memo_json = d["memo"]
        data = d["data"]

        assert memo_json
        memo = SerializeMemoizer.deserialize(
            memo_json, {"Rule": Rule, "TerminalDef": TerminalDef}, {}
        )
        options = dict(data["options"])
        if (set(kwargs) - _LOAD_ALLOWED_OPTIONS) & set(LarkOptions._defaults):
            raise ConfigurationError(
                "Some options are not allowed when loading a Parser: {}".format(
                    set(kwargs) - _LOAD_ALLOWED_OPTIONS
                )
            )
        options.update(kwargs)
        self.options = LarkOptions.deserialize(options, memo)
        self.rules = [Rule.deserialize(r, memo) for r in data["rules"]]
        self.source_path = "<deserialized>"
        _validate_frontend_args(self.options.parser, self.options.lexer)
        self.lexer_conf = self._deserialize_lexer_conf(
            data["parser"], memo, self.options
        )
        self.terminals = self.lexer_conf.terminals
        self._prepare_callbacks()
        self._terminals_dict = {t.name: t for t in self.terminals}
        self.parser = _deserialize_parsing_frontend(
            data["parser"],
            memo,
            self.lexer_conf,
            self._callbacks,
            self.options,  ##

        )
        return self

    @classmethod
    def _load_from_dict(cls, data, memo, **kwargs):
        inst = cls.__new__(cls)
        return inst._load({"data": data, "memo": memo}, **kwargs)

    @classmethod
    def open(
        cls: Type[_T], grammar_filename: str, rel_to: Optional[str] = None, **options
    ) -> _T:
        #--
        if rel_to:
            basepath = os.path.dirname(rel_to)
            grammar_filename = os.path.join(basepath, grammar_filename)
        with open(grammar_filename, encoding="utf8") as f:
            return cls(f, **options)

    @classmethod
    def open_from_package(
        cls: Type[_T],
        package: str,
        grammar_path: str,
        search_paths: "Sequence[str]" = [""],
        **options
    ) -> _T:
        #--
        package_loader = FromPackageLoader(package, search_paths)
        full_path, text = package_loader(None, grammar_path)
        options.setdefault("source_path", full_path)
        options.setdefault("import_paths", [])
        options["import_paths"].append(package_loader)
        return cls(text, **options)

    def __repr__(self):
        return "Lark(open(%r), parser=%r, lexer=%r, ...)" % (
            self.source_path,
            self.options.parser,
            self.options.lexer,
        )

    def lex(self, text: str, dont_ignore: bool = False) -> Iterator[Token]:
        #--
        lexer: Lexer
        if not hasattr(self, "lexer") or dont_ignore:
            lexer = self._build_lexer(dont_ignore)
        else:
            lexer = self.lexer
        lexer_thread = LexerThread.from_text(lexer, text)
        stream = lexer_thread.lex(None)
        if self.options.postlex:
            return self.options.postlex.process(stream)
        return stream

    def get_terminal(self, name: str) -> TerminalDef:
        #--
        return self._terminals_dict[name]

    def parse_interactive(
        self, text: Optional[str] = None, start: Optional[str] = None
    ) -> "InteractiveParser":
        #--
        return self.parser.parse_interactive(text, start=start)

    def parse(
        self,
        text: str,
        start: Optional[str] = None,
        on_error: "Optional[Callable[[UnexpectedInput], bool]]" = None,
    ) -> "ParseTree":
        #--
        return self.parser.parse(text, start=start, on_error=on_error)





class DedentError(LarkError):
    pass


class Indenter(PostLex, ABC):
    paren_level: int
    indent_level: List[int]

    def __init__(self) -> None:
        self.paren_level = 0
        self.indent_level = [0]
        assert self.tab_len > 0

    def handle_NL(self, token: Token) -> Iterator[Token]:
        if self.paren_level > 0:
            return

        yield token

        indent_str = token.rsplit("\n", 1)[1]  ##

        indent = indent_str.count(" ") + indent_str.count("\t") * self.tab_len

        if indent > self.indent_level[-1]:
            self.indent_level.append(indent)
            yield Token.new_borrow_pos(self.INDENT_type, indent_str, token)
        else:
            while indent < self.indent_level[-1]:
                self.indent_level.pop()
                yield Token.new_borrow_pos(self.DEDENT_type, indent_str, token)

            if indent != self.indent_level[-1]:
                raise DedentError(
                    "Unexpected dedent to column %s. Expected dedent to %s"
                    % (indent, self.indent_level[-1])
                )

    def _process(self, stream):
        for token in stream:
            if token.type == self.NL_type:
                yield from self.handle_NL(token)
            else:
                yield token

            if token.type in self.OPEN_PAREN_types:
                self.paren_level += 1
            elif token.type in self.CLOSE_PAREN_types:
                self.paren_level -= 1
                assert self.paren_level >= 0

        while len(self.indent_level) > 1:
            self.indent_level.pop()
            yield Token(self.DEDENT_type, "")

        assert self.indent_level == [0], self.indent_level

    def process(self, stream):
        self.paren_level = 0
        self.indent_level = [0]
        return self._process(stream)

    ##

    @property
    def always_accept(self):
        return (self.NL_type,)

    @property
    @abstractmethod
    def NL_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def OPEN_PAREN_types(self) -> List[str]:
        raise NotImplementedError()

    @property
    @abstractmethod
    def CLOSE_PAREN_types(self) -> List[str]:
        raise NotImplementedError()

    @property
    @abstractmethod
    def INDENT_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def DEDENT_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def tab_len(self) -> int:
        raise NotImplementedError()


class PythonIndenter(Indenter):
    NL_type = "_NEWLINE"
    OPEN_PAREN_types = ["LPAR", "LSQB", "LBRACE"]
    CLOSE_PAREN_types = ["RPAR", "RSQB", "RBRACE"]
    INDENT_type = "_INDENT"
    DEDENT_type = "_DEDENT"
    tab_len = 8



import pickle, zlib, base64
DATA = (
b'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BLSvjmR2zfTfKFQB+LUPZyCh3kN57P3ub+q/pv7ob5sit9hOp/Fh46pU/RXY87xyE/Y81R7x1Xff/FRnJEz///MLvUQNqj6Z+RFjpsgtNsq4YUc0/57aua1R4zcaV1N/9k1SdTd920+1W6ovUH/lo+p3f4B9U/3X1e/+VfW5j/Z75/yNioLcJsv3UeR+P1tA/U/ZvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRvibRpiXRpiXRpiXRUiXRtCXRtCXRpiXRICeRHUk0yEk0yEk0yEk0yEk0yEk0yEk0yEk0yEk0yEk0yEk0yEk0yEk0yEk0yEk0yEk0yEk0yFntgDogB9QDbYF6IY9UQPtfKoudqmAz4lz/z+pcSmsk+wNFf098L55E2j6Z/b1/K7dzazAiq8GIrAYjshqMyGowIqvBiKwGI7IajMhqMCKrwYisBiOyGozIajAiq8GIrAYjshqMyGowIqvBiKwGI7IajMhqMCKrwYisBiOyGozIajDqqsGoqwajrhqMumowsqrByKoGI6sajKxqMJaqwViqBqOnGoyeajBeqsF4qQbjpRoMlGowJqrBYKgGg6EaDIZqMPypwYCnBgOeGgx4ajDgqcFIpwYjnRqMbWowtqnB2KYGY5sajG1qMLapwaCmBqOZGgxcajBwqcHApQYDlxoMXLJqg0qgdmglZIMqISs0D1oOVUHd0DRoJpSCWqCp0FZoG1QLeaGJ0HSoCOqH/NBuaBm0EFoCzYUaoUVSAe1/v99GWnV6/zB+xG/8iN/H4MTQR7Lf/Tv1is3l7h9mXtOPQPugg9BRqBU6A+lSAe3v5cThj0ThkEWbhC5RItEuUSyxUmKVRINEh8RqiaUSkyTWSNgkOiUqJawS8yRmSEyRWCthl1gn0SWxXmKDxHKJKomNEtUS3RLTJDZJzJaYKVEusVhis0SBhEOiRaJHYo7EVIktElsltknUSzglaiV6JbZL7JBwSbglPBJeiYkSuySmSxRJlElUSPRJ9EsMSPgldkuUSsyXCEgEJQYl9kjslVgmEZIYklgo0SSxRGKuRKPEsESzxIjEZIlFEhclzktckkhJjEn4BALaP8g3S4ugP4qg3o0gIyOofiOofiPoGyOohSPouSLoGyPoGyPoxyLoxyLoIiPoziKotiPoDSOovSOovSOovSPo8SLo8SLo8SLo8SLoyiPow7NaD22AlkNV0EaoGuqGpkGboNnQTKgcWgxthgogB9QC9UBzoKnQFmgrtA2qh5xQLdQLbYd2QC7IDXkgLzQR2gVNh4qgMqgC6oP6oQHID+2GSqH5UAAKQoPQHmgvtAwKQUPQQqgJWgLNhRqhYagZGoEmQ4sgn1RA+7rKv9wr7QeYlGS1GLJC86AKaDY0BVoGTZIKaP9H/YtU7fwF2QTl24t8R5drFfM9RL7MvvF9/HOtYkD7hvrTjR5X+15E9Iu5bk7/DdXRLlBXC9XVb6mrBnW1cELket+rN6oP/Vpujlmba7w2qi//TfW5Serqt9TVf8rdTrDEFMk2m2vV5xapz/1ITeUWq6tZEyLZJq5CfehT6kM/NGUe7wLth5FsN711QiTbGH9JfU2T+poh9UctUVdh9clcMxbQvikHYHZ8W+0YgNkxALNjAGbHlqwdAzA7BmB2DMDsGIDZMQCz46lixwDMjgGYHQMwOwZgdgzA7BiA2TEAs2MAZscAzI4BmB0DMDsGYHYMwOwYgNkxALNjAGbHAMyOAZgdAzA7BmB2DMDsGIDZMQCzYwBmxwDMjgGYHQMwOwZgdgzA7BiA2TEAs2MAZscAzI4BmB0DMDsGYHYMwOwYgNkxALNjAGbHAMyOAZgdwyo7BlJ2DKTsGEHZMTizY3Bmx+DMjsGZHYMzOwZndozK7BiA2TE4s2MAZsd4yo7xlB3jKTvGU3aMp+wYT9kxnrJjPGXHeMqO8ZQd4yk7xlN2jKfsGE/ZMZ6yYzxlx3jKjvGUHeMpO8ZMWdVDxVAv1AB1QB5oPdQFlULlkAPqkQpo37rhJ6uHCyPv8yer//x+oPqH/nPUx39++of689PfkS3tE2hps/p9SIPaIB0qgdqhYmgltApqgDqg1dBSaBK0BrJBnVAlZIXmQTOgKdBayA6tg7qg9dAGaDlUBW2EqqFuaBq0CZoNzYTKocXQZqgAckAtUA80B5oKbYG2QtugesgJ1UK90HZoB+SC3JAH8kI7oYnQLmg6VASVQT6oAuqD+qEByA/thkqh+VAACkKD0B5oL7QMCkFD0EKoCVoCzYUaoWGoGRqBJkOLpALat2VSupGUbqShG2noRhq6kYZupKEbaehGGrqRhm6koRtp6EYaupGGbqShG2noRhq6kYZupKEbaehGGrqRhm6koRtp6EYaupGGbqShG2noRhq6kYZupKEbaehGGrqRhm6koRtp6EYaupGGbqShG2noRhq6kYZupKEbaehGGrqRhm6koRtp6EYaupGGbqShG2noRhq6kYZupKEbaehGGrqRhm6koRv550b+uZF/buSfG/nnRuK5kXhuJJ4biedG4rmReG4knhuJ50biuZF4biSeG4nnRuK5kXhuJJ4biedG4rmReG4knhuJ50biuZF4biSeG4nnRuK5kXhurDXubP59R+afC/nnQv65kH8u5J8L+edC/rmQfy7knwv550L+uZB/LuSfC/nnQv65kH8u5J8L+edC/rmQfy7knwv550L+uZB/LuSfC/nnQv65kH8u5J8L+edC/rmQfy7knwv550L+uZB/LuSfC/nnQv65kH8u5J8L+edC/rmQfy7knwv550L+uZB/LuSfC/nnQv65kH8u5J8L+edC/rmQfy7knwv550L+uZB/LuSfC/nnQv65kH8u5J8L+edC/rmQfy7knwv550L+uZB/LuSfC/nnQv65kH8u5J8L+edC/rmQfy7knwv550L+uZB/LuSfC/nnQv65kH8u5J8L+edC/rmy+fdd+SMIHNhRc2C/2YE9ZQf25RzYCXdgv9mBnTgHdukc2G92YBfZgT16B/bhHdiHd2B3z4G9dgd25R3Ya3dgT9mBPWUH9pQd2DF0YE/ZgXmBAzvMDuwpO7Bv7MC+owO7ng7snTqwi+zADqUDO5QO7Bs7sF/pwGTBgcmCA7MEB2YJDuxzOrDPmdXd0H7ofugByAtFoZ1QEfQgdAAqgw5CMagC6oMegvohP/QYFIQGoSegEPQUNATdAZ2DnoGGoRHoOegQ9Dz0KvQ69Ab0FvQC9BL0MnQYeg16G3oRegV6E9oCrYe6oHqoFCqGeqEGqAPyQOWQA+qRCmiXx99idPz88fj5Y+2WOH+sDvm3q3/hex1EvqJesV83uNCU/VZrr0ayby/+O+oDYeMiZVJf+L33fcoic9P4ORyyyJ+7+OmOW9x4yCL/5Pigpy2yJzj+9Cecu1iqrv4cJzAC2j/KU9Pv+CPXT02/I4rGLIolVkmsllgqMUlijcQMiSkSayXsEuskuiQ2SGyUqJbYJDFbYrHEZokCiTkS9RJOiV6J7RI7JFwSbgmPxC6JMgmfRIVEn8SAxEWJSxKlEvMlAhJBiUGJPRJ7JUISTRLDEs0SIxKTJcYk2iRKJNolVko0SHRI2CQ6JSolrBLzJNZLLJeokuiWmCYxU6JcIiXhkGiR6JGYKrFFYqvENolaCa/ERInpEkUS/RLnJfwSuyWWSQxJLJRYInFBYq5Eo8QigYD2TyryWlWRVnhtNVibWS2+P5L56av6twrV+7f8szxoWIAOpQD9XwG66wL0vlmFoWPQWcgJrYCOQ15oJ3QC2gedhILQEHQKOgK1QOeg09AZqYD2g39/0kRbExEr7vj5ko/K+ZJ8HXurHjR5l3LwX+T22aexAfxpbGJ/Orvd9q/yUOphbG4cxobXYWxnHMYm02EEwmFshh3GVtxhbH8dxnbNYWyUHcamyGG8zA9j6+gwto6yuhe6DxqF2qB2aD90P7QGegCKQg9CndAB6CAUg/qgh6B+6GEoDj0C+aEq6FHoMehxaBB6AnoSCkFPQU9Dz0DD0Aj0LPQcdAh6HnoBehF6CXoZegU6DL0KHYFeg16H3oDehN6C3oaOQjoUho5Bx6EV0AnoJHQKaoFOQ2egs5AT8kI7oSA0BJ2DtkDroS6oHiqFiqFeqAHqgDxQOeSAeqCpkAWaBdVCS6FJ0ERoOmSF5kFToOXQNGg+NBtaBi2EmqAl0ExoMTQXKoAaoc1QMzQZmgMtkgpoP5T3dr9pkrmZ1T7oIHQUaoXOQLpUQLuq/la1A3lsQubJV6BPnhDJvhPdPHVx1bj4pCnz+inQ/0dmS+dH8q14OjJ/6EVoPVQPrYO6oA3QeegSVAoVQ71QEGqAOqAd0CTIAw1B5VAKckCdUA80Bg1IBbR/u/b+l89MUP3Tj9Xjn3sR34YX8W14Ed+G6LkNJdFtKDxuw8v9NsTSbQii2xAFtyEKbkOJkpUbmghNh4qgSqgMskLzoBlQBTQF6oeWQ1WQH6qGSqFp0HxoEJoNLYNC0EKoCVoCzYTKocXQZqgRKoCGoWZoLjQCTYbmQIugHVCfVEAvMMmDSUEcTAriYFIQ6RbEwaQgDiYFERpBHEwK4mBSEKERRGgEcTApiINJQURIEAeTgjiYFEQwBHEwKYiDSUEcTAriYFIQB5OCOJgUxMGkIEI4iBAOIryDiOQgDiYF0dMFcTApiINJQRxMCuJgUhAHk4I4mBTEwaQggjaIg0lBHEwK4mBSECEcRF8aRAgHcTApiINJQRxMCuJgUhAHk4JY8II4mBTEwaQglqogDiYFsRwFcTApiINJQSxOQRxMCuJgUhAHk4I4mBTEwaQgDiYFcTApiINJQRxMCmLhCuJgUhAHk4JYwoM4mBTEwaQglvAgDiYFcTApiINJQRxMCuJgUhBLeBAHk4I4mBTEwaQgDiYFcTApiINJQRxMCuJgUhAHk4I4mBTEwaSMAropE4B3Gov/7YWR7O7dF1Vd9k3j4vPYiFI7aZ9RX6N2Wmeqj9xnXLRNiHDOug17dvmtum8ZF59VF3cZF3+hftMdxoVXfUTtXl2eEBE7c7l9uPwmUW6/7R21c6a+9G71x6kxmD7B+B8w2rQC/Y+Nf5JfL8z8/zxq+G8KI9kx9NfViG+ZGpz9urr6tLqKqqvPqKsudfXb6sqv/uB7jIv/qi6eNi6+OSHzsBfoJ3Kj9sXqD1UBMBK5Xj4vyqwsEcgP3QtVQfdBo1Ab1A49Bj0O7YcGoSeh+6GnoDVQCHoAikIPQp3QAegZ6CHoIBSDnoWeg/qhQ9BRSIdaoTB0DDoLOaHj0ArIC+2ETkD7oJNQEBqCTkFHoBboHHQaOiMV0CeaRrLDlvvUeEUvMsn+rBNLUieKpE4UQp1YkjpR+nSi9OnEAtWJYqcTS1InyptOFBidKEU6UYp0ovjoRD/YieWjE0tEJ8K9E2VDVhcgB9QDXYQuQSloDBqQCuj/6f0H+C8urvNPm69PkN+qrLqgeqgUKoZ6oSDUAHVAQ5AHKoccUCfUIxXQi9W3Q69S87F7jYVlsrpYb3zZt41f+41fc6fQbpyXrTcuPqfOffyS+j2OiNgkUR/YZvx6xfjAl00RsY+Sn5sZr09tX0ScSstNy3Sz+t33GB/5rvFraUTVgQXaA8avPzC+Yqk6VPLL6iteiOSHZvoU9YGXIu82PesxLpapvzl/FG218bVHIu92JM1pfOZsRJXuBdqfRcQ4bZfxgfMRVXUWaKmIOLK2w/jA1yLvMlfTS9Q/6dvGRy4bv34n8m4n1uzGZy5H3vPkmnor6KvGnzZRrfcTTZHsD1sow4G1lcbFVJxcW2dcPKcubhiL5c+93XhO7QMcTzO6UeNqVF2Z1NU+9UVt6rFRj0CZ+tAncm+TOkdd5Ed5u42LX1NfVK6+qFF97svGRaX6XH4O+5dqgFgYEQPZbuPiN9UX5weyDuPiWfWRG86t5Y/vbVLPAHXxj8bFD9RF7kSl/ivqb/+MSUTCtSTQLeozy02Z+CrQd6mL3CE248E2rlZgVJqfkOaPQOZSTK9QX92hPqS2DuPqn5Y/dJifle41LorffWj6vn5cb34yuta42Kj++mnqr9+h/rJ/My52q+9VpfqQV30oNwrVp6sP9asP/di4aMD5t/ycMz9t9RgXX0MOv8dB1Pxc/D2m4GoMPKh+142z7r8yLkLqf2SG+ifeqb7o+8b36InI9SF3foT9L8bFOvUHf8+4uEd9JDee1qvV796vPvQV9YzBYdANxp/zvPE1M9XXHFBfs0U9hzE9zh/w7DIudqpP5afH73FGMz8rzh3WzJ3RDBifeEx9Re6w5o1nNDvUw44DmP+snvTqI//+JKY+S/3Ln1e/K38mc5tx8bL6SO4IQP4w5r+quFPfz+8YFyfUl9iMi9PqYo9x8UfqIjep139V/cn/RX3oxsOTncaFT/31s9UXfV590Y3HKFcZF3+qPrXVuDivLm4Yl+frr140fL3ZemGSSR6G/hnPQP/cjj6/rxPPuSfuz+98c34puNlnlz9iZ5bzx2ty+a4Wt72R9ziq/DP+TPWf8YTyzXpjZKOOk/vEfuwT+7FP7EcL5Mc+sR/7xH60R37sE/uxT+xHs+RHs+THPrEf+8R+tE5+7BP7sU/sRyPlxz6xH/vEfuwT+7FP7Mc+sR/7xH7sE/vRnPnRnPnRxvnRqvmxT+zHPrEf+8R+7BP7sU/sxz6xH/vEfuwT+7FP7EfD58c+sR/7xH7sE/vRDPqxT+xHa+jHPrEf+8R+7BP7sU/sxz6xH025H/vEfuwT+9GU+7FP7Ecb7sc+sR/7xH405X7sE/uxT+zHPrEf+8R+7BP7sU/sxz6xH/vEfuwT+9Ek+7FP7Mc+sR+Nvh/7xH7sE/uxCeDHPrEf+8R+7BP7sU/sxz6xH1sJfuwT+7FP7Mc+sR/7xH7sE/uxT+zHPrEf+8R+7BP7sU/sR9ngz5YNv2S6tgl0m5oRG+W+ysN7DX9fBeWDxsWPVabnNgKnZ3rjR6AqqA1qhw5Cj0GPQ/uhZ6EQdBTSoVYoDB2DzkJO6Di0AvJCO6ET0D7oJBSEhqBT0BGoBToHnYbOSAX0XzbJg5SvTZAv0KwqoTKoGmqF7oRKoLugu6EZUAW0D7oHikD3QvdBo1Ab1A7th+6H1kAPQFHoQagTOgAdhGJQH/QQ1A89DMWhRyA/VAU9Cj0GPQ4NQk9AT0Ih6CnoaegZaBgagZ6FnoMOQc9DL0AvQi9BL0OvQIehV6Ej0GvQ69Ab0JvQW9Db0FFIh8LQMeg4tAI6AZ2ETkEt0GnoDHQWckJeaCcUhIagc9AWaD3UBdVDpVAx1As1QB2QByqHHFAPNBWyQLOgWmgpNAmaCE2HrNA8aAq0HJoGzYdmQ8ughVATtASaCS2G5kIFUCO0GWqGJkNzoEVSAX2K6YY3Xb0DOxTv8aar+d2Vm3V3jNqlOa6+5kO8TSa/A3MT7pfJbxTc+jfO/Gz3y9y4LfQz3jhzw+bPe7xTq15iGn8LhAnv+gQcfwuEW/EtENSI6xW50fjxfC+E99pyLM28ZNVcty5y/S0Qvm78Wq4+XZb5tPE4aQ9F4uOv7PFX9kfklf0f9wVdbpKbKQOZ0rIIqoTKoGqoFboTKoHugu6GZkAV0D7oHigC3QvdB41CbVA7tB+6H1oDPQBFoQehTugAdBCKQX3QQ1A/9DAUhx6B/FAV9Cj0GPQ4NAg9AT0JhaCnoKehZ6BhaAR6FnoOOgQ9D70AvQi9BL0MvQIdhl6FjkCvQa9Db0BvQm9Bb0NHIR0KQ8eg49AK6AR0EjoFtUCnoTPQWcgJeaGdUBAags5BW6D1UBdUD5VCxVAv1AB1QB6oHHJAPVIB/VcQvzriV0f86ohfHfGrI351xK+O+NURvzriV0f86ohfHfGrI351xK+O+NURvzriV0f86ohfHfGrI351xK+O+NURvzriV0f86ohfHfGrI351xK+O+NURvzriV0f86ohfHfGrI351xK+O+NURvzriV0f86ohfHfGrI351xK+O+NURvzriV0f86ohfHfGrI351RKWOONQRhzoCUEds64htHbGtI7Z1xLaO2NYR1DriV0ds64hfHfGrI351xK+O+NURvzriV0f86ohfHfGrI351xK+O+NURvzriV0f86ohfHfGrI351xK+O+NURsTpCVUeo6ghVHaGqI1R1RLqOSNcR4jriV0f86ohfPRu/FtPHdwdKdeF3R8b71ch4v/ox6len/sJesWr3b9eED+WlO/6SHX/Jflxesvky5b9lz2xVmORbvrxhklVxVvugg9BRqBU6A+lSAX2aSd4gWIrTnKU491mKc4qlOAVainOfpbhFrxR/bSnO8ZXiVG0pzjeW4hxfKU7VluJUbSnOPpbiHG0pTjuW4hxfKU6IZnUBckCdUA9kgWZBbVAJ1A6thFZBq6Gl0BrIBlVCVmgeNAOaAq2F7NByqAraCFVD3dA0aBM0G5oJpaDF0GaoAGqB5kBToa3QNsgJ1ULbIRfkhrzQRGgXNB0qgsogH1QB9UH90AB0EfJDu6FL0HwoAA1Ce6C90DIoBC2EmqAl0FyoERqGmqERaDI0Bi2SCuiVH+P26UOswVRl6VD/iptVjP3kGixfeuWLsfEa7H3WYD/NHUI/zW2c+TotX57d9BosX5Rf75+mm+Q9Q6NYxUexio+inhnFmj6KNX0U1c0oVvhRrPCjqG5GUd2MYvUfxeo/ilpnFLXAKGqBUVQwo6gMRlEZjKIyGEVlMIrKYBSVwSgqg1HUjqOoFkdRZY6idhxFRTGKimIUFcUoKopRVBSjqChGUVGMoqIYRUUxiopwFBXFKCqKUVQUo6gWR1FfjKJaHEW1MYpqI6st0FZoG1QPOaFaqBfaDu2AXJAb8kBeaCK0C5oOFUFlUAXUB/VDA5Af2g2VQvOhABSEBqE90F5oGRSChqCFUBO0BJoLNULDUDM0Ak2GFkE+qYBedSvXLKoS+DtT5KNUvIzXLOM1y8+5Zplhwtn2G44z5149+b8w/y1Qf2orXiv5b0r+Ick/QfKvlfwTI/99yj34+f/tGx+a/Ms8/9TOv8yv/59Um7LHJ7OJNCGTT61SAX2mSb7T7TczUysLNAuqh0qgYqgWaoCWQpOgidB0qAiqhMogKzQPmgFVQFOg5VAVVA2VQtOg+dBsaBm0EGqClkAzoXJoMTQXKoAaoWZoMjQHWiQV0GeZRq4XZn+tnlh+vcZ07Q2Vn5+g+Ksm2QiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiE0AiEsgvtbJP8+T1NeAo34WXYlP0Nt5nECEm7IF7SWayTqJfoktggcV5ClyiVKJbolQhKNEh0SOyQmCThkRiSKJe4IOGQ6JTokbBIzJJYJbFaYqnEGokZElMk1krYJTZKVEtskpgtsVhis0SBxBwJp8R2CZeEW2KXRJmET6JCok9iQOKixCWJ+RIBiUGJPRJ7JUISTRLDEs0SIxKTJcYk2iRKJNolVkrYJColrBLzJJZLVEl0S0yTmCmRkmiRmCqxVWKbRK2EV2KixHSJIol+Cb/EbollEgsllkjMlWiUWCQQ0GtN195h5Q8yReMnTLJoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTGO1SqNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTGPFTaNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTKNoTGdrQKvp2s8A1/42wh8BPpDZ4JmTy8tfNam8nGvK/XDYI4WZOCzQ/2aC+rp5mU8cNH7/v0Wy98++c/3PC+h1mU8fMPjjiLq1okD/Z/X7nzMu7lY7SuqHHHxZXTxjXLyuPvWAcbFffeQp4+IJ40L/HbVLfUR9aNS4+Lq6eMi4OK8u7lf/QvXbcndKVOPuhGrcw1GNvZZq3LVRjTssqnEPRzXuqajGfQzVuI8hq/3Qs1AIOgrpUCsUho5BZyEndBxaAXmhndAJaB90EgpCQ9Ap6AjUAp2DTkNnpAL67aZrP5PCllnKf810C89BPtj4Q01PPvVRn4OMH6QdP0j7E86+15vkzYJD2IAfwgb8EDbgh7A9PoSYzOpOqAS6C7obmgFVQPuge6AIdC90HzQKtUHt0H7ofmgN9AAUhR6EOqED0EEoBvVBD0H90MNQHHoE8kNV0KPQY9Dj0CD0BPQkFIKegp6GnoGGoRHoWeg56BD0PPQC9CL0EvQy9Ap0GHoVOgK9Br0OvQG9Cb0FvQ0dhXQoDB2DjkMroBPQSegU1AKdhs5AZyEn5IV2QkFoCDoHbYHWQ11QPVQKFUO9UAPUAXmgcsgB9UgF9E+a5C0E1Wguq7HdUY0tjWo0l9XYxKjGJkY1Ws1qbFtUo7msxkZFNbYKqrGpUI1NhWpsI2R1HiqFgtAQVA5dgBxQD2SBZkFtUAnUDq2EVkGroaXQGsgGVUJWaB40A5oCrYXs0HKoCtoIVUPd0DRoEzQbmgkthjZDBVALNAeaCm2FtkFOqBbaDrkgN+SFJkK7oOlQEVQGVUB9UD80APmh3dB8KAANQnugvdAyKAQthJqgJdBcqBEahpqhEWgytAi6CF2CUtAY5JMKGN2FCtXxn/gx/hM/3kdzeMNP/LhFf9KH2l353chN7AAXZF4tZwyvVp9QG4vfzewn/nrmE7knQf5hvuFk3D7jogLP7K8aF5uutanaHfL5nH/c8/+H+effXxtf+6bx69eMX0fV3/+fTdf2RXWbKYKNUa1Nff43TLmN0ERh9uP65zL/8IUoqqwoZKwoZKwouKwoa6woa6woa6wozawocqwo1Kwo1KwogKwo26wo26wo26wo26wo26woo6woo6woo6woo6wo96woqqwoqqwoqqwojqwojqwojqwojqwocqwocqwocqwocqwoZKwoZKwoVqwoVqwoT6woT6woT6woSKwoM6woLKwoLKwoLKwoHqwoEKxYpqwoF6woF6woEKxYFq1YFq0oEKwoEKwoEKwoEKwoEKwoCawoAqxY2q1Y2q1Y2q1Y2q1YorNqg0qgdmglZIMqISs0D1oOVUHd0DRoJpSCWqCp0FZoG1QLeaGJ0HSoCOqH/NBuaBm0EFoCzYUaoUVSAb1Bhqp2XmRqFusk6iW6JDZInJfQJUoliiV6JYISDRIdEjskJkl4JIYkyiUuSDgkOiV6JCwSsyRWSayWWCqxRmKGxBSJtRJ2iY0S1RKbJGZLLJbYLFEgMUfCKbFdwiXhltglUSbhk6iQ6JMYkLgocUlivkRAYlBij8ReiZBEk8SwRLPEiMRkiTGJNokSiXaJlRI2iUoJq8Q8ieUSVRLdEtMkZkqkJFokpkpsldgmUSvhlZgoMV2iSKJfwi+xW2KZxEKJJRJzJRolFgkE9EaTPJrkRRnkxbLmRUHoxSLnxSLnRXnoxZLnRWnlRXnoRXnoRdnlRdnlRbHoRRHmxaLqRQnoxRLrxRLrxRLrRSnnRSnnRSnnRSnnRfHtRbntRZnuRfHtxZLuxZLuRXnoRXnoxXLvxXLvRenoRenoRSngRUntRVnpRVnpRVnpRbntRQnhRbntRQHqRXmR1RZoK7QNqoecUC3UC22HdkAuyA15IC80EdoFTYeKoDKoAuqD+qEByA/thkqh+VAACkKD0B5oL7QMCkFD0EKoCVoCzYUaoWGoGRqBJkOLIJ9UQP9N07tuAdzQzuu/qzbQtrzr9kC+01c7Fn7jd+nN6ov/BEcVclsHAf23Mn/lnYZvL4xkN+++qL7im8bF59VFfrNF7bF95t/vK23Dll1+p+5bxsVn1cVdapNM/TF3GBde9RG1DXN5QkTs0OV2gPK7UrktoHfUho/60rvVH6cuciPoVoygWzGCbsUIuhUj6FaMoFsxgm7FCLoVI+hWjKBbMYJuxQi6FSPoVoygWzGCbsUIuhUj6FaMoFsxgm7FCLoVI+hWjKBbMYJuxQi6FSPoVoygWzGCbsUIuhUj6FaMoFsxgm7FCLoVI+hWjKBbMYJuxQi6FSPoVoygWzGCbsUIuhUD21YMbLNqhcLQMegs5ISOQyseKSgwFaj/8GEvtBM6Ae2DTkJBaAg6BR2BWqBz0GnojFRAX2Qos8H8d5njZotNH/Qe3l/orbtqDzauPnV9D/ZTJnFv5XmVvX69yZTb3nxpwvUHTfti5pFYYpLvePe6Sb6ustoHHYSOQq3QGUiXCuhLTXJn9XaUbLejuLsdxcjtKPVuR3GX1XlIh0qhYqgXCkINUAe0A5oEeaAhqBy6ADmgTqgHskCzoFXQamgptAaaAU2B1kJ2aCNUDW2CZkOLoc1QATQHckLbIRfkhnZBZZAPqoD6oAHoInQJmg8FoEFoD7QXCkFN0DDUDI1Ak6ExqA0qgdqhlZANqoSs0DxoOVQFdUPToJlQCmqBpkJboW1QLeSFJkLToSKoH/JDu6Fl0EJoCTQXaoQWSQX0ZaZr5/tnZ1a1T/90q5q+XFXRq00/j/VNrVCzCj/oQve/jYsvYDx+faH7jEnuqAwg/gbwdB7AQjCAJ/cAntwDWBYG8FQfQKQOYFkYwLIwgLgdQNwOYJEYQPgO4MU0gOgfwEtrAC+tAby0BhDhA4jwAUT4ACJ8AIvuAJbZASzPA1h0B/BSHsBLeQDLwgCWhQG8zAfwMh/AkjGAJWMAETCApXQAy8kAlpMBLCcDWGYHEB0DWGYHsPAMIFay2gJthbZB9ZATqoV6oe3QDsgFuSEP5IUmQrug6VARVAZVQH1QPzQA+aHdUCk0HwpAQWgQ2gPthZZBIWgIWgg1QUuguVAjNAw1QyPQZGgR5JMK6L+dCcDcS+1PMl/SKhXQf8cki+w5eBXPwet9Dp6fc/Dqn4PXe1bnIR0qhYqhXigINUAd0A5oEuSBhqBy6ALkgDqhHsgCzYJWQauhpdAaaAY0BVoL2aGNUDW0CZoNLYY2QwXQHMgJbYdckBvaBZVBPqgC6oMGoIvQJWg+FIAGoT3QXigENUHDUDM0Ak2GxqA2qARqh1ZCNqgSskLzoOVQFdQNTYNmQimoBZoKbYW2QbWQF5oITYeKoH7ID+2GlkELoSXQXKgRWiQV0H/XJN8C7ccTZEBkNQuqh0qgdqgWKoYaoKXQDmgStAZyQxOh6VARVAmVQVZoHjQDqoD6oClQP7QcqoL8UDVUCk2D5kOD0GxoGRSCFkJN0BJoJlQOLYY2Q41QATQMNUNzoRFoMjQHWiQV0JtN8j7cLxrdl0v1Yzfrhtz/KEejx++o/bgcmr5ph6WXm+T+xRgqyzFUCmOoscdQN4yhbhhDxT2GKmIM1eoYKu4xVNxjqGTHUMmOof4eQ107hjplDFX1GKqWMVQtY6haxlAdj6E6HkN1PIbqeAz9zBg6mDF0PmPoZ8ZQJY2hShpDxT2GinsMFdQYKqgxVONjqMbHUF2NoUsZQ6U+hkp9DJX6GDqYMVRlY+hgxlDTj6Fiy2oLtBXaBtVDTqgW6oW2QzsgF+SGPJAXmgjtgqZDRVAZVAH1Qf3QAOSHdkOl0HwoAAWhQWgPtBdaBoWgIWgh1AQtgeZCjdAw1AyNQJOhRZBPKqD/HgLwn1A5Z/X7kAa1QTpUArVDxdBKaBXUAHVAq6Gl0CRoDWSDOqFKyArNg2ZAU6C1kB1aB3VB66EN0HKoCtoIVUPd0DRoEzQbmgmVQ4uhzVAB5IBaoB5oDjQV2gJthbZB9ZATqoV6oe3QDsgFuSEP5IV2QhOhXdB0qAgqg3xQBdQH9UMDkB/aDZVC86EAFIQGoT3QXmgZFIKGoIVQE7QEmgs1QsNQMzQCTYYWSQWMFkS+tUoI36oQwiOEb1wIL8qsWqE7oRLoLuhuaAZUAe2D7oEi0L3QfdAo1Aa1Q/uh+6E10ANQFHoQ6oQOQAehGNQHPQT1Qw9DcegRyA9VQY9Cj0GPQ4PQE9CTUAh6CnoaegYahkagZ6HnoEPQ89AL0IvQS9DL0CvQYehV6Aj0GvQ69Ab0JvQW9DZ0FNKhMHQMOg6tgE5AJ6FTUAt0GjoDnYWckBfaCQWhIegctAVaD3VB9VApVAz1Qg1QB+SByiEH1CMV0FtMP483o/uPsvc1/v5yN+H95T5ybyun3mrxn9RfetM2zFpRBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQsNhQlNhQlNhQhthQPNlQPNlQPNlQPNlQPNlQPNlQLtlQBNlQPNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQBNlQ6NhQ2thQ2thQ2thQ2thQ2thQWNlQWNlQStlQBNlQBNlQBNmyRdAK07WzpdsyZ0t/35S7p+DPxD0F+peze3uaSf70km58X7uRet1Itm48O7qRx91IvW48H7rxXOlG6nUjy7qxUnRjNejGatCN51g3Er8ba0M3Er8bydaNZOtGsnXjeduNZOvGqtWNnOtGsnUjvbrx7O/Ga68br+BuZFk3XifdeJ10I7268arpxvrWjfWtGytaN1a0brzauvFqy+puaD90P/QA5IWi0E6oCHoQOgCVQQehGFQB9UEPQf2QH3oMCkKD0BNQCHoKGoLugM5Bz0DD0Aj0HHQIeh56FXodegN6C3oBegl6GToMvQa9Db0IvQK9CW2B1kNdUD1UChVDvVAD1AF5oHLIAfVIBYxOR8WvateaCkXeNOLV2YjnXSNSuRFZ1IjXcSNex43I70ZkdCOey41IrUY8fxrxGm9EojXiFd+IZ3Yjkr4Rr4FGZEMj0qARr/hGrBCNeP034hXRiNd/I17/jUjJRrziG/GKb8SrpREZ3YgVsBHrU1Zh6Bh0FnJCx6EVkBfaCZ2A9kEnoSA0BJ2CjkAt0DnoNHRGKqDrpvf5vnJfNT7TF8m+Q1wwIrZK3s/by+XfVq7ddK0k+m7mx2mszPxrNMNPqj8yrfrv7NGW7D86jjMecZzxiOOMRxxnPOI44xHHGY84znjEccYjjjMecZzxiOOMRxxnPOI44xHHGY84znjEccYjjjMecZzxiOOMRxxnPOI44xHHGY84znjEccYjjjMecZzxiOOMRxxnPOI44xHHGY84znjEccYjjjMecZzxiOOMRxxnPOI44xHHGY84znjEccYjjjMecZzxiOOMRxxnPOI44xHHGY84znjEccYjjjMecZzxiOOMRxxnPOI44xHHGY84znjEccYjjjMecZzxiOOMRxxnPOI44xHHGY84znjEccYjjjMecZzxiOOMRxxnPOI44xHHGY84znjEccYjjjMecZzxiOOMRxxnPOI44xHHGY84znjEccYjjjMecZzxiOOMRxxnPOI44xHHGY84znjEccYjjjMecZzxiGf7wFWZSDxlPKU3ZZK9QHOqD3eY5NEPH3LRh1z0IRd9yEUfctGHXPQhF33IRR9y0Ydc9CEXfchFH3LRh1z0IRd9yEUfctGHXPQhF33IRR9y0Ydc9CEXfchFH3LRh1z0IRd9yEUfctGHXPQhF33IRR9y0Ydc9CEXfchFH3LRh1z0IRd9yEUfctGHXPQhF33IRR9y0Ydc9CEXfchFH3LRh1z0IRd9yEUfctGHXPQhF33IRR9y0Ydc9CEXfchFH3LRh1z0IRd9yEUfctGHXPQhF33IRR9y0Ydc9CEXfchFH3LRh1z0IRd9yEUfctGHXPQhF33IRR9y0Ydc9CEXfchFH3LRh1z0IRd9yEUfctGHXPRlc3G16do7JWv/PZJ5o2StXn14jSl7S1/27Ynz71ccNi7ezO6yXXvDYptJ3tg3Gy/x2QiD2XjyzkY0zEYYZHUe0qFSqBjqhYJQA9QB7YAmQR5oCCqHLkAOqBPqgSzQLGgVtBpaCq2BZkBToLWQHdoIVUOboNnQYmgzVADNgZzQdsgFuaFdUBnkgyqgPmgAughdguZDAWgQ2gPthUJQEzQMNUMj0GRoDGqDSqB2aCVkgyohKzQPWg5VQd3QNGgmlIJaoKnQVmgbVAt5oYnQdKgI6of80G5oGbQQWgLNhRqhRVIBvTMTqrl3R0r4I/mdlwwC+lrTx/KHEq76qP9Qwp98ViR/RCR/aOSjcVZEdUq/E7mlfibhe9xbpfo7dWgjf4gkf3bkPY6M5A+a5M+X3PSfTZg/THT9EIndJDtPJ5Z9J0oeJ4ocJ0oCJ0oCJ0oCJwoZJwoEJwoEJwoEJwoEJwoEJ0o6J4o4J4o4J0oJJ0oJJ0oJJ0oJJ0oJJ0oJJ0oJJ0oJJ8pLJwoLJwpDJ8oMJ4o/J4oOJ4oOJ0pBJ0oQJ0oQJ0oQJ0oQJ0oQJ0oQJ0oQJ0qQrEqh+VAACkKD0B5oLxSCmqBhqBkagSZDY1AbVAK1QyuhBqgDskGdUCVkheZB66HlUBXUDU2DZkLlUApyQC1QDzQV2gJthbZBtZAXmghNh4qgfug85Id2Q8ugIWghtAS6AM2FGqFFkAbthH5fSv89k2RAX2eSb2FTiOFaIcZihRiLFWIsVoixWCHGYoUYixViLFaIQVghhmSFGIsVYixWiLFYIcZihRiLFWIsVoixWCHGYoUYixViLFaIsVghxmKFGIsVZsdiXVjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLFjkLNm1ar0MVe2zIlOzaJPQJUok2iWKJVZKrJJokOiQWC2xVGKSxBoJm0SnRKWEVWKexAyJKRJrJewS6yS6JNZLbJBYLlElsVGiWqJbYprEJonZEjMlyiUWS2yWKJBwSLRI9EjMkZgqsUViq8Q2iXoJp0StRK/EdokdEi4Jt4RHwisxUWKXxHSJIokyiQqJPol+iQEJv8RuiVKJ+RIBiaDEoMQeib0SyyRCEkMSCyWaJJZIzJVolBiWaJYYkZgssUjiosR5iUsSKYkxCZ9AQN9gQO2j6YHMMe+Npo/dluetsdOpNl6H1deMb3nehNvjPrStzlt+izNf6v1VtmzpNmV/vEOB3qr+zFw/fQD99AF0kQeyXeQmk3ifQ+1LMu2+JJfNL8n4/5JcNr8kV8ovyejL4ITEXRJLJaoEAvpmk5x816K2rkUHWYuurRb9ZC36yVrUnrXokGvRG9WiX65F71eL3qgWfUUt+opa9IW16KVr0QnWorqtRdVfi3q2FlV/LXqVWlT9WVmgWdAqaDW0FFoDzYCmQGshO7QRqoY2QbOhxdBmqACaAzmh7ZALckO7oDLIB1VAfdAAdBG6BM2HAtAgtAfaC4WgJmgYaoZGoMnQGNQGlUDt0ErIBlVCVmgetByqgrqhadBMKAW1QFOhrdA2qBbyQhOh6VAR1A/5od3QMmghtASaCzVCi6QCusMkJt/6xMyXtEoF9B7kbheeu11I4S7kbhcyuQsp3IUU7kIKd+H10IUU7kIKdyGFu5DCXUjhLqRwF1K4CynchRTuQgp3IYW78FzqQgp3IYW7kMJdeB11IRm6sg/5Fvld0f5BroX/IJ6kWVgkZknUS5RItEvUShRLNEgsldghMUlijYRbYqLEdIkiiUqJMgmrxDyJGRIVEn0SUyT6JZZL+CWqJUolpknMlxiUmC2xTCIksVCiSWKJxEyJconFEpslGiUKJIYlmiXmSoxITJaYI7FIIGC0XOpJ/LBqHFX9mbtRtAm3ojXh5rMm3G7WhNvNmnC7WRNuN2vCTWRNuG2sCTeKNeHWsCbcGtaEW8OacGtYE24Na8K8qgk3g2XVBz0E9UNx6BHID1VBj0KPQY9Dg9CTUAh6CnoaegYahkagZ6HnoEPQUUiHWqEwdAw6Czmh49AKyAvthE5A+6CTUBAagk5BR6AW6Bx0GjojFdC3meS7obRPEAF6TZVQGVQNtUJ3QiXQXdDd0AyoAtoH3QNFoHuh+6BRqA1qh/ZD90NroAegKPQg1AkdgA5CMagPegjqhx6G4tAjkB+qgh6FHoMehwahJ6AnoRD0FPQ09Aw0DI1Az0LPQYeg56FXodehN6C3oBegF6GXoJehV6DD0BHoTeg16G3oKKRDYegYdBxaAZ2ATkKnoBboNHQGOgs5IS+0EwpCQ9A5aAtUDxVDvVAD1AF5oPVQF1QKlUMOqEcqoDsNGY9/gV6R2SbvzaRxr+HJqsr5snFRqS6+bRRa/cav3zV+LTV+/Y7aCDVl/lEF+ufUxQbjM79s/HrZ+MDb2BD9oXGhY2c0aFzMm5D53y3Qf2lC5t9YoD+rftcV4+LL6idiW9Vue53aCPxH4+IHpojYUv++8Xc9ERE76v+stlqNC/0T6nd9Uv2uHxgXS3N7lr89IfN/XqAvUxe5PdXzxq+Nxm+qVb/pG4WZb3CB9oWIamAK9F3qb/oX42Kd+j3/qvY51Y7lReMiqT4yZlx8TV2o+cCoulCb7K+oi6vGRVxdfEX9b8k3KtP/H/V3vVYYEbur64yL5yZknkIFepXxEX2O+iKTuqpWVxvVV6WMi+7CTHwX6D518W/Gxe7CzFOhQN+pvnqu+uoD6kM/VvvT6uJ7xsVpdZHfEM/tf+sF6qtH1ZVJXe1TV/PU1Y8KM889438PG7K5MczRzBNne+aZklsBm7ECNmMFbMYK2IwVsBkrYDNWwGasgM1YAZuxAjZjBWzGCtiMFbAZK2AzVsBmrIDNWAGbsQI2YwVsxgrYjBWwGStgM1bAZqyAzVgBm7ECNmMFbMYK2IwVsBlrXjPWvGasec1Y85qx5jVjzWvGmteMNa8Za14z1rxmrBDNWCGyaoXC0DHoLOSEjkMrIC+0EzoB7YNOQkFoCDoFHYFaoHPQaeiMVEDfYZIH3zzY2vZgq9KDTX4PNi492Lj0YLPJg21MD7bLPdhs8mCzyYOtdA+20j3YevJgY92DjVIPNpQ82Db1YNvUg21TD7bnPdie92B73oPteQ827zzYvPNg08+DrTwPtmk92Kb1YMvfgy1/D7ZwPdjC9WAc4ME4wIPtXQ826DwYFXgwKvBgVODB5p0H28IebN5lNQeaCm2BtkLboHrICdVCvdB2aAfkgtyQB/JCE6Fd0HSoCCqDKqA+qB8agPzQbqgUmg8FoCA0CO2B9kLLoBA0BC2EmqAl0FyoERqGmqERaDK0CPJJBXRXJgC/bjyl/zaSfWuagcLMay97R7G6kfjwBPWF7swX5l696/HKXo/n5Xq8mtbju7Ee2bge+bcezwUHnqUOPPccyAdH9v/EY8pufhfog4WZJa9AvzdzB48XGZ9CxqeQ8SlkfAoZn0LGp/D/kULGp5DxKfw/ppDxKWR8ChmfQsankPEpZHwKGZ9CxqeQ8SlkfAoZn0LGp5DxKWR8ChmfwjMhhYxPIeNTyPgUvocpZHwKGZ9CxqeQ8SlkfAoZn0LGp/CsTCHjU8j4FDI+hYxPIeNTyPgUMj6FjE8h41PI+BQyPoXXUgoZn0LGp5DxKWR8Cq+eFDI+hYxPIeNTeJ2lkPEpZHwKGZ9CxqeQ8Sm8rlPI+BQyPoWMTyHjU8j4FFIlhYxPIeNTyPgUMj6FjE8h41PI+BQyPoWMTyHjU8j4FDI+hYxPIeNTyPgUMj6FjE8h41PI+BQyPpVNxp35ZJydS8ZEJhl3ZT6h3uvsE6plbjF6Uu0P1Sd8CPsNeIlvwBN0A15WG/Bt2YCQ3IAg3ICX/6bsP7TPNH528Ba6S3r8rfU/jLOD6lxnM84Ofghvtn/T3mO/33TtHQ2/kHlHw4Ess6/qv1Svar/uN11742dtS+T6J/88+5LfjeLsygRZnF3BTsYV7PBmtQpaDS2FJkFroBnQFGgtZIfWQV3QBmgjVA1tgmZDi6HNUAE0B6qHnFAvtB3aAbkgN+SBdkFlUAXUBw1ApdB8KAAFoUFoD7QXCkFN0DDUDI1Ak6E2qARqh1ZCDVAHZIM6oUrICs2D1kPLoSqoG5oGzYTKIQfUAvVAU6Et0FZoG1QLeaGJ0HSoCOqH/NBuaBk0BC2ElkBzoUZoEeSTCugBFYB6qypbnIWZTxdo38jEXoG+L9N5BzMR+Zjx8a7I9U3tMmxOl+HpltV+qApqgw5CRyEdaoXC0EnoGHQWckJBaAV0HBqCTkFeaCd0BGqBzkEnoNPQGWifVEAfNMmKuRsVczcq5m5UzN2omLtRMXejYu5Gxbw5o9yc+48y/6R7oTaoBGqHXoXWQK9Db0CdUCV0JzQDugvaB70FPQy9AL0ExaGXoUegauhR6HHoMPQkdAR6GmqBnoVeg96G7oEi0H3QKHQ3tB+6H3oAikJF0IPQAagMikEVUB/0ENQPvQj5oVegx6BB6AkoBD0F3QE9Aw1Db0Ij0HPQIamAvicTCReMHNdNkews/k2V8Gro/xX1kZ849M/P+m/sV37yIP/G8X1m3q5tjYiuNjfQz83x1WkC/dfVb3qPMf4/GRefUhsEK9Sfdylyw2A/P87/ofFrWeTdpvnvZ3Z/vXFRpx/q1Efyo3t16uEl9e/NzfCvz89/8rz++pT+PYbz2o+Mi+MmOaXPDPVfU3+bsRpr6YhsfPaaxM1O+t+jQPh7FE5/j/Ikq8VQAdQILZUK6CHTtX4rnem3hkzyUF8bXshtiOU2vHTbEIVtWNvbEOBtWD7aEOBtiJ82RH0b4qANUd+GuGtD3LVhKWtD+LUh/NqwzLVhYWtDFLYhCtuwzLUhGNsQjG2IwjYsem0IxjbUUW0IxjZEYRuisA1R2IZFrw0L2/9l794D2yzzO9FbIWmUzAQnmwQICbtsCoE2pKdNQkMTvO0u9gYSlJmMEEMCxLGJY0EiHBHeyI6dMowZjbnZwDDDcL+DuCjcCUzb7ck57vay7XpKt+a6255z7NB2e2+nV2979EqxeD4Nw1yZZWbCP3k/snxB0vt9fr/neV7pfIay84nJmhagL6E70JdRAd2J7kJ70d3oHnQv6kP70H3ofvQAehCV0FPoabQfPYQeRo+gR9Fj6HH0BCqjJ9Ez6FmUQteg59Dz6Dz0AnoRvYTWopfRAfQK6kA7UQ7tQb3oVdSOlqLpaDtagTaiHWgz2oQa0Ry0FbWFilJ91fh9IZ4eDa+kfa02t7WvotTPk9ARCR2R0BEJHZHQEQkdkdARCR2R0BEJHZHQEQkdkdARCR2R0BEJHZHQEQkdkdARCR2R0BEJHZHQEQkdkdARCR2R0BEJHZHQEQkdkdARCR2R0BEJHZHQEQkdkdARCR2R0BEJHZHQEQkdkdARCR2R0BEJHZHQEQkdkdARCR2R0BEJHZHQEQkdkbQRSRuRtBFJG5G0EUkbkfoRuRuRtBEjQsSIEJHQEeNDREJHJHREQkckdERCRyR0REJHJHREQkckdERCRyR0REJHJHREQkckdERCRyR0REJHJHREQkekaUSaRqR3RLZGZHlElkdkeUSWR2R5REJHJHREQke1hL4m8b+5Cau2Dn/93W/GjthcXW3Ori5+K81Yal3c6XTHv/G73pZ9mN3YEVumo9Rnqs/ztRX/WPyFeKX4N+M/7H9WDn4lPqivt8XruD/7Lxcdt7EsXF8N/uPKwS/FB5+tHPxW/GM+UznYGd8SL8D9RXxLfRV4cjWwvmQ5uRz4J5UbDsR37Y9/XHhR4zoG1nUMrOsYWNcxsK5jYF3HwLqOgXUdA+s6BtZ1DKzrGFjXMbCuY2Bdx8C6joF1HQPrOgbWdQys6xhY1zGwrmNgXcfAuo6BdR0D6zoG1nUMrOsYWNcxsK5jYF3HwLqOgXUdA+s6BtZ1DKzrGFjXMbCuY2Bdx8C6joF1HcPQOoahms5F16Dn0CuoAz2PzkM7UQ69gK5DL6I9qBe9hJ5Aa9Gr6GV0IFSUujZxeKrk1epUyWerCfFEHMuHdw2k/l0ivl9/9QsPV/yHcT48VDlr1xXjUqMhdVd8wweESj1LjsiQ1JQ4tppJkyOSYjKBfr/yhfb4C49WDo4No+OZyg09xxRrH0h4bnzwYOVgc3zweOXg3mOqL7iG9fvDhHuqcvAA8RX/X9/z/jn2dJz38cEjlYNV8cFj8WBJxO2vHHwsvqVcOXhtSphxT1YO/mTK+4VclLouEV650kTWNZF1TWRdE1nXRNY1kXVNZF0TWddE1jWRdU1kXRNZ10TWNZF1TWRdE1nXRNY1kXVNZF0TWddE1jWRdU1kXRNZ10TWNZF1TWRdE1nXRLo1kW5NpFsT6dZEujWRbk2kWxPp1kS6NZFuTaRbE+nWRLo1kW5NpFsT6dZEujWRbk2kWxPp1kS6NZFuTaRbE+nWRLo1kW5NpFsT6dZEujWRbk2kWxPp1lRLt88lwo0zWXY1Z9nVnGVXc5ZdzVl2NWdZfsyyqznLruYsS5NZdjVn2dWcZVdzll3NWXY1Z9nVnGVXc5ZdzVl2NWfZ1ZxlV3OWXc1ZdjVn2dWcZVdzlgXcLLuas+xqzrKrOcsibZZdzVl2NWfZ1ZxlV3OWXc1ZdjVn2dWcZTE5y67mLLuas+xqzrKrOcuu5iy7mrPsas6yqznLruYsu5qz7GrOsgSeZVdzll3NWXY1Z9nVnGVXc5ZdzVl2NWfZ1ZxlV3OWXc1ZdjVn2dWcZVdzll3NWXY1Z9nVnGVXc5ZdzVl2NWfZ1ZxlM0CWXc1ZdjVn2dWcZVdzll3NWXY1Z9nVnGVXc5ZdzVl2NWfZ1ZxlV3OWXc1ZdjVn2dWcZVdzll3NWXY1Z9nVnGVXc7Y2u1okALsJwG4CsJsA7CYAuwnAbgKwmwDsJgC7CcBuArCbAOwmALsJwG4CsJsA7CYAuwnAbgKwmwDsJgC7CcBuArCbAOwmALsJwG4CsJsA7CYAuwnAbgKwmwDsJgC7CcBuArCbAOwmALsJwG4CsJsA7CYAuwnAbgKwmwDsJgC7CcBuArCbAOwmALsJwG4CsJsA7CYAuwnAbgKwmwDsJgC7CcBuArCbAOwmALsJwG4CsJsA7CYAuwnAbgKwmwDsJgC7CcBuArCbAOwmALsJwG4CsJsA7CYAuwnAbgKwmwDsJgC7CcBuArCbAOwmALsJwG4CsJsA7CYAuwnAbgKwuxaAn68G4J2Vdmt93IlN9lkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9Fkt9FkttT5roHqWDVUGjn+unlYNqb89pvo4N6T6p1RPpobU706pPmMNqaeOqb74G1I3TKk+vw2pO+Np9n8fzwW9NaV6sjWk/mBK9RXbkHp9SvU0akj9m+oU9vXV3/RKxb82OeOzu/qFGxJhpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNJpdNZq3RuTHx/Xhf6LV0OOnkV6NGLPz/SF39+V675/B5c6nmw8nf9ZPHDuOTzJsqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRIcqRoVo5cnMi3NL78JTwqarpeDQbLUTnomvRseizqB+diOaj69DnUBF9Hg2g69H5aAO6Ad2I0ugmdDMaRBk0hG5Bt6Jd6DaUR19At6Mvot1oAfoSugN9GRXQnegutBfdje5B96I+tA/dh+5HD6AH0UPoYfQIehQ9hh5HJfQEehI9hZ5GZbQfPYOeRSl0DXoOPY/OQy+gF9FLaC16GR1Ar6AOtBPl0B7Ui15F7Wgz2oSWokY0HW1HK9BGtAPNQVtRG5qH5qKT0GJ0NkqiqegEdAo6Dc1Czeg4tAydjJrQcrQarUGL0FloCWpAK1ErOgfNQKeiVaGi1GBi8k2m3o537f7buN/uPKb66mxIlasb7YYSYeOQo3HI0TjkaBxyNA45GoccjUOOxiFH45CjccjROORoHHI0DjkahxyNQ47GIUfjkKNxyNE45GgccjQOORqHHI1DjsYhR+OQo3HI0TjkaBxyNA45GoccjUOOxiFH45CjccjROORoHHI0DjkahxyNQ47GIUfjkKNxyNE45GgccjQOORqHHI1DjsYhR+OQo3HI0TjkaBxyNA45GoccjUOOxiFH45CjccjROORoHHI0DjkahxyNQ47GIUfjkKNxyNE45GgccjQOORqHHI1DjsYhR+OQo3HI0TjkaBxyNA45GoccjUOOxiFH45CjccjROORoHHI0DjkahxyNQ47GIUfjkKNxyNE45GqNwy2J4N2xfi2+bXfq1moo1rdY8yDVdC46ECpK3Vb99smpufqkV31WcXKWsj6z9TOVGwaLwSxQfQ6pPgc4OW0ZVX5E2Om8NiV8bdV0PJqNFqJz0bXoWPRZ1I9ORPPRdehzqIg+jwbQ9eh8tAHdgG5EaXQTuhkNogwaQregW9EudBvKoy+g29EX0W60AH0J3YG+jAroTnQX2ovuRvege1Ef2ofuQ/ejB9CD6CH0MHoEPYoeQ4+jEnoCPYmeQk+jMtqPnkHPorUoha5Bz6Hn0XnoBfQiegm9jA6gV1AH2olyaA/qRa+iLJqOVqCNaBPajOagragNtaOlaDvagRpDRanbCeMMYZwhjDOEcYYwzhDGGcI4QxhnCOMMYZwhjDOEcYYwzhDGGcI4QxhnCOMMYZwhjDOEcYYwzhDGGcI4QxhnCOMMYZwhjDOEcYYwzhDGGcI4QxhnCOMMYZwhjDOEcYYwzhDGGcI4QxhnCOMMYZwhjDOEcYYwzhDGGcI4QxhnCOMMYZwhjDOEcYYwzhDGGYIzQzhmCMcMcZghxDOEeIYQzxDiGUI8Q4hniO0MYZwhxDOEcYYwzhC/GeI3Q/xmiN8M8ZshfjPEb4b4zRD+GcI4QxhnCOMMYZwhjDOEcYYwzhDGGcI4QxxmiMMM0ZwhHDMEdYagzhCcGYI6Q4hnCNUMIZ4hxDOEeKYWv19MhB+uOxykaBVR6kuJ789dCh+Jd69Oxf/r66cVP4SdDF9/A0N930J9J8P3bAPDf6n8e1zxB+ddrOsbGepbG47c0VDfyPAB+xfqux7qmx2+629eXd/Z8t6WhjuOnrrf8zeej9/3fN3346l79JT9KJyyX66espOVUyuVUyt9RSu9Qyv1VysdTyt9RSsVVyvVWCt9RSvdQiu9WCv9Viv9VitVXCs9VSvdVys9VSu9Qyu9Qyu9QyuVYSu9Qyt9YSudRCu9Qyv9QSv1ZSvVbSs1civdQiuVaCuVaCv9QSt1aSsdZCsdZCs9Yys9Yyv1bCv1bE396AZ0I7oJ7UQ3oxyahgbREJqNbkG3ovloF7oN5dFudAfagwroTrQX3Y160WfQq+he1If2ofvRA+hBVEJPoafRfvQQegQ9ih5HT6Jn0MPoMVRG7Wgz2oSWokY0HW1HK9BGtAPNQVtRW6godWc1fg//8et/O/j7akiFmB5ie4gVITaGyIZIhtgRIhNic4iLQmwKcXGI10M0htgTojfEnBBvhNgaoi3E3BAnhTg/xLEhNoT4RIhPhvhUiLNDpENcEOL4EKeEOC3EiSFmhbgwxKdDNIdYEOKSEAtDXBriuBBbQpwcYlGIs0K0hmgIsTbEqSHmhbgsxLYQHSEWh+gMcXmIK0LsDDE1xJUhTggxLcTsEPND7AqRD3FViN0hrg6xLEQUohCiO0RPiKYQe0MsD7E6xJoQS0KsDNEX4pwQ+0LMCLEqxJsh3grxToi3Q3QFiFJ3JcK3/P6bRHBaH9ZJaCk6Fm1Ai9F0tAKdjbIoidLoCjQVnYCmoePRbHQKOg2diOajXWgWyqNmtADtRgtRIzoOLUMFdDJqQj1oL1qOVqM1aBGag85CrWglakB96By0BO1DM9CpaFWoqNL5h2tP/dS2/fQ7/VSz/fQY/fRC/fRC/XRi/XQ//VTr/fRJ/dTE/fRJ/XQO/XQO/fSI/fQR/fQR/fSP/fSI/XQO/XQO/fSI/fQR/XQO/XQH/XST/fQK/XQH/XQH/fQD/fQD/fQD/fSP/fSP/fSP/XQO/fSP/XSM/XQV/fSP/XQV/XQV/fSW/fQY/fQY/XST/fQR/fQR/fQR/fSW/XQV/XQV/XQV/XQH/dT1/fQK/fQK/dT8/XQO/XQqNT2BnkRPoadRGe1Hz6BnUQpdg55Dz6Pz0AvoRfQSWoteRgfQK6gD7UQ5tAf1oldRO9qMNqGlqBFNR9vRCrQR7UBz0FbUFipK3ZM4Oj/9PZqfjhdm/rZ49BrZ7+Y89RcTDYmG+L+P/FWz3/2rZe+tnLqVAG5IHTcl3u55X6K2X7N6eq//o6BaqSJK3Z8IJlZSs9jGPYsN37NoMmrahC5Gr6MUakTT0Xa0B61AG1EWJdEO1IvmoDfQVpRBbWguOgmdj45FG9An0CfRp9DZKI0uQMejU9Bp6EQ0C12IPo2a0QJ0CVqILkXHoS3oZLQIvYPOQq2oAa1Fp6J56DK0DXWgxagTXY6uQDvRVHQlOgFNQ7NRF5qPdqE8ugq9iXajq9FbaBmKUAF1ox7UhPai5Wg1WoOWoJWoD52D9qEZ6G20KlSUeqAaqpPl7C9Q6v4CTekvUJb+Qq38ejBx+J3Et1Qz/KFEeB3TIQLmEAFziKg9RNwcIm4OEbyHCJ9DhM8hgvcQwXuIYDpEMB0ihg8RU4eIqUOE6yFC6xChdYjQOkRoHSK0DhFahwitQwxrhxjIDjEAHmJYO0TYHSLsDhF2hwi7Q4TdIcLuEGF3iLA7RNgdYrA6RNgdIuwOEXaHGMgOEX2HGMgOEYSHCMKa2tFlaBtaijrQYrQddaIsuhxdgXagnWgquhKdgKah2Wg+2oXy6Cq0G12NGtEyFKE9qIC6UQ9qQntRL1qOVqM1aAlaifrQOWgfmoFWoa5QUerhRLj3op04bWderZ25s3bmH9qZ8WtnXq2dGYd2ZiPamVdrZ7asnbnIdqK9nfnGdmYx2plTbGf2sZ05xXbmztqZO2tn7qydmZF25s7amRdtZyatnbmzdubH2plfaWd2p53ZpHZmy9qZiWlnJqad+bF2BsB2ZlDbmUFtZ860nTnTduZz2pnPqakf3YBuRDehnehmlEPT0CAaQrPRLehWNB/tQrehPNqN7kB7UAHdifaiu1Ev+gx6Fd2L+tA+dD96AD2ISugp9DTajx5Cj6BH0ePoSfQMehg9hsqoHW1Gm9BS1Iimo+1oBdqIdqA5aCtqCxWlHkmEey/+Nvjba7goxNIQm0JcHOL1EKkQjSGmh9geYk+IFSE2hsiGSIbYEaI3xJwQb4TYGiIToi1AlHo0EVx4+2Y8iO1OPZYIq/hxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvhxqvjxWhX/eCKcFPkKVfxXqJy/Qk34ldooVKp+ezzj/Z9ZS5hcAqnPoE+uE9Vn0uuLDPVVofpqQ31mv77yUV8Vqq941BcgJhcT6jP8R07s19ex6os39XWs96bon6j+n9xQ8dr4rpOV98fpSD5O/f5x+pqPUzd+nKr84/Q8H+dxreka9CJ6Dr2COtAedB56HvWil9BOlENPoLXoVfQCehkdQNeFilJPJsLK5m+CQaOGi0IsDbEpxMUhXg+RCtEYYnqI7SH2hFgRYmOIbIhkiB0hekPMCfFGiK0hMiHaAkSpp8JHLLWIUWIRdcsiapNFjBKLqEYWUY0sYsxYRP2xiFFiERXHIsb8RVQHi6gOFlEP1PQ6akR7UC+ag95AW1EbmotOQuejY9EG9An0SfQpdDZKowvQ8egUdBo6Ec1CF6JPo2a0AF2CFqJL0XFoCzoZLUJnoVbUgNaiU9E8dBnahjrQYtSJLkdXoJ1oKroSnYCmodloPtqF8ugqtBtdjZahCBVQN+pBTWgvWo5WozVoCVqJ+tA5aB+agVahN9Fb6B30NuoKFaWerij+3O7UW9VPji1XM/YPKr768HaN9aX4bvsTh5f2/6l6t2cYvA6EQ9SBcIQ5EI4wB8JB5UA4qBwIB5UD4aByIBxUDoQDxIHgxVHDmyE2h7goxKYQF4d4PcRbIRpD7AnRG2JOiHdCbA3RFuLtAFHq2eoDOzkdO0b5MUZBNUYhNlYrKp6rfnu80+TGRDXNG9bfF+Rcgu9JULwlKN4S/K4ExVuCci1BuZagXEtQoCUo0BIUYQmKsASlVYLyKUHpmKAgTFD0JSj6EhR2CR7ZBIVdglIuQSmXqD3Oz/P6/1r4gvta+IL7WnhmfC189X0tfPV9LXz1fS14HmpoDDE9xPYQe0KsCLExRDZEMsSOEL0h5oR4I8TWEJkQbQGi1AuJcAqqj9Kjj9Kjj1Kuj0Kkj0KkjzKvj7Kkj7Kkj6Kvj6Kvj5Klj5KljxKwjwKmjwKmj4Kwj3Kmj3Kmj3Kmj3Kmj3Kmj3Kmj3KmjyKzjyKzj3K0j5KzjzKojzKojzKojzKojzKojzKojzKojzKojzKoj8K1j6Koj6Koj6Koj6K2jxKpjxK3j4Kpj4KppnZ0GdqGlqIOtBhtR50oiy5HV6AdaCeaiq5EJ6BpaDaaj3ahPLoK7UZXo0a0DEVoDyqgbtSDmtBe1IuWo9VoDVqCVqI+dA7ah2agVagrVJR6MRFOQf0iY+gvMtr+IiPOL9ZGnJcSk5+Y9geJ6n0b1i+Nb385cXS7dHxD/BYbqxLFo58p9H22X/qHcJv0gUR4gdk7LODXdDyajRaic9G16Fj0WdSPTkTz0XXoc6iIPo8G0PXofLQB3YBuRGl0E7oZDaIMGkK3oFvRLnQbyqMvoNvRF9FutAB9Cd2BvowK6E50F9qL7kb3oHtRH9qH7kP3owfQg+gh9DB6BD2KHkOPoxJ6Aj2JnkJPozLaj55Bz6IUugY9h55H56EX0IvoJbQWvYwOoFdQB9qJcmgP6kWvona0GW1CS1Ejmo62oxVoI9qB5qCtqA1lQ0WpVxK1/c7rD8XzWq8mwi41T5eap0vN06Xm6VLzdKl5utQ8XWqeLjVPl5qnS83TpebpUvN0qXm61Dxdap4uNU+XmqdLzdOl5ulS83SpebrUPF1qni41T5eap0vN06Xm6VLzdKl5utQ8XWqeLjVPl5qnS83TpebpUvN0qXm61Dxdap4uNU+XmqdLzdOl5ulS83SpebrUPF1qni41T5eap0vN06Xm6VLzdKl5utQ8XWqeLjVPl5qnS83TpebpUvN0qXm61Dxdap4uNU+XmqdLzdOl5ulS83SpebrUPF1qni41T5eap0vN06Xm6VLzdKl5utQ8XWqeLjVPl5qnS83TpebpUvN0qXm61Dxdap4uNU+XmqdLzde61K/EAVj9RJv1LxXf+0CbeiQOEomDROIgkThIJA4SiYNE4iCROEgkDhKJg0TiIJE4SCQOEomDROIgkThIJA4SiYNE4iCROEgkDhKJg0TiIJE4SCQOEomDROIgkThIJA4SiYNE4iCROEgkDhKJg0TiIJE4SCQOEomDROIgkThIJA4SiYNE4iCROEgkDhKJg0TiIJE4SCQOEomDROIgkThIJA4SiYNE4iCROEgkDhKJg0TiIJE4SCQOEomDROIgkThIJA4SiYNE4iCROEgkDhKJg0TiIJE4SCQOEomDROIgkThIJA4SiYNE4iCROEgkDhKJg0TiIJE4SCQOEomDROIgkThIJA4SiYNE4mAtEn+honjyJnX/MXGJ+IuJsHsv072X6d7LdO9luvcy3XuZ7r1M916mey/TvZfp3st072W69zLde5nuvUz3XqZ7L9O9l+ney3TvZbr3Mt17me69TPdepnsv072X6d7LdO9luvcy3XuZ7r1M916mey/TvZfp3st072W69zLde5nuvUz3XqZ7L9O9l+ney3TvZbr3Mt17me69TPdepnsv072X6d7LdO9luvcy3XuZ7r1M916mey/TvZfp3st072W69zLde5nuvUz3XqZ7L9O9l+ney3TvZbr3Mt17me69TPdepnsv072X6d7LdO9luvcy3XuZ7r1M916mey/TvZfp3st072W69zLde5nuvUz3XqZ7L9O9l+ney3TvZbr3Mt17me69TPdepnsv072X6d7LdO81zUNz0UloMTobJdFUdAI6BZ2GZqFmdBxahk5GTWg5Wo3WoEXoLLQENaCVqBWdg2agU9GqUFHqlxLhVZIbKE43UPRtoKDYUBti/1MiuGbljfi23alfTnyLn/b2TXzKW3UOPzk1/pX/Z/XHf4fLZB/a6ti3tCg2uRb24a181R/I7/aq1vfZalZ9FesbLl59h+9F/x2uWX1LS1Xx2vGC4gcvWR1MHH5XiGJ1+9//VT15JiujedRC86gR51EjzqNmm0ed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B1+f8fE9p9ujRHC2cPBWMRH8SfjsWPvN4MlRQnWI2SHGhhgZYkaIeSGWhhgVYniIySFGhJgUYlyImSHqQlSFmBBiTIiVIa4IMSXE1BDlISaGmBNieohlIepDLA6xJMS0EBUhFoaoDVEWYn6IFSFGh5gVYkGAZOy/F0+UgZZiMKwPtkUD/dZgIh8MrYPhd7BViYLtnTRePYWDF4ZEf8+fclFWnKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenAFcnCFbnCFbnLFanGFgnGFgnGFgnGFgnGFgnGFgnPFfnKFenGFgnKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenKFenMFdnFFdnFFdnFFdnFFdnFFdnEFhnEFhnNFgnKFenKFenKFevDTU+x/F8jtQyJZTyJZTyJZTyJZTyJZTyJZTyJZTyJZTyJZTyJZTyJZTyJZTyJZTyJZTyJZTyJZTyJZTyJZTyJZTyJZTyJZTyJZTyJZTyJZTyJZTyJZTyJZTyJZTyJZTupZTupZTupZTupZTupZTupZTupZTupZTupZTupbzRF/OE72k1ehW1I7eRBeht1AGvY1Oo5fQKnQGnUXvoF1oH0qgFGpC50IlY9/55OvO5vC6s8HZ3SeH6J8chn6Wl5t9sV9m9r9NYmOjokuBZjX/SF5n9kN/edmP8FVl39eryQYH7B+Pgf9n8TyMTrbe6FN/oDcr+fG+Scn/4grd2iHhuljS5Wg22oKuQO+iGCpHI9FulELzUBztQaPQXtSEKtB7aBvaiLajC1A1ugRdipaiDagKjUGb0GbUgKaiq9B0tBBdjcrQLLQLXYOuRdeh69E4dAOagPajG9H7KI/moCQ6hG5Gt6DDaDE6glago2g0+gCtQ2PRenQxugxNQjNRHVqJpqAr0UQ0DX2IVqFK1Ih2ohloHxqOJqMR6AA6iG5Cy1A9WoJq0Xy0IFQy9mfFovpfP3pwTPH1Gf8N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cyTdOZLuHEl3jqQ7R9KdI+nOkXTnSLpzJN05ku4cSXeOpDtH0p0j6c6RdOdIunMk3TmS7hxJd46kO0fSnSPpzpF050i6cyTdOZLuHEl3jqQ7R9KdI+nOkXTnSLpzJN05ku4cSXeOpDtH0p0j6c6RdOdIunMk3TmS7hxJd46kO0fSnSPpzpF050i6cyTdOZLuHEl3jqQ7R9KdI+nOkXTnSLpzJN05ku4cSXeOpDtH0p0j6c6RdOdIunMk3TmS7hxJd46kO0fSnSPpzpF050i6cyTdOZLuHEl3jqQ7R9KdI+nOkXTnSLpzJN05ku4cSXeOpDtH0p0j6c6RdOdIunMk3TmS7hxJd46kO0fSnSPpzpF050i6cyTduUrS/UQ5/P5xdMp8+NTv9SPKL23NkvrSf/9r6b8nlQNfzZLby2GmJjE4MvrOJ8lZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBslZBis5y1PRycV3S793TnRu8emjV+8fvXr/5+RehtEdBa752b96/xmu3v99VquKzkYJNA4tRTGURMvQDLQcnYPmo7FoBToXrUST0KmoAdWjY9F56Hx0AVqFmtGFaBGqQxehyehidAK6BJ2CTkK1aA66FNWg1WgxWoNOQ8ejy9Dl6Ao0Da1FU9A6tB6lUBpdiTagjWg02oRORGPQBDQRbUZb0DVoK2pB49HpqBVtQxl0LboOLUDb0Q40Hc1F89BUNBPtRAvRLhRHs9HVoVoTz5YD4NooV4lCZHQz19TIcqCrWXJM+/2JM6KE5E9GlP+kmiXfir7lueFTqoljom8Zrq82VuqI58tfHS4H76AcvIOC7I7KN7zwSQ6VWDgqSqJeLN8c6e9H95+OQvVVpS+8Uvr1iWXRI79d2vhWtNHd/mmN0UbUbiNqtxG124jabUTtNqJ2G1G7jajdRtRuI2q3EbXbiNptRO02onYbUbuNqN1G1G4jarcRtduI2m1E7TaidhtRu42o3UbUbiNqtxG124jabUTtNqJ2G1G7jajdRtRu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'
)
DATA = pickle.loads(zlib.decompress(base64.b64decode(DATA)))
MEMO = (
b'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'
)
MEMO = pickle.loads(zlib.decompress(base64.b64decode(MEMO)))
Shift = 0
Reduce = 1
def Lark_StandAlone(**kwargs):
  return Lark._load_from_dict(DATA, MEMO, **kwargs)
