import os, sys
import paramiko
import re
import subprocess
import ipaddress

from python_terraform import *
from logger import LOGGER

#KVM_CLOUD_IMAGE = "https://cloud-images.ubuntu.com/bionic/current/bionic-server-cloudimg-amd64.img"
#KVM_CLOUD_IMAGE = "https://cloud-images.ubuntu.com/focal/current/focal-server-cloudimg-amd64.img"
EDGE_IMAGER = "https://imager.flexiwan.com"
TIMEOUT = 300
base_image = ""
SUPPORTED_TOPOS = ["1-site", "3-site"]
REPOSITORIES = ["setup-main", "setup-testing", "setup-unstable"]
TESTBED_CONFIG_PATH = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))),
                                   "infra",
                                   "kvm",
                                   "instances")
BRIDGE_INTERFACE_LIST = ["c1-edge1", "c1-edge2", "c1-edge3", "edge1-cr1", "edge1-cr2", 
                         "edge2-cr1", "edge2-cr2", "edge3-cr1", "edge3-cr2", "cr1-cr", "cr2-cr"]
#BASE = None
PACKER_FOCAL_FILE = "ubuntu-focal.pkr.hcl"
PACKER_EDGE_FILE = "ubuntu-fwedge.pkr.hcl"

def add_args(parser):
    """ Supports the command-line arguments listed below """

    parser.add_argument('-s', '--server',
                        required=True,
                        action='store',
                        help='kvm host')
    parser.add_argument('-u', '--username',
                        required=True,
                        action='store',
                        help='SSH username to access the Server')
    parser.add_argument('-k', '--ssh_key',
                        required=True,
                        action='store',
                        help='SSH Key file to access the Server')
    parser.add_argument('-t', '--topo',
                        action='store',
                        default='3-site',
                        choices=SUPPORTED_TOPOS,
                        help=f'supported topologies are: {SUPPORTED_TOPOS}')
    parser.add_argument('-r', '--repo',
                        action='store',
                        default='setup-testing',
                        choices=REPOSITORIES,
                        help=f'Repositories to pull the images: {REPOSITORIES}')
    parser.add_argument('-ev', '--edge_version',
                        required=True,
                        action='store',
                        help='Version of the fwagent')
    parser.add_argument('-m', '--management-ip',
                        required=True,
                        action='store',
                        help='Static management network with netmask')
    parser.add_argument('-fm', '--flexi-manage',
                        action='store',
                        help='Flexi Manage Host')
    parser.add_argument('-tk', '--token',
                        default=False,
                        action='store',
                        required=True,
                        help='Token of the organization')
    parser.add_argument('-ak', '--access_key',
                        default=False,
                        action='store',
                        required=True,
                        help='Access key to access the device')
    parser.add_argument('-l', '--log_level',
                        default='INFO',
                        action='store',
                        help='Log file to log the activities')                 
    parser.add_argument('-lf', '--log_file',
                        default=sys.stdout,
                        action='store',
                        help='Log file to log the activities')             

def build(args):
    """ Command line program for building KVM topology """

    topology=args.topo
    LOGGER.log.info(f"Start creating requested topology: {topology}")
    create_bridge_interface(args)
    enable_internet_access_on_server(args)
    base_client_image=create_image(args, PACKER_FOCAL_FILE, image_type="client")
    base_edge_image=create_image(args, PACKER_EDGE_FILE, image_type="edge")
    LOGGER.log.info(f"Base Focal Image Generated by packer is at: {base_client_image}")
    LOGGER.log.info(f"Base Edge Image generated by packer is at: {base_edge_image}")

    create_topology(args, client_image=base_client_image, edge_image=base_edge_image)
    data = get_output_file(args)
    apply_access_on_server(args, data)
    prepare_setup_json(args)

def destroy(args):
    """ Command line program for cleaning up KVM topology """

    topology=args.topo
    LOGGER.log.info(f"Start Deleting the Existing topology: {topology}")
    delete_topology(args)
    delete_bridge_interface(args)
    revoke_access_on_server(args)

def _exec_remote_command(hostname, username, ssh_key_file, command):
    """
    Function to execute command in remote machine via SSH

    Args:
        hostname - Hostname/IP of the remote machine on which we need to execute the SSH 
        username - SSH Username to access the Remote machine
        ssh_key  - SSH Key to access the Remote machine
    
    Return:
        output   - Output of command execution
    """
    client = paramiko.SSHClient()
    client.load_system_host_keys()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    try:
        client.connect(hostname=hostname, username=username, key_filename=ssh_key_file)
        LOGGER.log.info(f'Executing command: {command}')
        stdin, stdout, stderr = client.exec_command(command)
        LOGGER.log.info(f'Output: {stdout.readlines()}')
        print(stderr.read())
        client.close()
        return True
    except Exception as e:
        LOGGER.log.error(f"Failed executing the ssh command: {e}")
        client.close()
        sys.exit()

def create_bridge_interface(args):
    """
    Function to create bridge interfaces on the KVM Hypervisor using brctl command

    Args:
        args - list of command line arguments
    
    Return: 
        bool - True if the bridge interfaces are created else, False 

    """
    server = args.server
    username = args.username
    ssh_key_file = args.ssh_key
    client = paramiko.SSHClient()
    client.load_system_host_keys()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    try:
        client.connect(hostname=server, username=username, key_filename=ssh_key_file)
        client.exec_command(f'sudo brctl show')
        LOGGER.log.info(f"Creating Bridge interface in the KVM Server {server}")
        for interface in BRIDGE_INTERFACE_LIST:
            stdin, stdout, stderr = client.exec_command(f'sudo brctl addbr {interface}')
            err = stderr.read().decode()
            if err and not re.search(f"{interface} already exists", err):
                LOGGER.log.info(f"Error Creating Bridge Interface {err}")
                raise Exception("Not able to create Bridge interface in the Server")
            
            LOGGER.log.info(f"Added new bridge interface {interface}")
            stdin, stdout, stderr = client.exec_command(f'sudo ip link set {interface} up')
            err = stderr.read().decode()
            if err:
                LOGGER.log.error(f"Error Bringing up the interface {err}")
                raise Exception("Not able to Bring up the interface")
            LOGGER.log.info(f"Newly created interface {interface} is brought UP")
        client.close()
        return True
    except Exception as e:
        LOGGER.log.error(f"Failed Creating/Bring up the Bridge interface on the server Error: {e}")
        client.close()
        sys.exit()
    
def delete_bridge_interface(args):
    """
    Function to delete bridge interfaces on the KVM Hypervisor using brctl command

    Args:
        args - list of command line arguments
    
    Return: 
        bool - True or False based on the execution

    """
    server = args.server
    username = args.username
    ssh_key_file = args.ssh_key

    client = paramiko.SSHClient()
    client.load_system_host_keys()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    try:
        conn = client.connect(hostname=server, username=username, key_filename=ssh_key_file)
        stdin, stdout, stderr = client.exec_command('sudo brctl show')
        LOGGER.log.info(stdout.readlines())
        LOGGER.log.info(f"Delete the Existing Bridge interface in the KVM Server {server}")
        for interface in BRIDGE_INTERFACE_LIST:
            stdin, stdout, stderr = client.exec_command(f'sudo ip link set {interface} down')
            err = stderr.read().decode()
            if err:
                LOGGER.log.error(f"Error Bringing Down the interface {err}")
                raise Exception("Not able to Bring Down the interface")
            LOGGER.log.info(f"Interface {interface} is brought Down to be Deleted")
            stdin, stdout, stderr = client.exec_command(f'sudo brctl delbr {interface}')
            err = stderr.read().decode()
            #print(err)
            if err:
                LOGGER.log.error(f"Error Deleting Bridge Interface {err}")
                raise Exception("Not able to Delete the Bridge interface in the Server")
            LOGGER.log.info(f"Deleted the bridge interface {interface}")
        client.close()
    except Exception as e:
        LOGGER.log.error(f"Failed to Delte/Bring Down the Interface on the server Error: {e}")
        client.close()
        sys.exit(1)
    
def create_image(args, packer_file, image_type='client'):
    """ Create the golden image to use in the infrastructure code 

    Args:
        args (argument): Arguments passed during the execution
        base_image(str): Path to the base image which is used for intalling. 

    Returns:
        obj: testbed object
    """
    try:
        server_ip = args.server
        management_network = args.management_ip
        username = args.username
        ssh_key_file = args.ssh_key
        base_image_path = os.path.join(TESTBED_CONFIG_PATH, args.topo)
        version = ''
        repo = args.repo
        packer_path = os.path.join(TESTBED_CONFIG_PATH, args.topo, "packer")
        default_int_name = get_interface_name_of_destination(args, "default")
        mgmt_ip = ipaddress.IPv4Interface(f'{management_network}')
        packer_mgmt_ip = ipaddress.IPv4Network(mgmt_ip.network)[101]
        LOGGER.log.info("Creating Image via Packer")
        LOGGER.log.info("Configuring the Packer SSH access")
        cmd = f'sudo iptables -t nat -A PREROUTING -m comment --comment "packer-ssh" -i {default_int_name} -p tcp --dport 10011 -j DNAT --to-destination {packer_mgmt_ip}:22'
        _exec_remote_command(hostname=server_ip, username=username, ssh_key_file=ssh_key_file, command=cmd)        
        cmd=f"sudo virsh pool-define-as --name default --type dir --target /var/lib/libvirt/images"
        _exec_remote_command(hostname=server_ip, username=username,ssh_key_file=ssh_key_file, command=cmd)
        cmd=f"sudo virsh pool-start default"
        _exec_remote_command(hostname=server_ip, username=username,ssh_key_file=ssh_key_file, command=cmd)
        cmd=f"sudo virsh pool-autostart default"
        _exec_remote_command(hostname=server_ip, username=username,ssh_key_file=ssh_key_file, command=cmd)
        if image_type != "client":
            if args.edge_version != "latest":
                version = f"flexiwan-router={args.edge_version}"
            else:
                version = f"flexiwan-router"

            pkr_init=f"sudo packer init {packer_file}"
            _exec_shell_command(pkr_init, packer_path)
            pkr_validate=f"sudo packer validate -var username={username} -var ssh_key_file={ssh_key_file} -var server_ip={server_ip} -var mgmt_network={management_network} -var edge_version={version} -var repo=setup-{repo} {packer_file}"
            _exec_shell_command(pkr_validate, packer_path)
            pkr_build=f"sudo packer build -var username={username} -var ssh_key_file={ssh_key_file} -var server_ip={server_ip} -var mgmt_network={management_network} -var edge_version={version} -var repo={repo} {packer_file}"
            #pkr_build=f"sudo packer build -var username={username} -var ssh_key_file={ssh_key_file} -var server_ip={server_ip} -var mgmt_network={management_network} {packer_file}"
            _exec_shell_command(pkr_build, packer_path)
            jfile = open(os.path.join(packer_path, "ubuntu-fwedge-manifest.json"))
            artifact_path = json.load(jfile)['builds'][0]['artifact_id']
            LOGGER.log.info(f"The Edge artifact id is : {artifact_path}")
            LOGGER.log.info(f"Setting Packer user permission for edge artifact")
            _exec_remote_command(hostname=server_ip, username=username, ssh_key_file=ssh_key_file, command=f"sudo chown {username}:{username} {artifact_path}")
            LOGGER.log.info(f"SCPing the edge artifact from KVM host to local disk")
            _exec_shell_command(f"scp -i {ssh_key_file} {username}@{server_ip}:{artifact_path} {base_image_path}")
            packer_image_path = os.path.join(base_image_path, artifact_path.split("/")[-1])
        else:
            _exec_shell_command(f"sudo packer init {packer_file}", packer_path)
            pkr_validate=f"sudo packer validate -var username={username} -var ssh_key_file={ssh_key_file} -var server_ip={server_ip} -var mgmt_network={management_network} {packer_file}"
            _exec_shell_command(pkr_validate, packer_path)
            pkr_build=f"sudo packer build -var username={username} -var ssh_key_file={ssh_key_file} -var server_ip={server_ip} -var mgmt_network={management_network} {packer_file}"
            _exec_shell_command(pkr_build, packer_path)
            jfile = open(os.path.join(packer_path, "ubuntu-focal-manifest.json"))
            artifact_path = json.load(jfile)['builds'][0]['artifact_id']
            LOGGER.log.info(f"The Client artifact id is : {artifact_path}")
            LOGGER.log.info(f"Setting Packer user permission for client ubuntu artifact")
            _exec_remote_command(hostname=server_ip, username=username, ssh_key_file=ssh_key_file, command=f"sudo chown {username}:{username} {artifact_path}")
            LOGGER.log.info(f"SCPing the artifact from KVM host to local disk")
            _exec_shell_command(f"scp -i {ssh_key_file} {username}@{server_ip}:{artifact_path} {base_image_path}")
            packer_image_path = os.path.join(base_image_path, artifact_path.split("/")[-1])

        LOGGER.log.info("Revoking the Packer SSH access")
        cmd = f'sudo iptables -t nat -D PREROUTING -m comment --comment "packer-ssh" -i {default_int_name} -p tcp --dport 10011 -j DNAT --to-destination {packer_mgmt_ip}:22'
        _exec_remote_command(hostname=server_ip, username=username, ssh_key_file=ssh_key_file, command=cmd)        
        return packer_image_path

    except Exception as e:
        LOGGER.log.error(f"Exception occurred {str(e.stdout)}")
        sys.exit(1)

def create_topology(args, client_image, edge_image):
    """ Gets the topology object

    Args:
        args (argument): Arguments passed during the execution
        base_image(str): Path to the base image which is used for intalling. 

    Returns:
        obj: testbed object
    """
    try:
        server_ip = args.server
        token = args.token
        access_key = args.access_key 
        version = args.edge_version
        management_network = args.management_ip
        username = args.username
        ssh_key_file = args.ssh_key
        topology_config_path = os.path.join(TESTBED_CONFIG_PATH, args.topo)    
        tfvar_dict = {  'server_ip': server_ip, 
                        'username': username,
                        'ssh_key_file': ssh_key_file,
                        'token': token,
                        'ubuntu_base_path': client_image,
                        'ubuntu_fwedge_path': edge_image,
                        'mgmt_network': management_network,
                        'edge_version': version,
                        'access_key': access_key
                    }
        tf = Terraform(working_dir=topology_config_path, variables=tfvar_dict)

        return_code, stdout, stderr = tf.init()
        if not stderr:
            LOGGER.log.info(stdout)
            LOGGER.log.info("Terraform Initialization is Done Successfully!")
        else:
            LOGGER.log.error(stderr)
            raise Exception("Terraform Initialization not Done!")

        return_code, stdout, stderr = tf.plan(capture_output=True)
        if not stderr:
            LOGGER.log.info(stdout)
            LOGGER.log.info("Terraform Plan is Done Successfully!")
        else:
            LOGGER.log.error(f"Error Occurred: {stderr}")
            raise Exception("Terraform Plan not Done!")
 
        return_code, stdout, stderr = tf.apply(skip_plan=True, capture_output=True)
        if not stderr:
            LOGGER.log.info(stdout)
            LOGGER.log.info("Terraform Plan is Applied Successfully!")
        else:
            LOGGER.log.error(f"Error Occurred: {stderr}")
            raise Exception("Terraform Plan not Applied!")

    except Exception as e:
        LOGGER.log.error(f"Exception occurred {str(e)}")
        sys.exit(1)

def delete_topology(args):
    """ Deletes the topology object

    Args:
        args (argument): Arguments passed during the execution

    Returns:
        obj: testbed object
    """
    try:
        server_ip = args.server
        token = args.token
        version = args.edge_version
        management_network = args.management_ip 
        username = args.username
        ssh_key_file = args.ssh_key
        topology_config_path = os.path.join(TESTBED_CONFIG_PATH, args.topo)
        tfvar_dict = { 'server_ip': server_ip, 
                        'username': username,
                        'ssh_key_file': ssh_key_file,
                        'token': token,
                        'ubuntu_base_path': base_image,
                        'mgmt_network': management_network,
                        'edge_version': version
                    }
        tf = Terraform(working_dir=topology_config_path, variables=tfvar_dict)

        return_code, stdout, stderr = tf.destroy(skip_plan=True, capture_output=True)
        print(stdout)
        print(stderr)
        if not stderr:
            LOGGER.log.info(stdout)
            LOGGER.log.info("Terraform Deletion is Done Successfully!")

    except Exception as e:
        LOGGER.log.error(f"Exception occurred {str(e)}")
        sys.exit(1)

def get_output_file(args):
    """
    Create the output JSON file after the setup creation is successfull 

    Args:
        args : Arguments passed vi the CLI
    
    Returns:
        output_data (list): list of instance and corresponding IP's
    """
    try:        
        tf_output = "sudo terraform output"
        topology_config_path = os.path.join(TESTBED_CONFIG_PATH, args.topo)
        tf = Terraform(working_dir=topology_config_path)
        return_code, stdout, stderr = tf.output_cmd()
        file_path = os.path.join(topology_config_path, "output_file")

        if not stderr:
            LOGGER.log.info(stdout)
            LOGGER.log.info("Terraform output command Done Successfully!")
        else:
            LOGGER.log.error(stderr)
            raise Exception("Terraform Output Command not Done!")
        if not os.path.exists(file_path):
            op_file = open(file_path, "x")
        op_file = open(file_path, "wt+")
        n = op_file.writelines(stdout)
        op_file.close()
        import imp
        output_data = imp.load_source('data', file_path)
    except Exception as e:
        LOGGER.log.error(f"Exception Occured with error: {str(e)}")
        sys.exit(1)
    return (output_data)

def enable_internet_access_on_server(args):
    """
    Enable Internet access on the KVM server to install the applications

    Args:
        args: Arguments passed via CLI

    """
    server = args.server
    username = args.username
    ssh_key_file = args.ssh_key
    management_ip = args.management_ip
    default_int_name = get_interface_name_of_destination(args, "default")
    mgmt_int_name = get_interface_name_of_destination(args, management_ip)
    try:
        LOGGER.log.info("Cleaning up and install the iptables database!")
        _exec_remote_command(hostname=server, username=username, ssh_key_file=ssh_key_file, command='sudo iptables -t nat -F')
        _exec_remote_command(hostname=server, username=username, ssh_key_file=ssh_key_file, command=f'sudo iptables -t nat -A POSTROUTING -o {default_int_name} -j MASQUERADE')
        _exec_remote_command(hostname=server, username=username, ssh_key_file=ssh_key_file, command=f'sudo iptables -t nat -A POSTROUTING -o {mgmt_int_name} -j MASQUERADE')

    except Exception as e:
        LOGGER.log.error(f"Exception occured with Error: {e}")
        sys.exit(1)

def apply_access_on_server(args, data):
    """
    Apply SSH access on the server to access all the instances 

    Args:
        server(str): IP address of the server/hypervisor to apply iptables rules
        data (list): List of instances for which we need to apply iptables rules 
    """
    server = args.server
    username = args.username
    ssh_key_file = args.ssh_key
    management_ip = args.management_ip
    default_int_name = get_interface_name_of_destination(args, "default")
    mgmt_int_name = get_interface_name_of_destination(args, management_ip)

    try:
        client_port = 10011
        for (name, ip_address)  in zip(data.client[0], data.client[1]):
            #IPtables command to enable access for client SSH
            cmd = f'sudo iptables -t nat -A PREROUTING -m comment --comment "{name}-ssh" -i {default_int_name} -p tcp --dport {client_port} -j DNAT --to-destination {ip_address}:22'
            _exec_remote_command(hostname=server, username=username, ssh_key_file=ssh_key_file, command=cmd)
            client_port += 1
        edge_port = 10021
        edge_ui_port = 18021
        for (name, ip_address)  in zip(data.edge[0], data.edge[1]):
            #IPtables command to enable access for edge SSH
            cmd = f'sudo iptables -t nat -A PREROUTING -m comment --comment "{name}" -i {default_int_name} -p tcp --dport {edge_port} -j DNAT --to-destination {ip_address}:22'
            _exec_remote_command(hostname=server, username=username, ssh_key_file=ssh_key_file, command=cmd)
            cmd = f'sudo iptables -t nat -A PREROUTING -m comment --comment "{name}" -i {default_int_name} -p tcp --dport {edge_ui_port} -j DNAT --to-destination {ip_address}:8080'
            _exec_remote_command(hostname=server, username=username, ssh_key_file=ssh_key_file, command=cmd)
            edge_port += 1
            edge_ui_port += 1
        cmd = f'sudo chown {username}:{username} /etc/iptables/rules.v4'
        _exec_remote_command(hostname=server, username=username, ssh_key_file=ssh_key_file, command=cmd)
        cmd = f'sudo iptables-save > /etc/iptables/rules.v4'
        _exec_remote_command(hostname=server, username=username, ssh_key_file=ssh_key_file, command=cmd)
            
    except Exception as e:
        LOGGER.log.error(f"Exception occured with Error: {e}")
        sys.exit(1)

def revoke_access_on_server(args, data):
    """
    Revoke the existing SSH access on the server to access all the instances 

    Args:
        server(str): IP address of the server/hypervisor to apply iptables rules
        data (list): List of instances for which we need to apply iptables rules 
    """
    server = args.server
    username = args.username
    ssh_key_file = args.ssh_key
    management_ip = args.management_ip
    default_int_name = get_interface_name_of_destination(args, "default")
    mgmt_int_name = get_interface_name_of_destination(args, management_ip)

    try:
        client = paramiko.SSHClient()
        client.load_system_host_keys()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        conn = client.connect(hostname=server, username=username, key_filename=ssh_key_file)
        #print(f'sudo iptables -t nat -F')
        cmd = f'sudo iptables -t nat -F POSTROUTING'
        client.exec_command(cmd)
        cmd = f'sudo iptables -t nat -F PREROUTING'
        client.exec_command(cmd)
            
    except Exception as e:
        LOGGER.log.error(f"{e}")
        sys.exit(1)

def get_interface_name_of_destination(args, destination):
    """
    Get the interface name of a specific route 

    Returns:
        inf_name (str): Interface name of specific route 
    """
    server = args.server
    username = args.username
    ssh_key_file = args.ssh_key

    try:
        client = paramiko.SSHClient()
        client.load_system_host_keys()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        cmd = f'ip route show to {destination} | grep -Eo "dev\s*[[:alnum:]-]+" | sed "s/dev\s//g"'
        LOGGER.log.info(f"Executing command {cmd} in server {server} ")
        client.connect(hostname=server, username=username, key_filename=ssh_key_file)
        stdin, stdout, stderr = client.exec_command(cmd)
        inf_name = stdout.readline().strip()
        LOGGER.log.info(f"Got the interface name : {inf_name}")
    except Exception as e:
        LOGGER.log.error(f"Error occurred: {e}")
        sys.exit(1)
    return inf_name

def _exec_shell_command(command, path=None):
    """
    Execute Shell command via subbprocess

    Args:
        command (str): Shell command need to be executed
        path (str): Path on which the command needs to be executed 

    Returns:
        output (bool): True if command executed properly 
    """
    try:
        if not path:
            path = os.getcwd()
        os.chdir(path)
        LOGGER.log.info(f"Changing the directory to {path}")
        LOGGER.log.info(f"Executing Command: {command}")
        list_command = command.split()
        output_tunnel = subprocess.PIPE
        proc = subprocess.Popen(list_command, stdout=output_tunnel, stderr=output_tunnel, cwd=path)
        output, error = proc.communicate(timeout=TIMEOUT)
        LOGGER.log.info(output.decode())

    except Exception as e:
        LOGGER.log.error(f"{error}")
        LOGGER.log.error(f"Command not executed properly due to following error: {str(e)}") 
        proc.kill()
        sys.exit(1)
        
    return True

def prepare_setup_json(args):
    """
    Prepare the setup json file for requested topology 

    Args:
        args : Arguments of CLI 
    """
    try:
        server = args.server
        token = args.token
        access_key = args.access_key
        if not args.flexi_manage:
            LOGGER.log.info("Fleximanage IP Is not provided using default appqa01")
            fleximanage = "https://appqa01.flexiwan.com"
        else:
            LOGGER.log.info(f"Fleximanage IP is {args.flexi_manage}")
            fleximanage = args.flexi_manage
        config_file = os.path.join(TESTBED_CONFIG_PATH, args.topo, 'config', '2-site.json')
        with open(config_file, 'r') as file :
            filedata = file.read()

        # Replace the target string
        filedata = filedata.replace("{server_ip}", f'{server}')
        filedata = filedata.replace("{token}", f'{token}')
        filedata = filedata.replace("{fleximanage}", f'{fleximanage}')
        filedata = filedata.replace("{access_key}", f'{access_key}')
        setup_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))),
                                    "users",
                                    "regression",
                                    )
        # Write the file out again
        if not os.path.exists(setup_path):
            os.mkdir(setup_path)
            LOGGER.log.info(f"Directory {setup_path} created")
        else:
            LOGGER.log.info(f"Directory {setup_path} is already available")
        setup_file = os.path.join(setup_path, "3-site.json")
        with open(setup_file, 'w') as file:
            file.write(filedata)
        LOGGER.log.info(f"Setup file is created successfully and its Location: {setup_file}")
    except Exception as e:
        LOGGER.log.error(f"Got Exception while creating setup json: {str(e)}")
        sys.exit(1)
