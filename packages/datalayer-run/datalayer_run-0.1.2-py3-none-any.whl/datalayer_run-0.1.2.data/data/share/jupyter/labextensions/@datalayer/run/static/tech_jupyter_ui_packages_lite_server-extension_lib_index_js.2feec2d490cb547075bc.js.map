{"version":3,"file":"tech_jupyter_ui_packages_lite_server-extension_lib_index_js.2feec2d490cb547075bc.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACwD;AAC2B;AAC1C;AACe;AACpB;AACe;AACnD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,0BAA0B,8CAAK;AAC/B;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,0BAA0B,sFAAW;AACrC;AACA;AACA;AACA;AACA,0BAA0B,sFAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yDAAU;AACzC;AACA,6BAA6B,oBAAoB,cAAc,SAAS;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,SAAS;AAC7F;AACA;AACA,4BAA4B,oFAAS;AACrC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,6BAA6B,+CAAe;AAC5C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,UAAU;AAC5C;AACA,gBAAgB,qBAAqB;AACrC;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kEAAa;AAChC,mBAAmB,kEAAa;AAChC,yBAAyB,kEAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wEAAqB;AAC/C,CAAC,0BAA0B;;;;;;;;;;;;;;;;;;AC3L3B;AACA;AACA;AACA;AACA;AACmD;AACR;AAC3C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uEAAoB;AACpD;AACA;AACA;AACA;AACA;AACA,oCAAoC,oDAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AAC0C;AAC1C;AACA;AACA;AACO,qBAAqB,oDAAK;AACjC;AACA;AACA;AACO;AACP;AACA;AACA;AACO,yBAAyB,oDAAK;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjBrC;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;AAC0C;AACwB;AAChD;AACC;AAChC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4FAAiC;AAC/C;AACA,mBAAmB,2FAAgC;AACnD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mEAAQ;AACtB,eAAe,uEAAY;AAC3B;AACA,mBAAmB,kEAAO,GAAG,aAAa;AAC1C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mEAAQ;AACvB;AACA,8BAA8B,WAAW;AACzC;AACA;AACA;AACA,SAAS;AACT,gCAAgC,WAAW;AAC3C;AACA;AACA,uDAAuD,aAAa;AACpE,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uEAAY;AAC1B;AACA,mBAAmB,sEAAW;AAC9B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAY;AAC3B;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qEAAS;AACvB,eAAe,mEAAQ;AACvB;AACA,mBAAmB,oEAAQ,GAAG,SAAS;AACvC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qEAAS;AACxB;AACA,8BAA8B,SAAS;AACvC;AACA;AACA,2DAA2D,aAAa;AACxE,SAAS;AACT;AACA;AACA;AACA,wDAAwD,aAAa;AACrE,SAAS;AACT,gCAAgC,SAAS;AACzC;AACA;AACA;AACA,2DAA2D,aAAa;AACxE,SAAS;AACT,iCAAiC,SAAS;AAC1C;AACA;AACA,wCAAwC,aAAa;AACrD,SAAS;AACT;AACA;AACA;AACA;AACA,2DAA2D,aAAa;AACxE,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sEAAS;AACvB;AACA,4BAA4B,uEAAoB;AAChD,0CAA0C,uEAAoB;AAC9D,6BAA6B,sEAAQ,GAAG,wCAAwC,wDAAE;AAClF;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sEAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA,wCAAwC,aAAa;AACrD,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;;;ACzNvB;AACA;AACA;AACA;AACA;AAC2C;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gEAAgE,IAAI;AACpE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qDAAM;AACrC;;;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AAC0C;AAC1C;AACA;AACA;AACO,8CAA8C,oDAAK;;;;;;;;;;;;;;;;;;;;;ACT1D;AACA;AACA;AACA;AACA;AACgD;AACH;AACJ;AACzC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,IAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA,mCAAmC,IAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA,iCAAiC,yDAAU;AAC3C;AACA;AACA;AACA,sBAAsB,kEAAe;AACrC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,IAAI;AACvC;AACA;AACA;AACA;AACA;AACA,QAAQ,qEAAsB;AAC9B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/GA;AACA;AACA;AACA;AACA;AAC0C;AAC1C;AACA;AACA;AACO,sBAAsB,oDAAK;;;;;;;;;;;;;;;;;;;;;ACTlC;AACA;AACA;AACA;AACA;AAC2D;AAC5B;AACqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,0BAA0B,8DAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS,IAAI;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uEAAoB;AAChD;AACA,wCAAwC,8DAAW;AACnD;AACA,oBAAoB,KAAK;AACzB;AACA;AACA;AACA;AACA,0BAA0B,wCAAW;AACrC;AACA,SAAS;AACT,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uEAAoB;AACrD,0BAA0B,8DAAW,2DAA2D,WAAW;AAC3G,2BAA2B,8DAAW;AACtC;AACA;AACA,yEAAyE;AACzE,yBAAyB,wCAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uEAAoB,4BAA4B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uEAAoB;AACvD;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;;;;;;;;;;;;;;;;AC7L3B;AACA;AACA;AACA;AACA;AAC0C;AAC1C;AACA;AACA;AACO,sBAAsB,oDAAK","sources":["webpack://@datalayer/run/../../tech/jupyter/ui/packages/lite/kernel/lib/kernels.js","webpack://@datalayer/run/../../tech/jupyter/ui/packages/lite/kernel/lib/kernelspecs.js","webpack://@datalayer/run/../../tech/jupyter/ui/packages/lite/kernel/lib/tokens.js","webpack://@datalayer/run/../../tech/jupyter/ui/packages/lite/server-extension/lib/index.js","webpack://@datalayer/run/../../tech/jupyter/ui/packages/lite/server/lib/serviceworker.js","webpack://@datalayer/run/../../tech/jupyter/ui/packages/lite/server/lib/tokens.js","webpack://@datalayer/run/../../tech/jupyter/ui/packages/lite/session/lib/sessions.js","webpack://@datalayer/run/../../tech/jupyter/ui/packages/lite/session/lib/tokens.js","webpack://@datalayer/run/../../tech/jupyter/ui/packages/lite/settings/lib/settings.js","webpack://@datalayer/run/../../tech/jupyter/ui/packages/lite/settings/lib/tokens.js"],"sourcesContent":["/*\n * Copyright (c) 2022-2023 Datalayer Inc. All rights reserved.\n *\n * MIT License\n */\nimport { ObservableMap } from '@jupyterlab/observables';\nimport { deserialize, serialize } from '@jupyterlab/services/lib/kernel/serialize';\nimport { UUID } from '@lumino/coreutils';\nimport { Server as WebSocketServer } from 'mock-socket';\nimport { Mutex } from 'async-mutex';\nimport { PageConfig } from '@jupyterlab/coreutils';\n/**\n * A class to handle requests to /api/kernels\n */\nexport class Kernels {\n    /**\n     * Construct a new Kernels\n     *\n     * @param options The instantiation options\n     */\n    constructor(options) {\n        const { kernelspecs } = options;\n        this._kernelspecs = kernelspecs;\n    }\n    /**\n     * Start a new kernel.\n     *\n     * @param options The kernel start options.\n     */\n    async startNew(options) {\n        const { id, name, location } = options;\n        const factory = this._kernelspecs.factories.get(name);\n        // bail if there is no factory associated with the requested kernel\n        if (!factory) {\n            return { id, name };\n        }\n        // create a synchronization mechanism to allow only one message\n        // to be processed at a time\n        const mutex = new Mutex();\n        // hook a new client to a kernel\n        const hook = (kernelId, clientId, socket) => {\n            const kernel = this._kernels.get(kernelId);\n            if (!kernel) {\n                throw Error(`No kernel ${kernelId}`);\n            }\n            this._clients.set(clientId, socket);\n            this._kernelClients.get(kernelId)?.add(clientId);\n            const processMsg = async (msg) => {\n                await mutex.runExclusive(async () => {\n                    await kernel.handleMessage(msg);\n                });\n            };\n            socket.on('message', async (message) => {\n                let msg;\n                if (message instanceof ArrayBuffer) {\n                    message = new Uint8Array(message).buffer;\n                    msg = deserialize(message, 'v1.kernel.websocket.jupyter.org');\n                }\n                else if (typeof message === 'string') {\n                    const enc = new TextEncoder();\n                    const mb = enc.encode(message);\n                    msg = deserialize(mb, 'v1.kernel.websocket.jupyter.org');\n                }\n                else {\n                    return;\n                }\n                // TODO Find a better solution for this?\n                // input-reply is asynchronous, must not be processed like other messages\n                if (msg.header.msg_type === 'input_reply') {\n                    kernel.handleMessage(msg);\n                }\n                else {\n                    void processMsg(msg);\n                }\n            });\n            const removeClient = () => {\n                this._clients.delete(clientId);\n                this._kernelClients.get(kernelId)?.delete(clientId);\n            };\n            kernel.disposed.connect(removeClient);\n            // TODO: check whether this is called\n            // https://github.com/thoov/mock-socket/issues/298\n            // https://github.com/jupyterlab/jupyterlab/blob/6bc884a7a8ed73c615ce72ba097bdb790482b5bf/packages/services/src/kernel/default.ts#L1245\n            socket.onclose = removeClient;\n        };\n        // ensure kernel id\n        const kernelId = id ?? UUID.uuid4();\n        // There is one server per kernel which handles multiple clients\n        const kernelUrl = `${Kernels.WS_BASE_URL}api/kernels/${kernelId}/channels`;\n        const runningKernel = this._kernels.get(kernelId);\n        if (runningKernel) {\n            return {\n                id: runningKernel.id,\n                name: runningKernel.name,\n            };\n        }\n        // start the kernel\n        const sendMessage = (msg) => {\n            const clientId = msg.header.session;\n            const socket = this._clients.get(clientId);\n            if (!socket) {\n                console.warn(`Trying to send message on removed socket for kernel ${kernelId}`);\n                return;\n            }\n            const message = serialize(msg, 'v1.kernel.websocket.jupyter.org');\n            // process iopub messages\n            if (msg.channel === 'iopub') {\n                const clients = this._kernelClients.get(kernelId);\n                clients?.forEach((id) => {\n                    this._clients.get(id)?.send(message);\n                });\n                return;\n            }\n            socket.send(message);\n        };\n        const kernel = await factory({\n            id: kernelId,\n            sendMessage,\n            name,\n            location,\n        });\n        await kernel.ready;\n        this._kernels.set(kernelId, kernel);\n        this._kernelClients.set(kernelId, new Set());\n        // create the websocket server for the kernel\n        const wsServer = new WebSocketServer(kernelUrl);\n        wsServer.on('connection', (socket) => {\n            const url = new URL(socket.url);\n            const clientId = url.searchParams.get('session_id') ?? '';\n            hook(kernelId, clientId, socket);\n        });\n        // clean up closed connection\n        wsServer.on('close', () => {\n            this._clients.keys().forEach((clientId) => {\n                const socket = this._clients.get(clientId);\n                if (socket?.readyState === WebSocket.CLOSED) {\n                    this._clients.delete(clientId);\n                    this._kernelClients.get(kernelId)?.delete(clientId);\n                }\n            });\n        });\n        // cleanup on kernel shutdown\n        kernel.disposed.connect(() => {\n            wsServer.close();\n            this._kernels.delete(kernelId);\n            this._kernelClients.delete(kernelId);\n        });\n        return {\n            id: kernel.id,\n            name: kernel.name,\n        };\n    }\n    /**\n     * Restart a kernel.\n     *\n     * @param kernelId The kernel id.\n     */\n    async restart(kernelId) {\n        const kernel = this._kernels.get(kernelId);\n        if (!kernel) {\n            throw Error(`Kernel ${kernelId} does not exist`);\n        }\n        const { id, name, location } = kernel;\n        kernel.dispose();\n        return this.startNew({ id, name, location });\n    }\n    /**\n     * Shut down a kernel.\n     *\n     * @param id The kernel id.\n     */\n    async shutdown(id) {\n        this._kernels.delete(id)?.dispose();\n    }\n    _kernels = new ObservableMap();\n    _clients = new ObservableMap();\n    _kernelClients = new ObservableMap();\n    _kernelspecs;\n}\n/**\n * A namespace for Kernels statics.\n */\n(function (Kernels) {\n    /**\n     * The base url for the Kernels manager\n     */\n    Kernels.WS_BASE_URL = PageConfig.getBaseUrl().replace(/^http/, 'ws');\n})(Kernels || (Kernels = {}));\n","/*\n * Copyright (c) 2022-2023 Datalayer Inc. All rights reserved.\n *\n * MIT License\n */\nimport { PageConfig } from '@jupyterlab/coreutils';\nimport { FALLBACK_KERNEL } from './tokens';\n/**\n * A class to handle requests to /api/kernelspecs\n */\nexport class KernelSpecs {\n    /**\n     * Get the kernel specs.\n     */\n    get specs() {\n        if (this._specs.size === 0) {\n            return null;\n        }\n        return {\n            default: this.defaultKernelName,\n            kernelspecs: Object.fromEntries(this._specs),\n        };\n    }\n    /**\n     * Get the default kernel name.\n     */\n    get defaultKernelName() {\n        let defaultKernelName = PageConfig.getOption('defaultKernelName');\n        if (!defaultKernelName && this._specs.size) {\n            const keys = Array.from(this._specs.keys());\n            keys.sort();\n            defaultKernelName = keys[0];\n        }\n        return defaultKernelName || FALLBACK_KERNEL;\n    }\n    /**\n     * Get the kernel factories for the current kernels.\n     */\n    get factories() {\n        return this._factories;\n    }\n    /**\n     * Register a new kernel.\n     *\n     * @param options The options to register a new kernel.\n     */\n    register(options) {\n        const { spec, create } = options;\n        this._specs.set(spec.name, spec);\n        this._factories.set(spec.name, create);\n    }\n    _specs = new Map();\n    _factories = new Map();\n}\n","/*\n * Copyright (c) 2022-2023 Datalayer Inc. All rights reserved.\n *\n * MIT License\n */\nimport { Token } from '@lumino/coreutils';\n/**\n * The token for the kernels service.\n */\nexport const IKernels = new Token('@datalayer/jupyterlite-kernel:IKernels');\n/**\n * The kernel name of last resort.\n */\nexport const FALLBACK_KERNEL = 'javascript';\n/**\n * The token for the kernel spec service.\n */\nexport const IKernelSpecs = new Token('@datalayer/jupyterlite-kernel:IKernelSpecs');\n","/*\n * Copyright (c) 2022-2023 Datalayer Inc. All rights reserved.\n *\n * MIT License\n */\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { PageConfig } from '@jupyterlab/coreutils';\nimport { IKernels, Kernels, IKernelSpecs, KernelSpecs } from '@datalayer/jupyterlite-kernel';\nimport { IServiceWorkerRegistrationWrapper, ServiceWorkerRegistrationWrapper, } from '@datalayer/jupyterlite-server';\nimport { ISessions, Sessions } from '@datalayer/jupyterlite-session';\nimport { ISettings, Settings } from '@datalayer/jupyterlite-settings';\nimport localforage from 'localforage';\n/**\n * A plugin installing the service worker.\n */\nconst serviceWorkerPlugin = {\n    id: '@datalayer/jupyterlite-server-extension:service-worker',\n    autoStart: true,\n    provides: IServiceWorkerRegistrationWrapper,\n    activate: (app) => {\n        return new ServiceWorkerRegistrationWrapper();\n    },\n};\n/**\n * The kernels service plugin.\n */\nconst kernelsPlugin = {\n    id: '@datalayer/jupyterlite-server-extension:kernels',\n    autoStart: true,\n    provides: IKernels,\n    requires: [IKernelSpecs],\n    activate: (app, kernelspecs) => {\n        return new Kernels({ kernelspecs });\n    },\n};\n/**\n * A plugin providing the routes for the kernels service\n */\nconst kernelsRoutesPlugin = {\n    id: '@datalayer/jupyterlite-server-extension:kernels-routes',\n    autoStart: true,\n    requires: [IKernels],\n    activate: (app, kernels) => {\n        // POST /api/kernels/{kernel_id} - Restart a kernel\n        app.router.post('/api/kernels/(.*)/restart', async (req, kernelId) => {\n            const res = await kernels.restart(kernelId);\n            return new Response(JSON.stringify(res));\n        });\n        // DELETE /api/kernels/{kernel_id} - Kill a kernel and delete the kernel id\n        app.router.delete('/api/kernels/(.*)', async (req, kernelId) => {\n            const res = await kernels.shutdown(kernelId);\n            return new Response(JSON.stringify(res), { status: 204 });\n        });\n    },\n};\n/**\n * The kernel spec service plugin.\n */\nconst kernelSpecPlugin = {\n    id: '@datalayer/jupyterlite-server-extension:kernelspec',\n    autoStart: true,\n    provides: IKernelSpecs,\n    activate: (app) => {\n        return new KernelSpecs();\n    },\n};\n/**\n * A plugin providing the routes for the kernelspec service.\n */\nconst kernelSpecRoutesPlugin = {\n    id: '@datalayer/jupyterlite-server-extension:kernelspec-routes',\n    autoStart: true,\n    requires: [IKernelSpecs],\n    activate: (app, kernelspecs) => {\n        app.router.get('/api/kernelspecs', async (req) => {\n            const { specs } = kernelspecs;\n            if (!specs) {\n                return new Response(null);\n            }\n            // follow the same format as in Jupyter Server\n            const allKernelSpecs = {};\n            const allSpecs = specs.kernelspecs;\n            Object.keys(allSpecs).forEach((name) => {\n                const spec = allSpecs[name];\n                const { resources } = spec ?? {};\n                allKernelSpecs[name] = {\n                    name,\n                    spec,\n                    resources,\n                };\n            });\n            const res = {\n                default: specs.default,\n                kernelspecs: allKernelSpecs,\n            };\n            return new Response(JSON.stringify(res));\n        });\n    },\n};\n/**\n * A plugin providing the routes for the nbconvert service.\n * TODO: provide the service in a separate plugin?\n */\nconst nbconvertRoutesPlugin = {\n    id: '@datalayer/jupyterlite-server-extension:nbconvert-routes',\n    autoStart: true,\n    activate: (app) => {\n        app.router.get('/api/nbconvert', async (req) => {\n            return new Response(JSON.stringify({}));\n        });\n    },\n};\n/**\n * The sessions service plugin.\n */\nconst sessionsPlugin = {\n    id: '@datalayer/jupyterlite-server-extension:sessions',\n    autoStart: true,\n    provides: ISessions,\n    requires: [IKernels],\n    activate: (app, kernels) => {\n        return new Sessions({ kernels });\n    },\n};\n/**\n * A plugin providing the routes for the session service.\n */\nconst sessionsRoutesPlugin = {\n    id: '@datalayer/jupyterlite-server-extension:sessions-routes',\n    autoStart: true,\n    requires: [ISessions],\n    activate: (app, sessions) => {\n        // GET /api/sessions/{session} - Get session\n        app.router.get('/api/sessions/(.+)', async (req, id) => {\n            const session = await sessions.get(id);\n            return new Response(JSON.stringify(session), { status: 200 });\n        });\n        // GET /api/sessions - List available sessions\n        app.router.get('/api/sessions', async (req) => {\n            const list = await sessions.list();\n            return new Response(JSON.stringify(list), { status: 200 });\n        });\n        // PATCH /api/sessions/{session} - This can be used to rename a session\n        app.router.patch('/api/sessions(.*)', async (req, id) => {\n            const options = req.body;\n            const session = await sessions.patch(options);\n            return new Response(JSON.stringify(session), { status: 200 });\n        });\n        // DELETE /api/sessions/{session} - Delete a session\n        app.router.delete('/api/sessions/(.+)', async (req, id) => {\n            await sessions.shutdown(id);\n            return new Response(null, { status: 204 });\n        });\n        // POST /api/sessions - Create a new session or return an existing session if a session of the same name already exists\n        app.router.post('/api/sessions', async (req) => {\n            const options = req.body;\n            const session = await sessions.startNew(options);\n            return new Response(JSON.stringify(session), { status: 201 });\n        });\n    },\n};\n/**\n * The settings service plugin.\n */\nconst settingsPlugin = {\n    id: '@datalayer/jupyterlite-server-extension:settings',\n    autoStart: true,\n    requires: [],\n    provides: ISettings,\n    activate: (app) => {\n        const storageName = PageConfig.getOption('settingsStorageName');\n        const storageDrivers = JSON.parse(PageConfig.getOption('settingsStorageDrivers') || 'null');\n        const settings = new Settings({ storageName, storageDrivers, localforage });\n        app.started.then(() => settings.initialize().catch(console.warn));\n        return settings;\n    },\n};\n/**\n * A plugin providing the routes for the settings service.\n */\nconst settingsRoutesPlugin = {\n    id: '@datalayer/jupyterlite-server-extension:settings-routes',\n    autoStart: true,\n    requires: [ISettings],\n    activate: (app, settings) => {\n        // TODO: improve the regex\n        // const pluginPattern = new RegExp(/(?:@([^/]+?)[/])?([^/]+?):(\\w+)/);\n        const pluginPattern = '/api/settings/((?:@([^/]+?)[/])?([^/]+?):([^:]+))$';\n        app.router.get(pluginPattern, async (req, pluginId) => {\n            const setting = await settings.get(pluginId);\n            return new Response(JSON.stringify(setting));\n        });\n        app.router.put(pluginPattern, async (req, pluginId) => {\n            const body = req.body;\n            const { raw } = body;\n            await settings.save(pluginId, raw);\n            return new Response(null, { status: 204 });\n        });\n        app.router.get('/api/settings', async (req) => {\n            const plugins = await settings.getAll();\n            return new Response(JSON.stringify(plugins));\n        });\n    },\n};\nconst plugins = [\n    kernelsPlugin,\n    kernelsRoutesPlugin,\n    kernelSpecPlugin,\n    kernelSpecRoutesPlugin,\n    nbconvertRoutesPlugin,\n    serviceWorkerPlugin,\n    sessionsPlugin,\n    sessionsRoutesPlugin,\n    settingsPlugin,\n    settingsRoutesPlugin,\n];\nexport default plugins;\n","/*\n * Copyright (c) 2022-2023 Datalayer Inc. All rights reserved.\n *\n * MIT License\n */\nimport { Signal } from '@lumino/signaling';\nexport class ServiceWorkerRegistrationWrapper {\n    constructor() {\n        this.initialize();\n    }\n    /**\n     * A signal emitted when the registration changes.\n     */\n    get registrationChanged() {\n        return this._registrationChanged;\n    }\n    /**\n     * Whether the ServiceWorker is enabled or not.\n     */\n    get enabled() {\n        return this._registration !== null;\n    }\n    async initialize() {\n        if (!('serviceWorker' in navigator)) {\n            console.error('ServiceWorker registration failed: Service Workers not supported in this browser');\n            this.setRegistration(null);\n        }\n        if (navigator.serviceWorker.controller) {\n            const registration = await navigator.serviceWorker.getRegistration(navigator.serviceWorker.controller.scriptURL);\n            if (registration) {\n                this.setRegistration(registration);\n            }\n        }\n        return await navigator.serviceWorker\n            //      .register(URLExt.join(PageConfig.getBaseUrl(), 'services.js'))\n            .register(\"/services.js\")\n            .then((registration) => {\n            this.setRegistration(registration);\n        }, (err) => {\n            console.error(`ServiceWorker registration failed: ${err}`);\n            this.setRegistration(null);\n        });\n    }\n    setRegistration(registration) {\n        this._registration = registration;\n        this._registrationChanged.emit(this._registration);\n    }\n    _registration = null;\n    _registrationChanged = new Signal(this);\n}\n","/*\n * Copyright (c) 2022-2023 Datalayer Inc. All rights reserved.\n *\n * MIT License\n */\nimport { Token } from '@lumino/coreutils';\n/**\n * The token for the ServiceWorker.\n */\nexport const IServiceWorkerRegistrationWrapper = new Token('@datalayer/jupyterlite-server-extension:IServiceWorkerRegistrationWrapper');\n","/*\n * Copyright (c) 2022-2023 Datalayer Inc. All rights reserved.\n *\n * MIT License\n */\nimport { PathExt } from '@jupyterlab/coreutils';\nimport { ArrayExt } from '@lumino/algorithm';\nimport { UUID } from '@lumino/coreutils';\n/**\n * A class to handle requests to /api/sessions\n */\nexport class Sessions {\n    /**\n     * Construct a new Sessions.\n     *\n     * @param options The instantiation options for a Sessions.\n     */\n    constructor(options) {\n        this._kernels = options.kernels;\n    }\n    /**\n     * Get a session by id.\n     *\n     * @param id The id of the session.\n     */\n    async get(id) {\n        const session = this._sessions.find((s) => s.id === id);\n        if (!session) {\n            throw Error(`Session ${id} not found`);\n        }\n        return session;\n    }\n    /**\n     * List the running sessions\n     */\n    async list() {\n        return this._sessions;\n    }\n    /**\n     * Path an existing session.\n     * This can be used to rename a session.\n     * TODO: read path and name\n     *\n     * @param options The options to patch the session.\n     */\n    async patch(options) {\n        const { id, path, name } = options;\n        const index = this._sessions.findIndex((s) => s.id === id);\n        const session = this._sessions[index];\n        if (!session) {\n            throw Error(`Session ${id} not found`);\n        }\n        const patched = {\n            ...session,\n            path: path ?? session.path,\n            name: name ?? session.name,\n        };\n        this._sessions[index] = patched;\n        return patched;\n    }\n    /**\n     * Start a new session\n     * TODO: read path and name\n     *\n     * @param options The options to start a new session.\n     */\n    async startNew(options) {\n        const { path, name } = options;\n        const running = this._sessions.find((s) => s.name === name);\n        if (running) {\n            return running;\n        }\n        const kernelName = options.kernel?.name ?? '';\n        const id = options.id ?? UUID.uuid4();\n        const kernel = await this._kernels.startNew({\n            id,\n            name: kernelName,\n            location: PathExt.dirname(options.path),\n        });\n        const session = {\n            id,\n            path,\n            name: name ?? path,\n            type: 'notebook',\n            kernel: {\n                id: kernel.id,\n                name: kernel.name,\n            },\n        };\n        this._sessions.push(session);\n        return session;\n    }\n    /**\n     * Shut down a session.\n     *\n     * @param id The id of the session to shut down.\n     */\n    async shutdown(id) {\n        const session = this._sessions.find((s) => s.id === id);\n        if (!session) {\n            throw Error(`Session ${id} not found`);\n        }\n        const kernelId = session.kernel?.id;\n        if (kernelId) {\n            await this._kernels.shutdown(kernelId);\n        }\n        ArrayExt.removeFirstOf(this._sessions, session);\n    }\n    _kernels;\n    // TODO: offload to a database\n    _sessions = [];\n}\n","/*\n * Copyright (c) 2022-2023 Datalayer Inc. All rights reserved.\n *\n * MIT License\n */\nimport { Token } from '@lumino/coreutils';\n/**\n * The token for the sessions service.\n */\nexport const ISessions = new Token('@datalayer/jupyterlite-session:ISessions');\n","/*\n * Copyright (c) 2022-2023 Datalayer Inc. All rights reserved.\n *\n * MIT License\n */\nimport { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport * as json5 from 'json5';\nimport { PromiseDelegate } from '@lumino/coreutils';\n/**\n * The name of the local storage.\n */\nconst DEFAULT_STORAGE_NAME = 'JupyterLite Storage';\n/**\n * A class to handle requests to /api/settings\n */\nexport class Settings {\n    constructor(options) {\n        this._localforage = options.localforage;\n        this._storageName = options.storageName || DEFAULT_STORAGE_NAME;\n        this._storageDrivers = options.storageDrivers || null;\n        this._ready = new PromiseDelegate();\n    }\n    /**\n     * A promise that resolves when the settings storage is fully initialized\n     */\n    get ready() {\n        return this._ready.promise;\n    }\n    /**\n     * A lazy reference to initialized storage\n     */\n    get storage() {\n        return this.ready.then(() => this._storage);\n    }\n    /**\n     * Finish any initialization after server has started and all extensions are applied.\n     */\n    async initialize() {\n        await this.initStorage();\n        this._ready.resolve(void 0);\n    }\n    /**\n     * Prepare the storage\n     */\n    async initStorage() {\n        this._storage = this.defaultSettingsStorage();\n    }\n    /**\n     * Get default options for localForage instances\n     */\n    get defaultStorageOptions() {\n        const driver = this._storageDrivers?.length ? this._storageDrivers : null;\n        return {\n            version: 1,\n            name: this._storageName,\n            ...(driver ? { driver } : {}),\n        };\n    }\n    /**\n     * Create a settings store.\n     */\n    defaultSettingsStorage() {\n        return this._localforage.createInstance({\n            description: 'Offline Storage for Settings',\n            storeName: 'settings',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Get settings by plugin id\n     *\n     * @param pluginId the id of the plugin\n     *\n     */\n    async get(pluginId) {\n        const all = await this.getAll();\n        const settings = all.settings;\n        let found = settings.find((setting) => {\n            return setting.id === pluginId;\n        });\n        if (!found) {\n            found = await this._getFederated(pluginId);\n        }\n        return found;\n    }\n    /**\n     * Get all the settings\n     */\n    async getAll() {\n        const settingsUrl = PageConfig.getOption('settingsUrl') ?? '/';\n        const storage = await this.storage;\n        const all = (await (await fetch(URLExt.join(settingsUrl, 'all.json'))).json());\n        const settings = await Promise.all(all.map(async (plugin) => {\n            const { id } = plugin;\n            const raw = (await storage.getItem(id)) ?? plugin.raw;\n            return {\n                ...Private.override(plugin),\n                raw,\n                settings: json5.parse(raw),\n            };\n        }));\n        return { settings };\n    }\n    /**\n     * Save settings for a given plugin id\n     *\n     * @param pluginId The id of the plugin\n     * @param raw The raw settings\n     *\n     */\n    async save(pluginId, raw) {\n        await (await this.storage).setItem(pluginId, raw);\n    }\n    /**\n     * Get the settings for a federated extension\n     *\n     * @param pluginId The id of a plugin\n     */\n    async _getFederated(pluginId) {\n        const [packageName, schemaName] = pluginId.split(':');\n        if (!Private.isFederated(packageName)) {\n            return;\n        }\n        const labExtensionsUrl = PageConfig.getOption('fullLabextensionsUrl');\n        const schemaUrl = URLExt.join(labExtensionsUrl, packageName, 'schemas', packageName, `${schemaName}.json`);\n        const packageUrl = URLExt.join(labExtensionsUrl, packageName, 'package.json');\n        const schema = await (await fetch(schemaUrl)).json();\n        const packageJson = await (await fetch(packageUrl)).json();\n        const raw = (await (await this.storage).getItem(pluginId)) ?? '{}';\n        const settings = json5.parse(raw) || {};\n        return Private.override({\n            id: pluginId,\n            raw,\n            schema,\n            settings,\n            version: packageJson.version || '3.0.8',\n        });\n    }\n    _storageName = DEFAULT_STORAGE_NAME;\n    _storageDrivers = null;\n    _storage;\n    _localforage;\n    _ready;\n}\n/**\n * A namespace for private data\n */\nvar Private;\n(function (Private) {\n    const _overrides = JSON.parse(PageConfig.getOption('settingsOverrides') || '{}');\n    /**\n     * Test whether this package is configured in `federated_extensions` in this app\n     *\n     * @param packageName The npm name of a package\n     */\n    function isFederated(packageName) {\n        let federated;\n        try {\n            federated = JSON.parse(PageConfig.getOption('federated_extensions'));\n        }\n        catch {\n            return false;\n        }\n        for (const { name } of federated) {\n            if (name === packageName) {\n                return true;\n            }\n        }\n        return false;\n    }\n    Private.isFederated = isFederated;\n    /**\n     * Override the defaults of the schema with ones from PageConfig\n     *\n     * @see https://github.com/jupyterlab/jupyterlab_server/blob/v2.5.2/jupyterlab_server/settings_handler.py#L216-L227\n     */\n    function override(plugin) {\n        if (_overrides[plugin.id]) {\n            if (!plugin.schema.properties) {\n                // probably malformed, or only provides keyboard shortcuts, etc.\n                plugin.schema.properties = {};\n            }\n            for (const [prop, propDefault] of Object.entries(_overrides[plugin.id] || {})) {\n                plugin.schema.properties[prop].default = propDefault;\n            }\n        }\n        return plugin;\n    }\n    Private.override = override;\n})(Private || (Private = {}));\n","/*\n * Copyright (c) 2022-2023 Datalayer Inc. All rights reserved.\n *\n * MIT License\n */\nimport { Token } from '@lumino/coreutils';\n/**\n * The token for the settings service.\n */\nexport const ISettings = new Token('@datalayer/jupyterlite-settings:ISettings');\n"],"names":[],"sourceRoot":""}