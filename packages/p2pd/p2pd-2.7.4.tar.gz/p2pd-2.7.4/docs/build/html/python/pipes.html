<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pipes &mdash; P2PD 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Queues" href="queues.html" />
    <link rel="prev" title="Basics" href="basics.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            P2PD
          </a>
              <div class="version">
                0.1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../problems.html">The problem with P2P networking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../how.html">How P2PD works</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Using P2PD from Python</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="basics.html">Basics</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Pipes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tcp-echo-server-example">TCP echo server example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#udp-await-example">UDP await example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pipe-methods">Pipe methods</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#def-subscribe-self-sub-sub-all-handler-none">def subscribe(self, sub=SUB_ALL, handler=None)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#def-unsubscribe-self-sub">def unsubscribe(self, sub)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#async-def-recv-self-sub-sub-all-timeout-2-full-false">async def recv(self, sub=SUB_ALL, timeout=2, full=False)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#async-def-send-self-data-dest-tup-none">async def send(self, data, dest_tup=None)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#def-add-msg-cb-self-msg-cb">def add_msg_cb(self, msg_cb)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#def-del-msg-cb-self-msg-cb">def del_msg_cb(self, msg_cb)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#def-add-end-cb-self-end-cb">def add_end_cb(self, end_cb)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#def-del-end-cb-self-end-cb">def del_end_cb(self, end_cb)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#def-add-pipe-self-pipe">def add_pipe(self, pipe)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#def-del-pipe-self-pipe">def del_pipe(self, pipe)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#async-def-close-self">async def close(self)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#additional-pipe-options">Additional pipe options</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="queues.html">Queues</a></li>
<li class="toctree-l2"><a class="reference internal" href="daemons.html">Daemons</a></li>
<li class="toctree-l2"><a class="reference internal" href="p2p.html">Peer-to-peer connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples.html">Examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../rest_api.html">The P2PD REST API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../built/index.html">Awesome stuff built with P2PD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../future_work.html">Future work</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">P2PD</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Using P2PD from Python</a></li>
      <li class="breadcrumb-item active">Pipes</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/python/pipes.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="pipes">
<h1>Pipes<a class="headerlink" href="#pipes" title="Permalink to this heading"></a></h1>
<p>In P2PD all data messages are sent and received via pipes. Pipes are simply the
name given to the object providing a common list of functions for transmission
and message processing. A pipe supports UDP or TCP and IPv4 or IPv6.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span> <span class="nf">pipe_open</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="n">route</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sock</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">msg_cb</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">conf</span><span class="o">=</span><span class="n">NET_CONF</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    proto = TCP or UDP.</span>
<span class="sd">    route = Route object that&#39;s been bound with await route.bind().</span>
<span class="sd">    dest  = If it&#39;s a client pipe a destionation should be included.</span>
<span class="sd">                await Address(&#39;host/ip&#39;, port, route).res()</span>
<span class="sd">            A server includes no destination.</span>
<span class="sd">    sock  = Used to wrap a pre-existing socket in a pipe. If the protocol is</span>
<span class="sd">            TCP and dest is included the socket is assumed to be connected.</span>
<span class="sd">    cb    = A message handler registered with servers before they&#39;re started</span>
<span class="sd">            so that messages aren&#39;t received before a handler is setup.</span>
<span class="sd">    conf  = A dictionary describing many different configuration options for</span>
<span class="sd">            changing various properties of the pipe.</span>

<span class="sd">    More details on msg_cb format and conf format later.</span>

<span class="sd">    Returns: a pipe object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Whether a pipe is for a client or server, UDP or TCP, IPv4 or IPv6, every
pipe works the same. Pipes have been designed to process messages as
they arrive. They pass these messages to any registered
handlers (to process in real-time) or message queues (to be processed later).</p>
<section id="tcp-echo-server-example">
<h2>TCP echo server example<a class="headerlink" href="#tcp-echo-server-example" title="Permalink to this heading"></a></h2>
<p>Starts a simple TCP server that writes back received data down the client
pipes for the sender. If this example works you should see nothing.
Notice that msg handlers include a field for the senders addressing information
and a pipe that can be used to interact with that client.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">p2pd</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">msg_cb</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">client_tup</span><span class="p">,</span> <span class="n">pipe</span><span class="p">):</span>
    <span class="k">await</span> <span class="n">pipe</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">client_tup</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">example</span><span class="p">():</span>
    <span class="c1">#</span>
    <span class="c1"># Start default interface and get the first route.</span>
    <span class="c1"># No AF for route use i.supported()[0] </span>
    <span class="n">i</span> <span class="o">=</span> <span class="k">await</span> <span class="n">Interface</span><span class="p">()</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">route</span> <span class="o">=</span> <span class="k">await</span> <span class="n">i</span><span class="o">.</span><span class="n">route</span><span class="p">()</span><span class="o">.</span><span class="n">bind</span><span class="p">()</span> <span class="c1"># Port 0 = any unused port.</span>
    <span class="c1">#</span>
    <span class="c1"># Start the server and use msg_cb to process messages.</span>
    <span class="n">server</span> <span class="o">=</span> <span class="k">await</span> <span class="n">pipe_open</span><span class="p">(</span><span class="n">TCP</span><span class="p">,</span> <span class="n">route</span><span class="p">,</span> <span class="n">msg_cb</span><span class="o">=</span><span class="n">msg_cb</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="c1"># Connect to the server.</span>
    <span class="c1"># Use the IP of the route and unused port for the destination.</span>
    <span class="n">dest</span> <span class="o">=</span> <span class="k">await</span> <span class="n">Address</span><span class="p">(</span><span class="o">*</span><span class="n">server</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">getsockname</span><span class="p">()[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">route</span><span class="p">)</span><span class="o">.</span><span class="n">res</span><span class="p">()</span>
    <span class="n">client</span> <span class="o">=</span> <span class="k">await</span> <span class="n">pipe_open</span><span class="p">(</span><span class="n">TCP</span><span class="p">,</span> <span class="n">route</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="c1"># Send data to the server and check receipt.</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;test msg.&quot;</span>
    <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">msg</span> <span class="o">==</span> <span class="n">out</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="c1"># Close both.</span>
    <span class="k">await</span> <span class="n">client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">await</span> <span class="n">server</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="c1"># From inside the async REPL.</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">async_test</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="udp-await-example">
<h2>UDP await example<a class="headerlink" href="#udp-await-example" title="Permalink to this heading"></a></h2>
<p>In Python if you want to do asynchronous programming you’re likely going to be writing different code for TCP and UDP. This is because TCP is ‘stream-based’ and UDP
is ‘packet-based.’ TCP streams are reliable and ordered. UDP communication is not.
So in Python for TCP connections you will be dealing with ‘streams’ while for
UDP you will use protocol classes.</p>
<p>Only stream readers are ‘asynchronous’ e.g. you can await ‘draining’ a writer
or await a reader - while there is no such equivalent for UDP. It’s all very
<strong>inconvenient</strong>. Wouldn’t it be great if you could use asynchronous awaits
for UDP and TCP? Further: wouldn’t it be great if you modelled interactions in
such a way that the same code would work for both?</p>
<p>Here’s an example of how simple P2PD makes this. Here I’m using await for UDP
which is based on message queues. Since there is no delivery guarantees for UDP it’s
possible this example throws a timeout error for you. Real-world code that deals
with TCP usually has retransmissions built-in after a set duration. But no such
logic here has been included. Note that the await for the recv is fully
asynchronous. The event loop is free to run other tasks until a match occurs.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">binascii</span>
<span class="kn">from</span> <span class="nn">p2pd</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">example</span><span class="p">():</span>
    <span class="c1"># Open default interface.</span>
    <span class="c1"># Get a route for the first AF supported.</span>
    <span class="n">i</span> <span class="o">=</span> <span class="k">await</span> <span class="n">Interface</span><span class="p">()</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">route</span> <span class="o">=</span> <span class="k">await</span> <span class="n">i</span><span class="o">.</span><span class="n">route</span><span class="p">()</span><span class="o">.</span><span class="n">bind</span><span class="p">()</span>
    <span class="c1">#</span>
    <span class="c1"># Open a UDP pipe to stunprotocol.org.</span>
    <span class="c1"># Subscribe to all messages.</span>
    <span class="n">pipe</span> <span class="o">=</span> <span class="k">await</span> <span class="n">pipe_open</span><span class="p">(</span>
        <span class="n">UDP</span><span class="p">,</span>
        <span class="n">route</span><span class="p">,</span>
        <span class="k">await</span> <span class="n">Address</span><span class="p">(</span><span class="s2">&quot;stunserver.stunprotocol.org&quot;</span><span class="p">,</span> <span class="mi">3478</span><span class="p">,</span> <span class="n">route</span><span class="p">)</span><span class="o">.</span><span class="n">res</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="c1">#</span>
    <span class="c1"># Build a STUN request and send it.</span>
    <span class="n">msg_id</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">99</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">)])</span>
    <span class="n">req_hex</span> <span class="o">=</span> <span class="s2">&quot;00010000&quot;</span> <span class="o">+</span> <span class="n">msg_id</span>
    <span class="n">req_buf</span> <span class="o">=</span> <span class="n">binascii</span><span class="o">.</span><span class="n">unhexlify</span><span class="p">(</span><span class="n">req_hex</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">pipe</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">req_buf</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="c1"># Get the response.</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="k">await</span> <span class="n">pipe</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
    <span class="k">await</span> <span class="n">pipe</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">async_test</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="pipe-methods">
<h2>Pipe methods<a class="headerlink" href="#pipe-methods" title="Permalink to this heading"></a></h2>
<p>Pipes are an instance of the BaseProto class that provides many useful methods
and properties for working with connections (TCP or UDP.) Assume all of
these methods are of the form ‘pipe.method_name()’ and that they ‘belong’
to a BaseProto class instance.</p>
<section id="def-subscribe-self-sub-sub-all-handler-none">
<h3>def subscribe(self, sub=SUB_ALL, handler=None)<a class="headerlink" href="#def-subscribe-self-sub-sub-all-handler-none" title="Permalink to this heading"></a></h3>
<p>Install a new message queue indexed by the regex pair sub = [msg_regex, client_tup_regex]. Doing this enables the use of publish-subscribe e.g.
push / pull style awaits for a message. <strong>By default a pipe will subscribe to all messages (SUB_ALL) if a pipe has a destination given.</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Match any message containing meow.</span>
<span class="c1"># Allow only hosts from the 192.168.0.0/16 subnet.</span>
<span class="c1"># Put them into the same queue.</span>
<span class="n">sub</span> <span class="o">=</span> <span class="p">[</span><span class="sa">b</span><span class="s2">&quot;meow&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;192[.]168[.][0-9]+[.][0-9]+:[0-9]+&quot;</span><span class="p">]</span>
<span class="n">pipe</span><span class="o">.</span><span class="n">subscribe</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span>

<span class="c1"># Wait for a message that fits into the sub queue.</span>
<span class="k">await</span> <span class="n">pipe</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="def-unsubscribe-self-sub">
<h3>def unsubscribe(self, sub)<a class="headerlink" href="#def-unsubscribe-self-sub" title="Permalink to this heading"></a></h3>
<p>Delete the queue and its resources marked by sub (if it exists.) No longer
copy messages that fit this subscription into this queue.</p>
</section>
<section id="async-def-recv-self-sub-sub-all-timeout-2-full-false">
<h3>async def recv(self, sub=SUB_ALL, timeout=2, full=False)<a class="headerlink" href="#async-def-recv-self-sub-sub-all-timeout-2-full-false" title="Permalink to this heading"></a></h3>
<p>Given a queue identified by the subscription ‘sub’ – wait for a message that suites it. Waiting is done asynchronously and other tasks may be done by the
event loop until a message arrives. Timeout specifies the total duration
to attempt to wait. After the duration an exception will be thrown. Set this
to 0 to disable timeouts (not recommended.)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Wait for any message from a loopback client.</span>
<span class="n">out</span> <span class="o">=</span> <span class="k">await</span> <span class="n">pipe</span><span class="o">.</span><span class="n">recv</span><span class="p">([</span><span class="sa">b</span><span class="s2">&quot;[\s\S]+&quot;</span><span class="p">,</span> <span class="s2">&quot;127.0.0.1:[0-9]+&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>By default this function only returns the message received on the pipe.
Some pipes receive messages from multiple destinations (like UDP.)
To also show the sender set the full flag to True. The return value will
end up being [msg_bytes, client_tup].</p>
</section>
<section id="async-def-send-self-data-dest-tup-none">
<h3>async def send(self, data, dest_tup=None)<a class="headerlink" href="#async-def-send-self-data-dest-tup-none" title="Permalink to this heading"></a></h3>
<p>Wait for data to be transmitted down the pipe (non-blocking.) For TCP / UDP connections (with a fixed destination) the dest_tup does not need to be set.
But it’s a good practice to include it in servers because the same socket
in UDP servers is used to receive messages from multiple clients and the
pipe by itself won’t be able to disambiguate what the destination should be.
This is also one reasons why msg_cbs include a client_tup for a message sender.</p>
</section>
<section id="def-add-msg-cb-self-msg-cb">
<h3>def add_msg_cb(self, msg_cb)<a class="headerlink" href="#def-add-msg-cb-self-msg-cb" title="Permalink to this heading"></a></h3>
<p>When a pipe receives a message it will also forward it to any installed message
handlers. The format for a message handler is:</p>
<blockquote>
<div><p><strong>async def msg_cb(msg, client_tup, pipe)</strong></p>
</div></blockquote>
<p>The msg_cb also doesn’t have to be an async callback but keep in mind if it’s
given as a regular function you will have to use asyncio.create_task
to schedule any callbacks and you won’t be able to await them. Since
the whole library uses async await it’s best just to use an async msg_cb.</p>
<p>Using message handlers like this is very useful because you can install them
for either a server pipe or a client pipe and it will automatically be
called when there’s a new message. No need to run your own loop and
call awaits on some object. The event loop handles it.</p>
</section>
<section id="def-del-msg-cb-self-msg-cb">
<h3>def del_msg_cb(self, msg_cb)<a class="headerlink" href="#def-del-msg-cb-self-msg-cb" title="Permalink to this heading"></a></h3>
<p>Removes a function reference designated by msg_cb from the pipe’s msg_cbs.</p>
</section>
<section id="def-add-end-cb-self-end-cb">
<h3>def add_end_cb(self, end_cb)<a class="headerlink" href="#def-add-end-cb-self-end-cb" title="Permalink to this heading"></a></h3>
<p>When a connection is closed manually or forcefully the end_cb handlers are
called. These are useful for cleanup. The format is:</p>
<blockquote>
<div><p><strong>async def end_cb(msg, client_tup, pipe)</strong></p>
</div></blockquote>
<p>Where message is set to None.</p>
</section>
<section id="def-del-end-cb-self-end-cb">
<h3>def del_end_cb(self, end_cb)<a class="headerlink" href="#def-del-end-cb-self-end-cb" title="Permalink to this heading"></a></h3>
<p>Removes a function reference designated by end_cb from the pipe’s end_cb handlers.</p>
</section>
<section id="def-add-pipe-self-pipe">
<h3>def add_pipe(self, pipe)<a class="headerlink" href="#def-add-pipe-self-pipe" title="Permalink to this heading"></a></h3>
<p>Pipes can be made to route messages to other pipes. You can connect
two pipes together by adding each pipe to each other.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pipe_a</span><span class="o">.</span><span class="n">add_pipe</span><span class="p">(</span><span class="n">pipe_b</span><span class="p">)</span>
<span class="n">pipe_b</span><span class="o">.</span><span class="n">add_pipe</span><span class="p">(</span><span class="n">pipe_a</span><span class="p">)</span>
</pre></div>
</div>
<ol class="arabic simple">
<li><p>Messages received at pipe_a will be sent down pipe_b.</p></li>
<li><p>Messages received at pipe_b will be sent down pipe_a.</p></li>
</ol>
<p>This doesn’t cause looping as the messages get sent to the destination rather than the pipe itself. Linking pipes together is the trick used in the P2PD REST API
for ‘converting’ an active HTTP connection into a two-way relay to an active P2P connection in only two lines of code.</p>
</section>
<section id="def-del-pipe-self-pipe">
<h3>def del_pipe(self, pipe)<a class="headerlink" href="#def-del-pipe-self-pipe" title="Permalink to this heading"></a></h3>
<p>Unlink ‘pipe’ from self.</p>
</section>
<section id="async-def-close-self">
<h3>async def close(self)<a class="headerlink" href="#async-def-close-self" title="Permalink to this heading"></a></h3>
<p>Closes all resources associated with a pipe. If it’s a server it will stop serving
any clients and all client connections will be closed. All sockets will be
closed forcefully. Server’s that immediately reuse the same port may experience
errors where they fail to receive designated packets. There may be a solution to
this by setting SO_LINGER to enabled and using a zero timeout. But using
this option on client TCP sockets on Windows prevents the hole punching algorithm
from working so this needs to only be considered for server sockets.</p>
</section>
</section>
<section id="additional-pipe-options">
<h2>Additional pipe options<a class="headerlink" href="#additional-pipe-options" title="Permalink to this heading"></a></h2>
<p>A default dictionary of configuration options is passed to each pipe. The
options look like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">NET_CONF</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1"># Protocol family used for the socket.socket function.</span>
    <span class="s2">&quot;sock_proto&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>

    <span class="c1"># N seconds before a registering recv timeout.</span>
    <span class="s2">&quot;recv_timeout&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>

    <span class="c1"># Only applies to TCP.</span>
    <span class="s2">&quot;con_timeout&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>

    <span class="c1"># No of messages to receive per subscription.</span>
    <span class="s2">&quot;max_qsize&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>

    <span class="c1"># Require unique messages or not.</span>
    <span class="s2">&quot;enable_msg_ids&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>

    <span class="c1"># Number of message IDs to keep around.</span>
    <span class="s2">&quot;max_msg_ids&quot;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>

    <span class="c1"># Reuse address tuple for bind() socket call.</span>
    <span class="s2">&quot;reuse_addr&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>

    <span class="c1"># Setup socket as a broadcast socket.</span>
    <span class="s2">&quot;broadcast&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>

    <span class="c1"># Buf size for asyncio.StreamReader.</span>
    <span class="s2">&quot;reader_limit&quot;</span><span class="p">:</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">16</span><span class="p">,</span>

    <span class="c1"># Return the sock instead of the base proto.</span>
    <span class="s2">&quot;sock_only&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>

    <span class="c1"># Disable closing sock on error.</span>
    <span class="s2">&quot;no_close&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>

    <span class="c1"># Whether to set SO_LINGER. None = off.</span>
    <span class="c1"># Non-none = linger value.</span>
    <span class="s2">&quot;linger&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>

    <span class="c1"># Ref to an event loop.</span>
    <span class="s2">&quot;loop&quot;</span><span class="p">:</span> <span class="kc">None</span>
<span class="p">}</span>

<span class="c1"># Here&#39;s where to use these options.</span>
<span class="n">pipe</span> <span class="o">=</span> <span class="n">pipe_open</span><span class="p">(</span><span class="n">TCP</span><span class="p">,</span> <span class="n">route</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">conf</span><span class="o">=</span><span class="n">NET_CONF</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="basics.html" class="btn btn-neutral float-left" title="Basics" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="queues.html" class="btn btn-neutral float-right" title="Queues" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>