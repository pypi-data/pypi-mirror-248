"""
Implementation for the magnetic field of homogeneously
magnetized tetrahedra. Computation details in function docstrings.
"""
import numpy as np

from magpylib._src.fields.field_BH_triangle import triangle_field
from magpylib._src.input_checks import check_field_input


def check_chirality(points: np.ndarray) -> np.ndarray:
    """
    Checks if quadruple of points (p0,p1,p2,p3) that forms tetrahedron is arranged in a way
    that the vectors p0p1, p0p2, p0p3 form a right-handed system

    Parameters
    -----------
    points: 3d-array of shape (m x 4 x 3)
            m...number of tetrahedrons

    Returns
    ----------
    new list of points, where p2 and p3 are possibly exchanged so that all
    tetrahedron is given in a right-handed system.
    """

    vecs = np.zeros((len(points), 3, 3))
    vecs[:, :, 0] = points[:, 1, :] - points[:, 0, :]
    vecs[:, :, 1] = points[:, 2, :] - points[:, 0, :]
    vecs[:, :, 2] = points[:, 3, :] - points[:, 0, :]

    dets = np.linalg.det(vecs)
    dets_neg = dets < 0

    if np.any(dets_neg):
        points[dets_neg, 2:, :] = points[dets_neg, 3:1:-1, :]

    return points


def point_inside(points: np.ndarray, vertices: np.ndarray) -> np.ndarray:
    """
    Takes points, as well as the vertices of a tetrahedra.
    Returns boolean array indicating whether the points are inside the tetrahedra.
    """
    mat = vertices[:, 1:].swapaxes(0, 1) - vertices[:, 0]
    mat = np.transpose(mat.swapaxes(0, 1), (0, 2, 1))

    tetra = np.linalg.inv(mat)
    newp = np.matmul(tetra, np.reshape(points - vertices[:, 0, :], (*points.shape, 1)))
    inside = (
        np.all(newp >= 0, axis=1)
        & np.all(newp <= 1, axis=1)
        & (np.sum(newp, axis=1) <= 1)
    ).flatten()

    return inside


def magnet_tetrahedron_field(
    field: str,
    observers: np.ndarray,
    magnetization: np.ndarray,
    vertices: np.ndarray,
) -> np.ndarray:
    """
    Magnetic field generated by a homogeneously magnetized tetrahedron.

    Parameters
    ----------
    field: str, default=`'B'`
        If `field='B'` return B-field in units of mT, if `field='H'` return H-field
        in units of kA/m.

    observers: ndarray, shape (n,3)
        Observer positions (x,y,z) in Cartesian coordinates in units of mm.

    magnetization: ndarray, shape (n,3)
        Homogeneous magnetization vector in units of mT.

    vertices: ndarray, shape (n,4,3)
        Vertices of the individual tetrahedrons [(pos1a, pos1b, pos1c, pos1d),
        (pos2a, pos2b, pos2c, pos2d), ...].

    Returns
    -------
    B-field or H-field: ndarray, shape (n,3)
        B/H-field of magnet in Cartesian coordinates (Bx, By, Bz) in units of mT/(kA/m).

    Examples
    --------
    Compute the B-field of two different tetrahedron-observer instances

    >>> import numpy as np
    >>> import magpylib as magpy
    >>>
    >>> obs = np.array([(1,2,3), (2,3,4)])
    >>> mag = np.array([(222,333,444), (111,112,113)])
    >>> vert = np.array([((-1,0,0), (1,-1,0), (1,1,0), (0,0,1))]*2)
    >>> B = magpy.core.magnet_tetrahedron_field('B', obs, mag, vert)
    >>> print(B)
    [[0.19075398 0.8240532  1.18170862]
     [0.03125701 0.08445416 0.1178967 ]]

    Notes
    -----
    The tetrahedron is built up via 4 faces applying the Triangle class, making sure that
    all normal vectors point outwards, and providing inside-outside evaluation to distinguish
    between B- and H-field.
    """

    bh = check_field_input(field, "magnet_tetrahedron_field()")

    n = len(observers)

    vertices = check_chirality(vertices)
    tri_vertices = np.concatenate(
        (
            vertices[:, (0, 2, 1), :],
            vertices[:, (0, 1, 3), :],
            vertices[:, (1, 2, 3), :],
            vertices[:, (0, 3, 2), :],
        ),
        axis=0,
    )
    tri_fields = triangle_field(
        field,
        np.tile(observers, (4, 1)),
        np.tile(magnetization, (4, 1)),
        tri_vertices,
    )
    tetra_field = (  # slightly faster than reshape + sum
        tri_fields[:n]
        + tri_fields[n : 2 * n]
        + tri_fields[2 * n : 3 * n]
        + tri_fields[3 * n :]
    )

    if not bh:
        return tetra_field

    # if B, and inside magnet add magnetization vector
    mask_inside = point_inside(observers, vertices)
    tetra_field[mask_inside] += magnetization[mask_inside]
    return tetra_field
