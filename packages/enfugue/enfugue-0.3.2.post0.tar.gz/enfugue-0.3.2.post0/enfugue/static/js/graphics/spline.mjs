import{Point,Drawable}from"./geometry.mjs";import{roundTo,shiftingFrameIterator}from"../base/helpers.mjs";class SplinePoint{static TYPE_LINEAR=0;static TYPE_BEZIER=1;constructor(t,o,n,i){this.anchorPoint=t,this.pointType=o,this.controlPoint1=n,this.controlPoint2=i}clone(){return new SplinePoint(this.anchorPoint.clone(),this.pointType,void 0===this.controlPoint1?void 0:this.controlPoint1.clone(),void 0===this.controlPoint2?void 0:this.controlPoint2.clone())}copy(t){if(t instanceof SplinePoint)this.anchorPoint.x=t.x,this.anchorPoint.y=t.y,this.pointType=t.pointType,void 0===t.controlPoint1?this.controlPoint1=void 0:void 0===this.controlPoint1?this.controlPoint1=t.controlPoint1.clone():this.controlPoint1.copy(t.controlPoint1),void 0===t.controlPoint2?this.controlPoint2=void 0:void 0===this.controlPoint2?this.controlPoint2=t.controlPoint2.clone():this.controlPoint2.copy(t.controlPoint2);else{if(!(t instanceof Point))throw"Cannot copy point of type "+typeof t;this.anchorPoint.x=t.x,this.anchorPoint.y=t.y}}set x(t){this.anchorPoint.x=t}get x(){return this.anchorPoint.x}set y(t){this.anchorPoint.y=t}get y(){return this.anchorPoint.y}get cp1x(){return this.controlPoint1.x}set cp1x(t){this.controlPoint1.x=t}get cp1y(){return this.controlPoint1.y}set cp1y(t){this.controlPoint1.y=t}get cp2x(){return this.controlPoint2.x}set cp2x(t){this.controlPoint2.x=t}get cp2y(){return this.controlPoint2.y}set cp2y(t){this.controlPoint2.y=t}}class Spline extends Drawable{pointAlongSpline(t,o){for(let[n,i]of shiftingFrameIterator(this.points,2))if(n.pointType===SplinePoint.TYPE_LINEAR&&i.pointType===SplinePoint.TYPE_LINEAR){if(t.x>=n.x&&t.x<=i.x){let e=(i.y-n.y)/(i.x-n.x)*(t.x-n.x)+n.y;return e-o<=t.y&&e+o>=t.y}}else if(n.pointType===SplinePoint.TYPE_BEZIER&&i.pointType===SplinePoint.TYPE_BEZIER)for(let e=1;e<=3*o;e++){let r=e/(3*o),p=n,c=n.controlPoint2,P=i.controlPoint1,l=i,s=Math.pow(1-r,3)*p.x+3*Math.pow(1-r,2)*r*c.x+3*(1-r)*Math.pow(r,2)*P.x+Math.pow(r,3)*l.x,h=Math.pow(1-r,3)*p.y+3*Math.pow(1-r,2)*r*c.y+3*(1-r)*Math.pow(r,2)*P.y+Math.pow(r,3)*l.y;if(s-o<=t.x&&s+o>=t.x&&h-o<=t.y&&h+o>=t.y)return!0}else for(let e=1;e<=2*o;e++){let r=e/(2*o),p=n,c=n.pointType===SplinePoint.TYPE_BEZIER?n.controlPoint2:i.controlPoint1,P=i,l=Math.pow(1-r,2)*p.x+2*(1-r)*r*c.x+Math.pow(r,2)*P.x,s=Math.pow(1-r,2)*p.y+2*(1-r)*r*c.y+Math.pow(r,2)*P.y;if(l-o<=t.x&&l+o>=t.x&&s-o<=t.y&&s+o>=t.y)return!0}return!1}drawPath(t){t.beginPath(),t.moveTo(this.points[0].x,this.points[0].y);for(let[o,n]of shiftingFrameIterator(this.points,2))o.pointType===SplinePoint.TYPE_LINEAR&&n.pointType===SplinePoint.TYPE_LINEAR?t.lineTo(n.x,n.y):o.pointType===SplinePoint.TYPE_LINEAR&&n.pointType===SplinePoint.TYPE_BEZIER?t.quadraticCurveTo(n.cp1x,n.cp1y,n.x,n.y):o.pointType===SplinePoint.TYPE_BEZIER&&n.pointType===SplinePoint.TYPE_LINEAR?t.quadraticCurveTo(o.cp2x,o.cp2y,n.x,n.y):t.bezierCurveTo(o.cp2x,o.cp2y,n.cp1x,n.cp1y,n.x,n.y)}}export{SplinePoint,Spline};
