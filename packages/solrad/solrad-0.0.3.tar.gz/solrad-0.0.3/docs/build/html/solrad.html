<!doctype html>
<html class="no-js" lang="en" data-content_root="">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<link rel="index" title="Index" href="genindex.html" /><link rel="search" title="Search" href="search.html" /><link rel="next" title="solrad.atmosphere package" href="solrad.atmosphere.html" /><link rel="prev" title="src" href="modules.html" />

    <!-- Generated with Sphinx 6.2.1 and Furo 2023.09.10 -->
        <title>solrad package - solrad 0.0.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo.css?digest=369552022d0b975c8e74270ce6eabe0fb7978f24" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="index.html"><div class="brand">solrad 0.0.2 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="index.html">
  
  
  <span class="sidebar-brand-text">solrad 0.0.2 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="modules.html">src</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of src</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2 current has-children current-page"><a class="current reference internal" href="#">solrad package</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of solrad package</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="solrad.atmosphere.html">solrad.atmosphere package</a></li>
<li class="toctree-l3"><a class="reference internal" href="solrad.climate.html">solrad.climate package</a></li>
<li class="toctree-l3"><a class="reference internal" href="solrad.radiation.html">solrad.radiation package</a></li>
<li class="toctree-l3"><a class="reference internal" href="solrad.sun.html">solrad.sun package</a></li>
<li class="toctree-l3"><a class="reference internal" href="solrad.terrain.html">solrad.terrain package</a></li>
</ul>
</li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="solrad-package">
<h1>solrad package<a class="headerlink" href="#solrad-package" title="Permalink to this heading">#</a></h1>
<section id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this heading">#</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="solrad.atmosphere.html">solrad.atmosphere package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="solrad.atmosphere.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="solrad.atmosphere.html#module-solrad.atmosphere.aerosol_asymmetry_factor">solrad.atmosphere.aerosol_asymmetry_factor module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="solrad.atmosphere.html#solrad.atmosphere.aerosol_asymmetry_factor.compute_aerosol_asymmetry_factor_using_SF"><code class="docutils literal notranslate"><span class="pre">compute_aerosol_asymmetry_factor_using_SF()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="solrad.atmosphere.html#module-solrad.atmosphere.angstrom_exponent">solrad.atmosphere.angstrom_exponent module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="solrad.atmosphere.html#solrad.atmosphere.angstrom_exponent.compute_angstrom_exponent_using_SF"><code class="docutils literal notranslate"><span class="pre">compute_angstrom_exponent_using_SF()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="solrad.atmosphere.html#module-solrad.atmosphere.aod_550nm">solrad.atmosphere.aod_550nm module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="solrad.atmosphere.html#solrad.atmosphere.aod_550nm.fill_CDS_aod_550nm_data_nans"><code class="docutils literal notranslate"><span class="pre">fill_CDS_aod_550nm_data_nans()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="solrad.atmosphere.html#solrad.atmosphere.aod_550nm.get_CDS_aod_550nm_data"><code class="docutils literal notranslate"><span class="pre">get_CDS_aod_550nm_data()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="solrad.atmosphere.html#solrad.atmosphere.aod_550nm.process_CDS_aod_550nm_data"><code class="docutils literal notranslate"><span class="pre">process_CDS_aod_550nm_data()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="solrad.atmosphere.html#module-solrad.atmosphere.ozone_column">solrad.atmosphere.ozone_column module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="solrad.atmosphere.html#solrad.atmosphere.ozone_column.compute_van_Heuklon_ozone"><code class="docutils literal notranslate"><span class="pre">compute_van_Heuklon_ozone()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="solrad.atmosphere.html#solrad.atmosphere.ozone_column.get_CDS_ozone_column_data"><code class="docutils literal notranslate"><span class="pre">get_CDS_ozone_column_data()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="solrad.atmosphere.html#solrad.atmosphere.ozone_column.process_CDS_ozone_column_data"><code class="docutils literal notranslate"><span class="pre">process_CDS_ozone_column_data()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="solrad.atmosphere.html#module-solrad.atmosphere.single_scattering_albedo">solrad.atmosphere.single_scattering_albedo module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="solrad.atmosphere.html#solrad.atmosphere.single_scattering_albedo.compute_single_scattering_albedo_using_SF"><code class="docutils literal notranslate"><span class="pre">compute_single_scattering_albedo_using_SF()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="solrad.atmosphere.html#module-solrad.atmosphere.water_column">solrad.atmosphere.water_column module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="solrad.atmosphere.html#solrad.atmosphere.water_column.fill_CDS_water_column_data_nans"><code class="docutils literal notranslate"><span class="pre">fill_CDS_water_column_data_nans()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="solrad.atmosphere.html#solrad.atmosphere.water_column.get_CDS_water_column_data"><code class="docutils literal notranslate"><span class="pre">get_CDS_water_column_data()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="solrad.atmosphere.html#solrad.atmosphere.water_column.process_CDS_water_column_data"><code class="docutils literal notranslate"><span class="pre">process_CDS_water_column_data()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="solrad.atmosphere.html#module-solrad.atmosphere">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="solrad.climate.html">solrad.climate package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="solrad.climate.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="solrad.climate.html#module-solrad.climate.pvgis_tmy">solrad.climate.pvgis_tmy module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="solrad.climate.html#solrad.climate.pvgis_tmy.climate_data_from_pvgis_tmy_dataframe"><code class="docutils literal notranslate"><span class="pre">climate_data_from_pvgis_tmy_dataframe()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="solrad.climate.html#solrad.climate.pvgis_tmy.get_pvgis_tmy_dataframe"><code class="docutils literal notranslate"><span class="pre">get_pvgis_tmy_dataframe()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="solrad.climate.html#module-solrad.climate">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="solrad.radiation.html">solrad.radiation package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="solrad.radiation.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="solrad.radiation.html#module-solrad.radiation.diffuse_radiance_model">solrad.radiation.diffuse_radiance_model module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="solrad.radiation.html#solrad.radiation.diffuse_radiance_model.compute_angular_distance_between_sun_and_sky_element_Zeta"><code class="docutils literal notranslate"><span class="pre">compute_angular_distance_between_sun_and_sky_element_Zeta()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="solrad.radiation.html#solrad.radiation.diffuse_radiance_model.compute_clear_sky_index_Kc"><code class="docutils literal notranslate"><span class="pre">compute_clear_sky_index_Kc()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="solrad.radiation.html#solrad.radiation.diffuse_radiance_model.compute_cloud_ratio_Ce"><code class="docutils literal notranslate"><span class="pre">compute_cloud_ratio_Ce()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="solrad.radiation.html#solrad.radiation.diffuse_radiance_model.compute_cloudless_index_Cle"><code class="docutils literal notranslate"><span class="pre">compute_cloudless_index_Cle()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="solrad.radiation.html#solrad.radiation.diffuse_radiance_model.compute_diffuse_radiance"><code class="docutils literal notranslate"><span class="pre">compute_diffuse_radiance()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="solrad.radiation.html#solrad.radiation.diffuse_radiance_model.compute_improved_all_sky_model_coeffs"><code class="docutils literal notranslate"><span class="pre">compute_improved_all_sky_model_coeffs()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="solrad.radiation.html#solrad.radiation.diffuse_radiance_model.compute_inverse_of_the_integration_value_of_relative_sky_radiance_distribution_numerically_LzEd"><code class="docutils literal notranslate"><span class="pre">compute_inverse_of_the_integration_value_of_relative_sky_radiance_distribution_numerically_LzEd()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="solrad.radiation.html#solrad.radiation.diffuse_radiance_model.compute_inverse_of_the_integration_value_of_relative_sky_radiance_distribution_using_constants_LzEd"><code class="docutils literal notranslate"><span class="pre">compute_inverse_of_the_integration_value_of_relative_sky_radiance_distribution_using_constants_LzEd()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="solrad.radiation.html#solrad.radiation.diffuse_radiance_model.compute_sky_index_Siv"><code class="docutils literal notranslate"><span class="pre">compute_sky_index_Siv()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="solrad.radiation.html#solrad.radiation.diffuse_radiance_model.compute_standard_cloud_ratio_Ces"><code class="docutils literal notranslate"><span class="pre">compute_standard_cloud_ratio_Ces()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="solrad.radiation.html#solrad.radiation.diffuse_radiance_model.compute_standard_global_irradiance_Ghs"><code class="docutils literal notranslate"><span class="pre">compute_standard_global_irradiance_Ghs()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="solrad.radiation.html#solrad.radiation.diffuse_radiance_model.diffusion_indicatrix_function"><code class="docutils literal notranslate"><span class="pre">diffusion_indicatrix_function()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="solrad.radiation.html#solrad.radiation.diffuse_radiance_model.gradation_function"><code class="docutils literal notranslate"><span class="pre">gradation_function()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="solrad.radiation.html#module-solrad.radiation.direct_radiance_model">solrad.radiation.direct_radiance_model module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="solrad.radiation.html#solrad.radiation.direct_radiance_model.compute_direct_radiance"><code class="docutils literal notranslate"><span class="pre">compute_direct_radiance()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="solrad.radiation.html#module-solrad.radiation.spectral_radiance_model">solrad.radiation.spectral_radiance_model module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="solrad.radiation.html#solrad.radiation.spectral_radiance_model.compute_spectral_radiance"><code class="docutils literal notranslate"><span class="pre">compute_spectral_radiance()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="solrad.radiation.html#module-solrad.radiation.spectrl2">solrad.radiation.spectrl2 module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="solrad.radiation.html#solrad.radiation.spectrl2.compute_direct_and_diffuse_normalized_spectra"><code class="docutils literal notranslate"><span class="pre">compute_direct_and_diffuse_normalized_spectra()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="solrad.radiation.html#solrad.radiation.spectrl2.spectrl2"><code class="docutils literal notranslate"><span class="pre">spectrl2()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="solrad.radiation.html#module-solrad.radiation">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="solrad.sun.html">solrad.sun package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="solrad.sun.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="solrad.sun.html#module-solrad.sun.sun">solrad.sun.sun module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="solrad.sun.html#solrad.sun.sun.compute_sun_data"><code class="docutils literal notranslate"><span class="pre">compute_sun_data()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="solrad.sun.html#module-solrad.sun">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="solrad.terrain.html">solrad.terrain package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="solrad.terrain.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="solrad.terrain.html#module-solrad.terrain.horizon">solrad.terrain.horizon module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="solrad.terrain.html#solrad.terrain.horizon.clear_horizon_func"><code class="docutils literal notranslate"><span class="pre">clear_horizon_func()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="solrad.terrain.html#solrad.terrain.horizon.compute_fraction_of_unblocked_sky_patch_by_horizon"><code class="docutils literal notranslate"><span class="pre">compute_fraction_of_unblocked_sky_patch_by_horizon()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="solrad.terrain.html#solrad.terrain.horizon.horizon_arrays_from_pvgis"><code class="docutils literal notranslate"><span class="pre">horizon_arrays_from_pvgis()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="solrad.terrain.html#solrad.terrain.horizon.horizon_func_from_arrays"><code class="docutils literal notranslate"><span class="pre">horizon_func_from_arrays()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="solrad.terrain.html#solrad.terrain.horizon.plot_horizon"><code class="docutils literal notranslate"><span class="pre">plot_horizon()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="solrad.terrain.html#module-solrad.terrain">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</section>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading">#</a></h2>
</section>
<section id="module-solrad.Site">
<span id="solrad-site-module"></span><h2>solrad.Site module<a class="headerlink" href="#module-solrad.Site" title="Permalink to this heading">#</a></h2>
<p>This module contains all functions, methods and classes related to the
computation and manipulation of most of a site’s geographical and
metheorological data.</p>
<dl class="py class">
<dt class="sig sig-object py" id="solrad.Site.Site">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">solrad.Site.</span></span><span class="sig-name descname"><span class="pre">Site</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">latitude</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">longitude</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">altitude</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SF_model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Rural'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Site.Site" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="solrad.Site.Site.compute_aerosol_asymmetry_factor_using_SF_model">
<span class="sig-name descname"><span class="pre">compute_aerosol_asymmetry_factor_using_SF_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interp_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Site.Site.compute_aerosol_asymmetry_factor_using_SF_model" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the Aersol Asymmetry Factor within the spectral range
300 nm - 4000 nm, for the site, using the Ansgtrom Shettel and Fenn
model, as detailed in [1].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>interp_method</strong> (<em>{&quot;linear&quot;</em><em>, </em><em>&quot;nearest&quot;</em><em>, </em><em>&quot;cubic&quot;}</em>) – Method of interpolation to use on the data. Default is “linear”.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Produces</p>
<p>Filled <em>self.aerosol_assymetry_factor</em> attribute. More specifically, it
fills completely all the DataFrames contained by the
<em>self.aerosol_assymetry_factor</em> dict.</p>
<p class="rubric">Notes</p>
<p>1) Uses the “RH” column in the dataframes stored by the
<em>self.climate_and_air_data</em> attribute for the calculation.</p>
<dl class="field-list simple">
<dt class="field-odd">Warns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>1) Warning</strong> – f”NaN/None values detected in self.climate_and_air_df[{date}][‘RH’].
NaN input values will produce NaN output values.
None input values will raise Exceptions.”</p>
</dd>
</dl>
<p class="rubric">References</p>
<p>[1] Shettle, Eric &amp; Fenn, Robert. (1979). Models for the Aerosols of the
Lower Atmosphere and the Effects of Humidity Variations on their Optical
Properties. Environ. Res.. 94.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Site.Site.compute_angstrom_turbidity_exponent_500nm_using_SF_model">
<span class="sig-name descname"><span class="pre">compute_angstrom_turbidity_exponent_500nm_using_SF_model</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Site.Site.compute_angstrom_turbidity_exponent_500nm_using_SF_model" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the Ansgtrom turbidity exponent at 500nm for the site using the
Shettel and Fenn model, as detailed in [1].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>None</strong> – </p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Produces</p>
<p>Partially filled <em>self.climate_an_air_data</em> attribute. Specifically,
it fills the “alpha_500nm” column of all DataFrames contained by
the <em>self.climate_and_air_data</em> dict.</p>
<dl class="field-list simple">
<dt class="field-odd">Warns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>1) Warning</strong> – f”NaN/None values detected in self.climate_and_air_df[{date}][‘RH’].
NaN input values will produce NaN output values.
None input values will raise Exceptions.”</p>
</dd>
</dl>
<p class="rubric">References</p>
<p>[1] Copernicus Climate Change Service, Climate Data Store, (2019): Aerosol
properties gridded data from 1995 to present derived from satellite observation.
Copernicus Climate Change Service (C3S) Climate Data Store (CDS). DOI: 10.24381/cds.239d815c</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Site.Site.compute_aod_500nm_using_satelite_data">
<span class="sig-name descname"><span class="pre">compute_aod_500nm_using_satelite_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">percentile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Site.Site.compute_aod_500nm_using_satelite_data" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the monthly year-wise average or ‘percentile’-th percentile of Aerosol
Optical Depth at 500nm (aod_500nm) for the site. The raw data used for the calculation
is extracted from the database referenced in [1].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> (<em>path-str</em>) – Path of the folder where the aod_500nm raw.ny and filled_NaNs.npy files
are stored. That is, the path to the local aod_550nm database.</p></li>
<li><p><strong>percentile</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – If float, it computes the monthly year-wise ‘percentile’-th percentile of aod_500nm.
If NONE,  it computes the monthly year-wise average of aod_500nm.
Default is 0.5.</p></li>
<li><p><strong>interp_method</strong> (<em>{'linear'</em><em>, </em><em>'nearest'</em><em>, </em><em>'slinear'</em><em>, </em><em>'cubic'</em><em>, </em><em>'quintic'}</em><em>, </em><em>optional</em>) – The method of interpolation to perform when computing the
<em>res[“filled_nans_data_funcs”]</em>, <em>res[“avg_data_funcs”]</em> and <em>res[“percentile_data_funcs”]</em>
dictionaries. Supported methods are the same as supported by scipy’s
RegularGridInterpolator. Default is “linear”.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Produces</p>
<p>Partially filled <em>self.climate_and_air_data</em> attribute. Specifically, it
fills the “aod_500nm” column of all the DataFrames contained by the
<em>self.climate_and_air_data</em> dict.</p>
<p class="rubric">Notes</p>
<p>1) Uses the “alpha_500nm” column in the dataframes stored by the
<em>self.climate_and_air_data</em> attribute for the calculation.</p>
<dl class="field-list simple">
<dt class="field-odd">Warns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>1) Warning</strong> – f”NaN/None values detected in self.climate_and_air_df[{date}][‘alpha_500nm’].
NaN input values will produce NaN output values.
None input values will raise Exceptions.”</p>
</dd>
</dl>
<p class="rubric">References</p>
<p>[1] Copernicus Climate Change Service, Climate Data Store, (2019): Aerosol
properties gridded data from 1995 to present derived from satellite observation.
Copernicus Climate Change Service (C3S) Climate Data Store (CDS). DOI: 10.24381/cds.239d815c</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Site.Site.compute_cummulative_time_integral_of_irradiances">
<span class="sig-name descname"><span class="pre">compute_cummulative_time_integral_of_irradiances</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Site.Site.compute_cummulative_time_integral_of_irradiances" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the cummulative time integral of the cols {“G(h)”, “Gb(n)”, “Gd(h)”}
in <em>self.climate_and_air_data[date]</em>, for all dates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>None</strong> – </p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Produces</p>
<p>Partially filled <em>self.climate_and_air_data</em> attribute. Specifically, it adds
the columns {“int G(h)”, “int Gb(n)”, “int Gd(h)”} to each dataframe of the dict
<em>self.climate_and_air_data</em>; containing the cummulative time integral of
the columns {“G(h)”, “Gb(n)” and “Gd(h)”}, respectively. Units of this new columns
are Wh/m^2.</p>
<dl class="field-list simple">
<dt class="field-odd">Warns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>1) Warning</strong> – f”NaN/None values detected in self.climate_and_air_df[{date}][{col}].
NaN input values will produce NaN output values.
None input values will raise Exceptions.”</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Site.Site.compute_extraterrestrial_normal_irradiance">
<span class="sig-name descname"><span class="pre">compute_extraterrestrial_normal_irradiance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'nrel'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Site.Site.compute_extraterrestrial_normal_irradiance" title="Permalink to this definition">#</a></dt>
<dd><p>Determines extraterrestrial radiation from day of year, using pvlib’s
<code class="docutils literal notranslate"><span class="pre">get_extra_radiation</span></code> function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>method</strong> (<em>{&quot;pyephem&quot;</em><em>, </em><em>&quot;spencer&quot;</em><em>, </em><em>&quot;asce&quot;</em><em>, </em><em>&quot;nrel&quot;}</em><em>, </em><em>opional</em>) – The method by which the extraterrestrial radiation should be
calculated. The default is “nrel”.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None.</p>
</dd>
</dl>
<p class="rubric">Produces</p>
<p>Partially filled <em>self.climate_and_air_data</em> attribute. Specifically, it
fills the “extra_Gbn” column of all the DataFrames contained by the
<em>self.climate_and_air_data</em> dict.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Site.Site.compute_ozone_column_using_satelite_data">
<span class="sig-name descname"><span class="pre">compute_ozone_column_using_satelite_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">percentile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Site.Site.compute_ozone_column_using_satelite_data" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the monthly year-wise average or ‘percentile’-th percentile of atmospheric ozone column
for the site. The raw data used for the calculation is extracted from the database referenced in [1].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> (<em>path-str</em>) – Path of the folder where the ozone column raw.ny and filled_NaNs.npy files
are stored. That is, the path to the local ozone column database.</p></li>
<li><p><strong>percentile</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – If float, it computes the monthly year-wise ‘percentile’-th percentile of ozone column.
If NONE,  it computes the monthly year-wise average of ozone column.
Default is 0.5.</p></li>
<li><p><strong>interp_method</strong> (<em>{'linear'</em><em>, </em><em>'nearest'</em><em>, </em><em>'slinear'</em><em>, </em><em>'cubic'</em><em>, </em><em>'quintic'}</em><em>, </em><em>optional</em>) – The method of interpolation to perform when computing the
<em>res[“filled_nans_data_funcs”]</em>, <em>res[“avg_data_funcs”]</em> and <em>res[“percentile_data_funcs”]</em>
dictionaries. Supported methods are the same as supported by scipy’s
RegularGridInterpolator. Default is “linear”.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Produces</p>
<p>Partially filled <em>self.climate_and_air_data</em> attribute. Specifically, it
fills the “O3” column of all the DataFrames contained by the
<em>self.climate_and_air_data</em> dict.</p>
<p class="rubric">References</p>
<p>[1] Copernicus Climate Change Service, Climate Data Store, (2020):
Ozone monthly gridded data from 1970 to present derived from satellite
observations. Copernicus Climate Change Service (C3S) Climate Data Store
(CDS). DOI: 10.24381/cds.4ebfe4eb</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Site.Site.compute_ozone_column_using_van_Heuklon_model">
<span class="sig-name descname"><span class="pre">compute_ozone_column_using_van_Heuklon_model</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Site.Site.compute_ozone_column_using_van_Heuklon_model" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the ozone column values (in atm-cm) for the site, using
van Heuklon’s Ozone model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>None</strong> – </p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Produces</p>
<p>Partially filled <em>self.climate_and_air_data</em> attribute. Specifically, it
fills the “O3” column of all the DataFrames contained by the
<em>self.climate_and_air_data</em> dict.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Site.Site.compute_single_scattering_albedo_using_SF_model">
<span class="sig-name descname"><span class="pre">compute_single_scattering_albedo_using_SF_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interp_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Site.Site.compute_single_scattering_albedo_using_SF_model" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the Single Scattering Albedo within the spectral range
300 nm - 4000 nm, for the site, using the Ansgtrom Shettel and Fenn
model, as detailed in [1].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>interp_method</strong> (<em>{&quot;linear&quot;</em><em>, </em><em>&quot;nearest&quot;</em><em>, </em><em>&quot;cubic&quot;}</em>) – Method of interpolation to use on the data. Default is “linear”.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Produces</p>
<p>Filled <em>self.single_scattering_albedo</em> attribute. More specifically, it
fills completely all the DataFrames contained by the
<em>self.single_scattering_albedo</em> dict.</p>
<p class="rubric">Notes</p>
<p>1) Uses the “RH” column in the dataframes stored by the
<em>self.climate_and_air_data</em> attribute for the calculation.</p>
<dl class="field-list simple">
<dt class="field-odd">Warns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>1) Warning</strong> – f”NaN/None values detected in self.climate_and_air_df[{date}][‘RH’].
NaN input values will produce NaN output values.
None input values will raise Exceptions.”</p>
</dd>
</dl>
<p class="rubric">References</p>
<p>[1] Shettle, Eric &amp; Fenn, Robert. (1979). Models for the Aerosols of the
Lower Atmosphere and the Effects of Humidity Variations on their Optical
Properties. Environ. Res.. 94.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Site.Site.compute_spectrally_averaged_aerosol_asymmetry_factor">
<span class="sig-name descname"><span class="pre">compute_spectrally_averaged_aerosol_asymmetry_factor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spectral_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(300,</span> <span class="pre">4000)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Site.Site.compute_spectrally_averaged_aerosol_asymmetry_factor" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the spectral average of the aerosol asymmetry factor,
for the interval of wavelengths specified.</p>
<p>We take the <em>self.aerosol_asymmetry_factor</em> attribute, loop over all
the DataFrames stored in it and compute the row-wise mean of the
values for the interval of wavelengths specified by <em>spectral range</em>.
We then use the the computed values to fill the “spectrally_averaged_aaf”
column in all dataframes of the <em>self.climate_and_air_data</em> attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>spectral_range</strong> (<em>2-tuple</em><em> of </em><em>float</em>) – Tuple containing the lower and upper bounds of wavelengths
(in nm) that make up the spectral range meant for averaging the
aerosol asymmetry factor.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Produces</p>
<p>Partially filled <em>self.climate_an_air_data</em> attribute. Specifically,
it fills the “spectrally_averaged_aaf” column of all DataFrames
contained by the <em>self.climate_and_air_data</em> dict.</p>
<p class="rubric">Notes</p>
<ol class="arabic simple">
<li><p>Uses the <em>self.aerosol_asymmtry_factor</em> attribute for the calculation.</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Site.Site.compute_sun_data">
<span class="sig-name descname"><span class="pre">compute_sun_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">NaN_handling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Site.Site.compute_sun_data" title="Permalink to this definition">#</a></dt>
<dd><p>Compute solar position data and related parameters for a specific location and time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>NaN_handling</strong> (<em>{&quot;strict&quot;</em><em>, </em><em>&quot;loose&quot;</em><em>, </em><em>&quot;null&quot;}</em><em>, </em><em>optional</em>) – How to handle NaN and None values when present in “SP” and “T2m” columns of the DataFrames stored in <em>self.climate_and_air_data</em>
If “strict” an Exception is raised.
If “loose”, default values are used instead (see notes for more info).
If “null”, nothing is done about it and NaN/None values are directly passed onto the calculation, which may
produce NaN results or raise another Exception.
Default is “strict”.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Produces</p>
<p>Filled <em>self.sun_data</em> attribute.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="docutils literal notranslate"><span class="pre">pvlib.solarposition.get_solarposition</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>1) In case that NaN_handling is “loose”, the default value of temperature used is 15°C and the default
value of pressure is computed from altitude using the function <code class="docutils literal notranslate"><span class="pre">pvlib.atmosphere.alt2pres</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Site.Site.compute_water_column_using_gueymard94_model">
<span class="sig-name descname"><span class="pre">compute_water_column_using_gueymard94_model</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Site.Site.compute_water_column_using_gueymard94_model" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the Precipitable Water Column values (in atm-cm) for the site,
using pvlib’s implementation of the gueymard94 model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>None</strong> – </p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Produces</p>
<p>Partially filled <em>self.climate_and_air_data</em> attribute. More specifically, it
fills the “H2O” column of all the DataFrames contained by the
<em>self.climate_and_air_data</em> dict.</p>
<p class="rubric">Notes</p>
<p>1) Uses the “RH” and “T2m” columns in the dataframes stored by the
<em>self.climate_and_air_data</em> attribute for the calculation.</p>
<dl class="field-list simple">
<dt class="field-odd">Warns<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>1) Warning</strong> – f”NaN/None values detected in self.climate_and_air_df[{date}][‘T2m’].
NaN input values will produce NaN output values.
None input values will raise Exceptions.”</p></li>
<li><p><strong>2) Warning</strong> – f”NaN/None values detected in self.climate_and_air_df[{date}][‘RH’].
NaN input values will produce NaN output values.
None input values will raise Exceptions.”</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Site.Site.compute_water_column_using_satelite_data">
<span class="sig-name descname"><span class="pre">compute_water_column_using_satelite_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">percentile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Site.Site.compute_water_column_using_satelite_data" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the monthly year-wise average or ‘percentile’-th percentile of atmospheric water column
for the site. The raw data used for the calculation is extracted from the database referenced in [1].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> (<em>path-str</em>) – Path of the folder where the water column raw.ny and filled_NaNs.npy files
are stored. That is, the path to the local water column database.</p></li>
<li><p><strong>percentile</strong> (<em>float</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – If float, it computes the monthly year-wise ‘percentile’-th percentile of water_column.
If NONE,  it computes the monthly year-wise average of water_column.
Default is 0.5.</p></li>
<li><p><strong>interp_method</strong> (<em>{'linear'</em><em>, </em><em>'nearest'</em><em>, </em><em>'slinear'</em><em>, </em><em>'cubic'</em><em>, </em><em>'quintic'}</em><em>, </em><em>optional</em>) – The method of interpolation to perform when computing the
<em>res[“filled_nans_data_funcs”]</em>, <em>res[“avg_data_funcs”]</em> and <em>res[“percentile_data_funcs”]</em>
dictionaries. Supported methods are the same as supported by scipy’s
RegularGridInterpolator. Default is “linear”.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Produces</p>
<p>Partially filled <em>self.climate_and_air_data</em> attribute. Specifically, it
fills the “H2O” column of all the DataFrames contained by the
<em>self.climate_and_air_data</em> dict.</p>
<p class="rubric">References</p>
<p>[1] Preusker, R., El Kassar, R. (2022): Monthly total column water vapour
over land and ocean from 2002 to 2012 derived from satellite observation.
Copernicus Climate Change Service (C3S) Climate Data Store (CDS).
DOI: 10.24381/cds.8e0e4724</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Site.Site.define_simulation_time_data">
<span class="sig-name descname"><span class="pre">define_simulation_time_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_hms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_hms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inclusive</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Site.Site.define_simulation_time_data" title="Permalink to this definition">#</a></dt>
<dd><p>Define time data used for simulation.</p>
<p>It generates a date range based on geographical coordinates and specified time parameters,
with optional filtering for each day based on user input or sunrise and sunset times.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start_time</strong> (<em>str</em>) – The starting date and time in the format ‘YYYY-MM-DD HH:MM:SS’.</p></li>
<li><p><strong>end_time</strong> (<em>str</em>) – The ending date and time in the format ‘YYYY-MM-DD HH:MM:SS’.</p></li>
<li><p><strong>freq</strong> (<em>str</em>) – The frequency at which the date range should be generated.
Any frequency accepted by pandas.date_range is valid for geo_date_range.</p></li>
<li><p><strong>min_hms</strong> (<em>str</em><em> or </em><em>None</em>) – A string representing the minimum hour-minute-second (HH:MM:SS) value for a Timestamp within each day’s time series.
If the hms values are below this threshold, they are removed. It can also be set to None to ignore this condition,
or to “sunrise” to use the computed sunrise time for the location as the value for <em>min_hms</em>.</p></li>
<li><p><strong>max_hms</strong> (<em>str</em><em> or </em><em>None</em>) – A string representing the maximum hour-minute-second (HH:MM:SS) value for a Timestamp within each day’s time series.
If the hms values are above this threshold, they are removed. It can also be set to None to ignore this condition,
or to “sunset” to use the computed sunset time for the location as the value for <em>max_hms</em>.</p></li>
<li><p><strong>inclusive</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to forcibly include the end_time in the generated date range, in case it’s left out. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Produces</p>
<dl class="simple">
<dt>self.simulation_time_data<span class="classifier">dict</span></dt><dd><p>A dictionary containing the filtered date ranges/time series, separated by day, based on the specified parameters.
Its strucure is as follows: Each key is a 3-tuple of (year : int, month : int, day :int) and each corresponding value is a
pandas.DatetimeIndex object containing the time series associated to that date.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>1) This function also initializes other attributes such as: <em>self.climate_and_air_data</em>,
<em>self.sun_data</em>, <em>self.single_scattering_albedo</em>, <em>self.aerosol_asymmetry_factor</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Site.Site.plot_data">
<span class="sig-name descname"><span class="pre">plot_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">col</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">years</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">months</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">days</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hours</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(16,</span> <span class="pre">12)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Site.Site.plot_data" title="Permalink to this definition">#</a></dt>
<dd><p>Plot site variable specified by <em>col</em>, for the period of time specified,
and using the mode selected.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>col</strong> (<em>str</em>) – Name of the variable to be plotted. Must be one of the keys of
<em>self.variables_info[“descriptions”]</em>.</p></li>
<li><p><strong>years</strong> (<em>list</em><em> or </em><em>None</em>) – If list, it must be a list of 2 elements, containing the lower and
upper bounds of the years to plot. The first element of <em>years</em>
would be the lower bound, while the second element would be the
upper bound. If None, the lower and upper bounds for the <em>years</em>
variable are automatically selected by the program so that all
avialable years are included.</p></li>
<li><p><strong>months</strong> (<em>list</em><em> or </em><em>None</em>) – If list, it must be a list of 2 elements, containing the lower and
upper bounds of the months to plot. The first element of <em>months</em>
would be the lower bound, while the second element would be the
upper bound. If None, the lower and upper bounds for the <em>months</em>
variable are automatically selected by the program so that all
avialable months are included.</p></li>
<li><p><strong>days</strong> (<em>list</em><em> or </em><em>None</em>) – If list, it must be a list of 2 elements, containing the lower and
upper bounds of the days to plot. The first element of <em>days</em>
would be the lower bound, while the second element would be the
upper bound. If None, the lower and upper bounds for the ‘days’
variable are automatically selected by the program so that all
avialable days are included.</p></li>
<li><p><strong>hours</strong> (<em>list</em><em> of </em><em>hours</em>) – If list, it must be a list of 2 elements, containing the lower and
upper bounds of the hours to plot. The first element of <em>hours</em>
would be the lower bound, while the second element would be the
upper bound.</p></li>
<li><p><strong>mode</strong> (<em>int</em><em>, </em><em>optional</em>) – <p>Mode of plotting. There are 3 options:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>mode=1 : Plot all variable curves for all times.</p></li>
<li><p>mode=2 : Plot all variable curves for all times + Plot average and 25th, 50th, 75th percentiles.</p></li>
<li><p>mode=3 : Plot average and 25th, 50th, 75th percentiles.</p></li>
</ol>
</div></blockquote>
<p>Default is mode=2.</p>
</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>interp_method<span class="classifier">{‘linear’, ‘nearest’, ‘cubic’}, optional</span></dt><dd><p>Method to use for the interpolation of data before plotting.
The methods supported are the same ones as those supported by
<code class="docutils literal notranslate"><span class="pre">scipy.interpolate.griddata</span></code> function. Default is “linear”.</p>
</dd>
<dt>figsize<span class="classifier">2-tuple of int, optional</span></dt><dd><p>Figure size of plot. Default is (16, 12).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Site.Site.plot_horizon">
<span class="sig-name descname"><span class="pre">plot_horizon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">azimuth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">config</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Site.Site.plot_horizon" title="Permalink to this definition">#</a></dt>
<dd><p>Plots site’s horizon profile based on the provided azimuth data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>config</strong> (<em>None</em><em> or </em><em>dict</em><em>, </em><em>optional</em>) – <p>Configuration settings of the plot. When equal to None (which is
the default) the default plot settings are used. When not equal to None,
it must be a dict containing some or all of the following key-value
pairs:</p>
<blockquote>
<div><dl class="simple">
<dt>“projection”<span class="classifier">”polar” or “cartesian”</span></dt><dd><p>If equal to “polar”, the Horizon profile is plotted using a polar
plot. If equal to “cartesian”, it is plotted using a cartesian plot.
“Default is “polar”.</p>
</dd>
<dt>”show_polar_elevation”<span class="classifier">bool</span></dt><dd><p>If true, it shows the elevation angle makers for the polar
plot. If False, it does not. Default is False.</p>
</dd>
<dt>”title”<span class="classifier">str</span></dt><dd><p>Title of the plot. Default is ‘Horizon Profile’.</p>
</dd>
<dt>”facecolor”<span class="classifier">str</span></dt><dd><p>Background color of the Horizon Height part of the plot.
Must be equal to str(x), where x is a float between 0 and 1.
0 means that the background color is black. 1 means that it
is white. Any value in between represents a shade of gray.
Default is “0.5”.</p>
</dd>
<dt>”figsize”<span class="classifier">tuple of float</span></dt><dd><p>Figure size of the plot.</p>
</dd>
</dl>
</div></blockquote>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Site.Site.reset_horizon">
<span class="sig-name descname"><span class="pre">reset_horizon</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Site.Site.reset_horizon" title="Permalink to this definition">#</a></dt>
<dd><p>Resets horizon profile, such that elevation is 0° everywhere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>None</strong> – </p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Produces</p>
<p>self.horizon attribute : dict
Dictionary with information about the horizon. It has the following
key-value pairs:</p>
<blockquote>
<div><dl class="simple">
<dt>‘func’<span class="classifier">Callable</span></dt><dd><p>Horizon function. Its input is an array of azimuth values (in degrees)
and its output is an array of horizon elevation angle values (in degrees).</p>
</dd>
<dt>‘is_clear’<span class="classifier">bool</span></dt><dd><p>Whether the current horizon is clear or not (i.e, null elevation everywhere).</p>
</dd>
<dt>‘is_pvgis’<span class="classifier">bool</span></dt><dd><p>Whether the current horizon was obtained from pvgis.</p>
</dd>
<dt>‘was_used_for_climate_data’<span class="classifier">bool</span></dt><dd><p>Whether the current horizon was used for the computation of
climate data.</p>
</dd>
</dl>
</div></blockquote>
<p class="rubric">Notes</p>
<p>1) Horizon height is the angle between the local horizontal plane and the
horizon. In other words, the Horizon height is equal to the horizon’s
elevation angle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Site.Site.set_climate_data_from_pvgis_tmy_data">
<span class="sig-name descname"><span class="pre">set_climate_data_from_pvgis_tmy_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">startyear</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endyear</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_site_horizon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Site.Site.set_climate_data_from_pvgis_tmy_data" title="Permalink to this definition">#</a></dt>
<dd><p>Use the Typical Meteorological Year (TMY) data from PVGIS to partially
fill the <em>self.climate_and_air_data</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>startyear</strong> (<em>int</em><em> or </em><em>None</em>) – First year to calculate TMY.</p></li>
<li><p><strong>endyear</strong> (<em>int</em><em> or </em><em>None</em>) – Last year to calculate TMY, must be at least 10 years from first year.</p></li>
<li><p><strong>interp_method</strong> (<em>{'linear'</em><em>, </em><em>'quadratic'</em><em>, </em><em>'cubic'}</em><em>, </em><em>optional</em>) – The interpolation method to be used. Defaults is ‘linear’.</p></li>
<li><p><strong>use_site_horizon</strong> (<em>bool</em><em>, </em><em>optional</em>) – Wether to include effects of the site’s horizon. Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Produces</p>
<p>Partially filled <em>self.climate_and_air_data</em> attribute. Specifically, it
fills the “G(h)”, “Gb(n)”, “Gd(h)”, “T2m”, “SP”, “RH” columns of all the
DataFrames contained by the <em>self.climate_and_air_data</em> dict.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="docutils literal notranslate"><span class="pre">pvlib.iotools.get_pvgis_tmy</span></code></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Site.Site.set_horizon_from_arrays">
<span class="sig-name descname"><span class="pre">set_horizon_from_arrays</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">azimuth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elevation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Site.Site.set_horizon_from_arrays" title="Permalink to this definition">#</a></dt>
<dd><p>Set site’s horizon function by interpolating provided data points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>azimuth</strong> (<em>array_like</em><em> (</em><em>npoints</em><em>,</em><em>)</em>) – Array of azimuth angle values in degrees, from 0 to 360. Must be monotonic-increasing.</p></li>
<li><p><strong>elevation</strong> (<em>array_like</em><em> (</em><em>npoints</em><em>,</em><em>)</em>) – Array of horizon elevation angle values in degrees. Elevation values must
lie between 0 and 90.</p></li>
<li><p><strong>interp_method</strong> (<em>{&quot;linear&quot;</em><em>, </em><em>&quot;quadratic&quot;</em><em>, </em><em>&quot;cubic&quot;}</em><em>, </em><em>optional</em>) – Order of the spline interpolator to use. Default is ‘linear’.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Produces</p>
<dl>
<dt>self.horizon attribute<span class="classifier">dict</span></dt><dd><p>Dictionary with information about the horizon. It has the following
key-value pairs:</p>
<blockquote>
<div><dl class="simple">
<dt>‘func’<span class="classifier">Callable</span></dt><dd><p>Horizon function. Its input is an array of azimuth values (in degrees)
and its output is an array of horizon elevation angle values (in degrees).</p>
</dd>
<dt>‘is_clear’<span class="classifier">bool</span></dt><dd><p>Whether the current horizon is clear or not (i.e, null elevation everywhere).</p>
</dd>
<dt>‘is_pvgis’<span class="classifier">bool</span></dt><dd><p>Whether the current horizon was obtained from pvgis.</p>
</dd>
<dt>‘was_used_for_climate_data’<span class="classifier">bool</span></dt><dd><p>Whether the current horizon was used for the computation of
climate data.</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>1) Horizon height is the angle between the local horizontal plane and the
horizon. In other words, the Horizon height is equal to the horizon’s
elevation angle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Site.Site.set_horizon_from_func">
<span class="sig-name descname"><span class="pre">set_horizon_from_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Site.Site.set_horizon_from_func" title="Permalink to this definition">#</a></dt>
<dd><p>Set site’s horizon function by directly passing a function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>func</strong> (<em>callable</em>) – Horizon profile function. It should take in an array of azimuth values
(in degrees) and return an array of elevation angle values (in degrees).</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Produces</p>
<dl>
<dt>self.horizon attribute<span class="classifier">dict</span></dt><dd><p>Dictionary with information about the horizon. It has the following
key-value pairs:</p>
<blockquote>
<div><dl class="simple">
<dt>‘func’<span class="classifier">Callable</span></dt><dd><p>Horizon function. Its input is an array of azimuth values (in degrees)
and its output is an array of horizon elevation angle values (in degrees).</p>
</dd>
<dt>‘is_clear’<span class="classifier">bool</span></dt><dd><p>Whether the current horizon is clear or not (i.e, null elevation everywhere).</p>
</dd>
<dt>‘is_pvgis’<span class="classifier">bool</span></dt><dd><p>Whether the current horizon was obtained from pvgis.</p>
</dd>
<dt>‘was_used_for_climate_data’<span class="classifier">bool</span></dt><dd><p>Whether the current horizon was used for the computation of
climate data.</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>1) Horizon height is the angle between the local horizontal plane and the
horizon. In other words, the Horizon height is equal to the horizon’s
elevation angle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Site.Site.set_horizon_from_pvgis">
<span class="sig-name descname"><span class="pre">set_horizon_from_pvgis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interp_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Site.Site.set_horizon_from_pvgis" title="Permalink to this definition">#</a></dt>
<dd><p>Get a site’s horizon profile from PVGIS’s API and use it for the current site.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>interp_methd</strong> (<em>{'linear'</em><em>, </em><em>'quadratic'</em><em>, </em><em>'cubic'}</em><em>, </em><em>optional</em>) – Order of the spline interpolator to use. Default is ‘linear’.</p></li>
<li><p><strong>timeout</strong> (<em>float</em>) – Number of seconds after which the requests library will stop waiting
for a response of the server. That is, if the requests library does not
receive a response in the specified number of seconds, it will raise a
Timeout error.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Produces</p>
<dl>
<dt>self.horizon<span class="classifier">dict</span></dt><dd><p>Dictionary with information about the horizon. It has the following
key-value pairs:</p>
<blockquote>
<div><dl class="simple">
<dt>‘func’<span class="classifier">Callable</span></dt><dd><p>Horizon function. Its input is an array of azimuth values (in degrees)
and its output is an array of horizon elevation angle values (in degrees).</p>
</dd>
<dt>‘is_clear’<span class="classifier">bool</span></dt><dd><p>Whether the current horizon is clear or not (i.e, null elevation everywhere).</p>
</dd>
<dt>‘is_pvgis’<span class="classifier">bool</span></dt><dd><p>Whether the current horizon was obtained from pvgis.</p>
</dd>
<dt>‘was_used_for_climate_data’<span class="classifier">bool</span></dt><dd><p>Whether the current horizon was used for the computation of
climate data.</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>1) Horizon height is the angle between the local horizontal plane and the
horizon. In other words, the Horizon height is equal to the horizon’s
elevation angle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Site.Site.time_interpolate_variable">
<span class="sig-name descname"><span class="pre">time_interpolate_variable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">col</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">year</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">month</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">day</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_hms_float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interp_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Site.Site.time_interpolate_variable" title="Permalink to this definition">#</a></dt>
<dd><p>Interpolate a site variable across time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>col</strong> (<em>str</em>) – Name of the variable to be plotted. Must be one of the keys of
<em>self.variables_info[“descriptions”]</em>.</p></li>
<li><p><strong>year</strong> (<em>int</em>) – Year at which the variable is defined.</p></li>
<li><p><strong>month</strong> (<em>int</em>) – Month at which the variable is defined.</p></li>
<li><p><strong>day</strong> (<em>int</em>) – Day at which the variable is defined.</p></li>
<li><p><strong>new_hms_float</strong> (<em>array-like</em><em> of </em><em>floats</em><em> (</em><em>npoints</em><em>,</em><em>)</em>) – Fractional hours at which to evaluate the interpolated variable.
The range of <em>new_hms_float</em> must be the same as the the variable’s
original hms_float.</p></li>
<li><p><strong>interp_method</strong> (<em>{'linear'</em><em>, </em><em>'slinear'</em><em>, </em><em>'quadratic'</em><em>, </em><em>'cubic'}</em><em>, </em><em>optional</em>) – Interpolation method. Any str supported by the <code class="docutils literal notranslate"><span class="pre">scipy.interpolate.interp1d</span></code>
function is accepted. Default is “linear”.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>interpd_y</strong> – Array of interpolated values for the variable specified by “col”,
at the times specified by “year”, “month”, “day”.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.array of floats (npoints,)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-solrad.Sky">
<span id="solrad-sky-module"></span><h2>solrad.Sky module<a class="headerlink" href="#module-solrad.Sky" title="Permalink to this heading">#</a></h2>
<p>This module contains all functions, methods and classes related to the
modelling of radiation coming from the sky.</p>
<dl class="py class">
<dt class="sig sig-object py" id="solrad.Sky.Sky">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">solrad.Sky.</span></span><span class="sig-name descname"><span class="pre">Sky</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Site_obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_divisions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">400</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Sky.Sky" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="solrad.Sky.Sky.azimuth_to_patch">
<span class="sig-name descname"><span class="pre">azimuth_to_patch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zone_num</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">az</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Sky.Sky.azimuth_to_patch" title="Permalink to this definition">#</a></dt>
<dd><p>Bin azimuth value into the correct sky patch via binary search.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>zone_num</strong> (<em>int</em>) – Sky zone to which the azimuth value “belongs”.</p></li>
<li><p><strong>az</strong> (<em>float</em>) – Azimuth value in degrees. Must be between 0 and 360.</p></li>
<li><p><strong>start</strong> (<em>int</em><em> or </em><em>None</em>) – Lower search bound for patch. If None, it defaults to the lowest
bound possible.</p></li>
<li><p><strong>end</strong> (<em>int</em><em> or </em><em>None</em>) – Upper search bound for patch. If None, it defaults to the highest
bound possible.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>local_patch_num</strong> – Sky patch (int) to which the zenith coordinate belongs, or “not found”
if search failed.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Sky.Sky.compute_absorbed_energy_by_unit_plane">
<span class="sig-name descname"><span class="pre">compute_absorbed_energy_by_unit_plane</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_uvec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">absorption_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">component</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'global'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Sky.Sky.compute_absorbed_energy_by_unit_plane" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the total energy absorbed by a unit plane from the sky for a specified component of radiation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_uvec</strong> (<em>numpy.array</em><em> of </em><em>float with shape</em><em> (</em><em>3</em><em>,</em><em>)</em>) – The normal unit vector of the unit plane.</p></li>
<li><p><strong>absorption_func</strong> (<em>int</em><em>, </em><em>float</em><em>, or </em><em>callable</em><em>, </em><em>optional</em>) – The absorption function. If int or float, a constant absorption coefficient is used.
If callable, the function should take an array of arguments representing angle of incidence
and wavelength and return the absorption coefficient. Default is 1.</p></li>
<li><p><strong>component</strong> (<em>{&quot;global&quot;</em><em>, </em><em>&quot;direct&quot;</em><em>, </em><em>&quot;diffuse&quot;}</em><em>, </em><em>optional</em>) – The spectral component to consider. Default is “global”.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>total_absorbed_incident_energy</strong> – The total absorbed incident energy by the unit plane.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the <cite>absorption_func</cite> is not a valid type.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This method computes the total absorbed energy by a unit plane for a specified spectral component.
The computation considers the spectral exposure vectors and absorption function. The total absorbed
energy is returned as a scalar value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Sky.Sky.compute_exposure_vectors_for_a_date_interval">
<span class="sig-name descname"><span class="pre">compute_exposure_vectors_for_a_date_interval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_date</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_date</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">46</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">naz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">181</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">150</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_site_horizon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">int_nzen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">int_naz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Sky.Sky.compute_exposure_vectors_for_a_date_interval" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the radiant exposure and spectral radiant exposure vectors
of each Sky patch. That is, the time-integrated spectral irradiance
over each Sky patch (for a given date interval) by integrating the
time-integrated spectral radiance with respect to the solid angle, over
each sky patch of the discretised Sky Vault.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start_date</strong> (<em>3-tuple</em><em> of </em><em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – Start date of computation.
If None, the first date in self.Site_obj.simulation_times_data.keys() is chosen.
Otherwise, it must be a is 3-tuple of (year, month, day) indicating the start date.</p></li>
<li><p><strong>end_date</strong> (<em>3-tuple</em><em> of </em><em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – End date of computation.
If None, the last date in self.Site_obj.simulation_times_data.keys() is chosen.
Otherwise, it must be a is 3-tuple of (year, month, day) indicating the end date.</p></li>
<li><p><strong>nel</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of samples for dicretizing the sky vault with regards to
the elevation coordinate. Default is 46.</p></li>
<li><p><strong>naz</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of samples for dicretizing the sky vault with regards to
the azimuth coordinate. Default is 181.</p></li>
<li><p><strong>num_iterations</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of iterations to use when filling NaN data. Default is 150.</p></li>
<li><p><strong>use_site_horizon</strong> (<em>bool</em>) – Include horizon effects. Default is False.</p></li>
<li><p><strong>int_nzen</strong> (<em>int</em>) – Number of samples for dicretizing each sky patch, with regards to
the zenith coordinate, in order to compute the diffuse spectral
irradiance via integration. Default is 20.</p></li>
<li><p><strong>int_naz</strong> (<em>int</em>) – Number of samples for dicretizing each sky patch, with regards to
the zenith coordinate, in order to compute the diffuse spectral
irradiance via integration. Default is 30.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Produces</p>
<dl>
<dt>self.patch_data[(zone_num, local_patch_num)][“exposure”]<span class="classifier">dict of dicts</span></dt><dd><p>Each sky patch recieves a new key in its database called
“exposure”. This is a dict with keys: “direct”, “diffuse”, “global”,
“spectral_direct”, “spectral_diffuse”, “spectral_global”; and “wavelengths”.
Aside from “wavelengths”, every other key holds another dictionary that stores
some relevant information about the direct, diffuse and global radiant and
spectral radiant exposure (respectively) related to that particular sky patch.</p>
<p>For keys “spectral_direct”, “spectral_diffuse”, “spectral_global”,
each of these dicts contains the following key-value pairs:</p>
<blockquote>
<div><dl class="simple">
<dt>“vector”<span class="classifier">np.array of floats with shape (3,122)</span></dt><dd><p>spectral direct/spectral diffuse/spectral global
(depending on the case) radiant exposure vector.
“vector”[0,:], “vector”[1,:] and “vector”[2,:],
hold the x, y and z components of the
spectral radiant exposure vector, respectively,
for all wavelengths in key “wavelengths”.
Each component has units of Wh/m^2/nm.</p>
</dd>
<dt>“magnitude”<span class="classifier">np.array of floats with shape (122,)</span></dt><dd><p>Magnitude of the spectral direct/spectral diffuse/spectral global
(depending on the case) spectral radiant exposure vector.
It has units of Wh/m^2/nm.</p>
</dd>
<dt>“spectrally_averaged_unit_vector”<span class="classifier">np.array of floats with shape (3,)</span></dt><dd><p>Average position of irradiance within a sky patch. That is,
the unit vector version of the spectrally averageds
spectral direct/spectral diffuse/spectral global (depending
on the case) radiant exposure vector.
In the case, however, that said Spectral radiant exposure
vector is zero, we default to using the unit vector
pointing to the center of the current sky patch.
It is adimensional.</p>
</dd>
</dl>
</div></blockquote>
<p>Now, for keys “direct”, “diffuse”, “global”,
each of these dicts contains the following key-value pairs:</p>
<blockquote>
<div><dl class="simple">
<dt>“vector”<span class="classifier">np.array of floats with shape (3,)</span></dt><dd><p>direct/diffuse/global (depending on the case)
radiant exposure vector. “vector”[0], “vector”[1]
and “vector”[2], hold the x, y and z components of the
radiant exposure vector, respectively, for all
wavelengths in key “wavelengths”. Each component
has units of Wh/m^2.</p>
</dd>
<dt>“magnitude”<span class="classifier">float</span></dt><dd><p>Magnitude of the direct/diffuse/global (depending on
the case) spectral radiant exposure vector.
It has units of Wh/m^2.</p>
</dd>
<dt>“spectrally_averaged_unit_vector”<span class="classifier">np.array of floats with shape (3,)</span></dt><dd><p>Average position of irradiance within a sky patch. That is,
the unit vector version of the spectrally averaged
direct/diffuse/global (depending on the case) Radiant exposure vector.
In the case, however, that said Spectral radiant exposure
vector is zero, we default to using the unit vector
pointing to the center of the current sky patch.
It is adimensional.</p>
</dd>
</dl>
</div></blockquote>
<p>Finally, in the case of the key “wavelengths”, it does not store any dicts
but rather a numpy.array of float values:</p>
<dl class="simple">
<dt>np.array of floats with shape (122,)</dt><dd><p>Array of wavelengths over which the spectral irradiances are defined.</p>
</dd>
</dl>
</dd>
<dt>self.exposure_vectors<span class="classifier">dict of numpy.arrays</span></dt><dd><p>Dict containing the same info as above, but in another format
that is handier for other things. It has the following
key-value pairs:</p>
<blockquote>
<div><dl class="simple">
<dt>“spectral_direct”<span class="classifier">numpy.array of floats with shape (self.num_divisions, 3, 122)</span></dt><dd><p>Direct spectral radiant exposure vector for each of the sky patches.
It has units of Wh/m^2/nm.</p>
</dd>
<dt>“spectral_direct_mag”<span class="classifier">numpy.array of floats with shape (self.num_divisions, 122)</span></dt><dd><p>Magnitude of the direct spectral radiant exposure vector for each of the sky patches.
It has units of Wh/m^2/nm.</p>
</dd>
<dt>“spectral_direct_unit_savgd”<span class="classifier">numpy.array of floats with shape (self.num_divisions, 3)</span></dt><dd><p>Average position of radiant exposure within a sky patch. That is,
unit vector version of the spectrally averaged spectral direct
(depending on the case) radiant exposure vector.
In the case, however, that said Spectral radiant exposure
vector is zero, we default to using the unit vector
pointing to the center of the current sky patch.
It is adimensional.</p>
</dd>
<dt>“spectral_diffuse”<span class="classifier">numpy.array of floats with shape (self.num_divisions, 3, 122)</span></dt><dd><p>Diffuse spectral radiant exposure vector for each of the sky patches.
It has units of Wh/m^2/nm.</p>
</dd>
<dt>“spectral_diffuse_mag”<span class="classifier">numpy.array of floats with shape (self.num_divisions, 122)</span></dt><dd><p>Magnitude of the diffuse spectral radiant exposure vector for each of the sky patches.
It has units of Wh/m^2/nm.</p>
</dd>
<dt>“spectral_diffuse_unit_savgd”<span class="classifier">numpy.array of floats with shape (self.num_divisions, 3)</span></dt><dd><p>Average position of radiant exposure within a sky patch. That is,
unit vector version of the spectrally averaged spectral diffuse
(depending on the case) radiant exposure vector.
In the case, however, that said Spectral radiant exposure
vector is zero, we default to using the unit vector
pointing to the center of the current sky patch.
It is adimensional.</p>
</dd>
<dt>“spectral_global”<span class="classifier">numpy.array of floats with shape (self.num_divisions, 3, 122)</span></dt><dd><p>Global spectral radiant exposure vector for each of the sky patches.
It has units of Wh/m^2/nm.</p>
</dd>
<dt>“spectral_global_global”<span class="classifier">numpy.array of floats with shape (self.num_divisions, 122)</span></dt><dd><p>Magnitude of the global spectral radiant exposure vector for each of the sky patches.
It has units of Wh/m^2/nm.</p>
</dd>
<dt>“spectral_global_unit_savgd”<span class="classifier">numpy.array of floats with shape (self.num_divisions, 3)</span></dt><dd><p>Average position of radiant exposure within a sky patch. That is,
unit vector version of the spectrally averaged spectral diffuse
(depending on the case) radiant exposure vector.
In the case, however, that said Spectral radiant exposure
vector is zero, we default to using the unit vector
pointing to the center of the current sky patch.
It is adimensional.</p>
</dd>
<dt>“direct”<span class="classifier">numpy.array of floats with shape (self.num_divisions, 3, 122)</span></dt><dd><p>Direct radiant exposure vector for each of the sky patches.
It has units of Wh/m^2.</p>
</dd>
<dt>“direct_mag”<span class="classifier">numpy.array of floats with shape (self.num_divisions, 122)</span></dt><dd><p>Magnitude of the direct radiant exposure vector for each of the sky patches.
It has units of Wh/m^2.</p>
</dd>
<dt>“direct_unit”<span class="classifier">numpy.array of floats with shape (self.num_divisions, 3)</span></dt><dd><p>Average position of radiant exposure within a sky patch. That is,
unit vector version of the spectrally averaged spectral direct
(depending on the case) radiant exposure vector.
In the case, however, that said radiant exposure
vector is zero, we default to using the unit vector
pointing to the center of the current sky patch.
It is adimensional.</p>
</dd>
<dt>“diffuse”<span class="classifier">numpy.array of floats with shape (self.num_divisions, 3, 122)</span></dt><dd><p>Diffuse radiant exposure vector for each of the sky patches.
It has units of Wh/m^2.</p>
</dd>
<dt>“diffuse_mag”<span class="classifier">numpy.array of floats with shape (self.num_divisions, 122)</span></dt><dd><p>Magnitude of the diffuse radiant exposure vector for each of the sky patches.
It has units of Wh/m^2.</p>
</dd>
<dt>“diffuse_unit”<span class="classifier">numpy.array of floats with shape (self.num_divisions, 3)</span></dt><dd><p>Average position of radiant exposure within a sky patch. That is,
unit vector version of the spectrally averaged spectral diffuse
(depending on the case) radiant exposure vector.
In the case, however, that said radiant exposure
vector is zero, we default to using the unit vector
pointing to the center of the current sky patch.
It is adimensional.</p>
</dd>
<dt>“global”<span class="classifier">numpy.array of floats with shape (self.num_divisions, 3, 122)</span></dt><dd><p>Global radiant exposure vector for each of the sky patches.
It has units of Wh/m^2.</p>
</dd>
<dt>“global_mag”<span class="classifier">numpy.array of floats with shape (self.num_divisions, 122)</span></dt><dd><p>Magnitude of the global radiant exposure vector for each of the sky patches.
It has units of Wh/m^2.</p>
</dd>
<dt>“global_unit”<span class="classifier">numpy.array of floats with shape (self.num_divisions, 3)</span></dt><dd><p>Average position of radiant exposure within a sky patch. That is,
unit vector version of the spectrally averaged spectral global
(depending on the case) radiant exposure vector.
In the case, however, that said radiant exposure
vector is zero, we default to using the unit vector
pointing to the center of the current sky patch.
It is adimensional.</p>
</dd>
<dt>“wavelengths”<span class="classifier">np.array of floats with shape (122,)</span></dt><dd><p>Array of wavelengths over which the spectral irradiances
are defined.</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Sky.Sky.compute_optimal_plane_orientation">
<span class="sig-name descname"><span class="pre">compute_optimal_plane_orientation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_res</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">naz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">13</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">absorption_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">component</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'global'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Sky.Sky.compute_optimal_plane_orientation" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the optimal orientation of a plane for maximum absorbed energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>min_res</strong> (<em>float</em><em>, </em><em>optional</em>) – Minimum angular resolution (in degrees) that wants to be achieved during
the optimization process. Default is 0.5.</p></li>
<li><p><strong>naz</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of azimuthal divisions for each iteration. Default is 13.</p></li>
<li><p><strong>nel</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of elevation divisions. Default is 4.</p></li>
<li><p><strong>absorption_func</strong> (<em>int</em><em>, </em><em>float</em><em>, or </em><em>callable</em><em>, </em><em>optional</em>) – The absorption function. If int or float, a constant absorption coefficient is used.
If callable, the function should take an array of arguments representing angle of incidence
and wavelength and return the absorption coefficient. Default is 1.</p></li>
<li><p><strong>component</strong> (<em>{&quot;global&quot;</em><em>, </em><em>&quot;direct&quot;</em><em>, </em><em>&quot;diffuse&quot;}</em><em>, </em><em>optional</em>) – The spectral component to consider. Default is “global”.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>opti_vals</strong> –</p>
<p>A dictionary containing the optimal orientation information:</p>
<blockquote>
<div><ul class="simple">
<li><p>”energy”: Total absorbed incident energy.</p></li>
<li><p>”az”: Optimal azimuth angle in degrees.</p></li>
<li><p>”zen”: Optimal zenith angle in degrees.</p></li>
<li><p>”el”: Optimal elevation angle in degrees.</p></li>
<li><p>”n_uvec”: Normalized unit vector of the optimal orientation.</p></li>
<li><p>”az_res”: Azimuth resolution in degrees.</p></li>
<li><p>”el_res”: Elevation resolution in degrees.</p></li>
</ul>
</div></blockquote>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This method iteratively searches for the optimal plane orientation by dividing the
azimuth and zenith angles into divisions and computing the absorbed energy for each
combination. The resolution is refined until it reaches the specified minimum.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Sky.Sky.compute_radiance_for_a_date">
<span class="sig-name descname"><span class="pre">compute_radiance_for_a_date</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Sky.Sky.compute_radiance_for_a_date" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the radiance for a given date by integrating the (already
computed) spectral radiance over the wavelength axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>None</strong> – </p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Produces</p>
<dl>
<dt>self.radiances<span class="classifier">dict</span></dt><dd><p>Dictionary containing result variables. It has the following Key-Value
pairs:</p>
<blockquote>
<div><dl class="simple">
<dt>“Az”<span class="classifier">float or numpy.array of floats with shape (nel, naz)</span></dt><dd><p>Grid of azimuth coordinates (in degrees) of the sky elements for which the
radiances was calculated. Its values should vary along axis 1.
In any case, all values should be between 0 and 360 (inclusive).</p>
</dd>
<dt>“El”<span class="classifier">float or numpy.array of floats with shape (nel, naz)</span></dt><dd><p>Grid of elevation coordinates (in degrees) of the sky elements for which the
radiances was calculated. Its values should vary along axis 0.
In any case, all values should be between 0 and 90 (inclusive).</p>
</dd>
<dt>“Siv”<span class="classifier">numpy.array of floats with shape (nt,)</span></dt><dd><p>Igawa’s ‘Sky Index’ parameter across time.</p>
</dd>
<dt>“Kc”<span class="classifier">numpy.array of floats with shape (nt,)</span></dt><dd><p>Igawa’s ‘Clear Sky Index’ parameter across time.</p>
</dd>
<dt>“Cle”<span class="classifier">numpy.array of floats with shape (nt,)</span></dt><dd><p>Igawa’s ‘Cloudless Index’ parameter across time.</p>
</dd>
<dt>“wavelengths”<span class="classifier">numpy.array of floats with shape (122,)</span></dt><dd><p>Wavelengths in nanometers.</p>
</dd>
<dt>“DatetimeIndex_obj”<span class="classifier">pandas.Series of pandas.Timestamp objects.</span></dt><dd><p>Series of Timestamp values detailing the times at which each of the
samples of the time-dependent variables were taken. We denote its
length as nt.</p>
</dd>
<dt>“spectral_direct”<span class="classifier">List with length nt of numpy.arrays of floats with shape (nel,naz,122)</span></dt><dd><p>Direct component of spectral radiance across time. It has
units of W/m^2/sr/nm.</p>
</dd>
<dt>“spectral_diffuse”<span class="classifier">List with length nt of numpy.arrays of floats with shape (nel,naz,122)</span></dt><dd><p>Diffuse component of spectral radiance across time. It has
units of W/m^2/sr/nm.</p>
</dd>
<dt>“direct”<span class="classifier">numpy.array of floats with shape (nel,naz,nt)</span></dt><dd><p>Direct component of radiance across time. It has units
of W/m^2/sr.</p>
</dd>
<dt>“diffuse”<span class="classifier">numpy.array of floats with shape (nel,naz,nt)</span></dt><dd><p>Diffuse component of radiance across time. It has units
of W/m^2/sr.</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<ol class="arabic simple">
<li><p>This method requires the attribute <em>self.radiances</em> to
already be defined. For this, please check out
<a class="reference internal" href="#solrad.Sky.Sky.compute_spectral_radiance_for_a_date" title="solrad.Sky.Sky.compute_spectral_radiance_for_a_date"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_spectral_radiance_for_a_date()</span></code></a>.</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Sky.Sky.compute_radiances_for_a_date">
<span class="sig-name descname"><span class="pre">compute_radiances_for_a_date</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">year</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">month</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">day</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">46</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">naz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">181</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">150</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_site_horizon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Sky.Sky.compute_radiances_for_a_date" title="Permalink to this definition">#</a></dt>
<dd><p>Compute radiance and spectral radiance across time for a complete day on a specific
date, using the data stored in the <em>self.Site_obj</em> attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>year</strong> (<em>int</em>) – Year for which the spectral radiance is to be computed. Must be
present in ‘self.Site_obj.simulation_times_data’.</p></li>
<li><p><strong>month</strong> (<em>int</em>) – Month for which the spectral radiance is to be computed. Must be
present in ‘self.Site_obj.simulation_times_data’.</p></li>
<li><p><strong>day</strong> (<em>int</em>) – Day for which the spectral radiance is to be computed. Must be
present in ‘self.Site_obj.simulation_times_data’.</p></li>
<li><p><strong>nel</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of samples for dicretizing the sky vault with regards to
the elevation coordinate. Default is 46.</p></li>
<li><p><strong>naz</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of samples for dicretizing the sky vault with regards to
the azimuth coordinate. Default is 181.</p></li>
<li><p><strong>num_iterations</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of iterations to use when filling NaN data. Default is 150.</p></li>
<li><p><strong>use_site_horizon</strong> (<em>bool</em>) – Include horizon effects. Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Produces</p>
<dl>
<dt>self.radiances<span class="classifier">dict</span></dt><dd><p>Dictionary containing result variables. It has the following Key-Value
pairs:</p>
<blockquote>
<div><dl class="simple">
<dt>“Az”<span class="classifier">float or numpy.array of floats with shape (nel, naz)</span></dt><dd><p>Grid of azimuth coordinates (in degrees) of the sky elements for which the
radiances was calculated. Its values should vary along axis 1.
In any case, all values should be between 0 and 360 (inclusive).</p>
</dd>
<dt>“El”<span class="classifier">float or numpy.array of floats with shape (nel, naz)</span></dt><dd><p>Grid of elevation coordinates (in degrees) of the sky elements for which the
radiances was calculated. Its values should vary along axis 0.
In any case, all values should be between 0 and 90 (inclusive).</p>
</dd>
<dt>“Siv”<span class="classifier">numpy.array of floats with shape (nt,)</span></dt><dd><p>Igawa’s ‘Sky Index’ parameter across time.</p>
</dd>
<dt>“Kc”<span class="classifier">numpy.array of floats with shape (nt,)</span></dt><dd><p>Igawa’s ‘Clear Sky Index’ parameter across time.</p>
</dd>
<dt>“Cle”<span class="classifier">numpy.array of floats with shape (nt,)</span></dt><dd><p>Igawa’s ‘Cloudless Index’ parameter across time.</p>
</dd>
<dt>“wavelengths”<span class="classifier">numpy.array of floats with shape (122,)</span></dt><dd><p>Wavelengths in nanometers.</p>
</dd>
<dt>“DatetimeIndex_obj”<span class="classifier">pandas.Series of pandas.Timestamp objects.</span></dt><dd><p>Series of Timestamp values detailing the times at which each of the
samples of the time-dependent variables were taken. We denote its
length as nt.</p>
</dd>
<dt>“spectral_direct”<span class="classifier">List with length nt of numpy.arrays of floats with shape (nel,naz,122)</span></dt><dd><p>Direct component of spectral radiance across time. It has
units of W/m^2/sr/nm.</p>
</dd>
<dt>“spectral_diffuse”<span class="classifier">List with length nt of numpy.arrays of floats with shape (nel,naz,122)</span></dt><dd><p>Diffuse component of spectral radiance across time. It has
units of W/m^2/sr/nm.</p>
</dd>
<dt>“direct”<span class="classifier">numpy.array of floats with shape (nel,naz,nt)</span></dt><dd><p>Direct component of radiance across time. It has units
of W/m^2/sr.</p>
</dd>
<dt>“diffuse”<span class="classifier">numpy.array of floats with shape (nel,naz,nt)</span></dt><dd><p>Diffuse component of radiance across time. It has units
of W/m^2/sr.</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Sky.Sky.compute_spectral_radiance_for_a_date">
<span class="sig-name descname"><span class="pre">compute_spectral_radiance_for_a_date</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">year</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">month</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">day</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">46</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">naz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">181</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">150</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_site_horizon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Sky.Sky.compute_spectral_radiance_for_a_date" title="Permalink to this definition">#</a></dt>
<dd><p>Compute spectral radiance across time for a complete day on a specific
date, using the data stored in the <em>self.Site_obj</em> attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>year</strong> (<em>int</em>) – Year for which the spectral radiance is to be computed. Must be
present in ‘self.Site_obj.simulation_times_data’.</p></li>
<li><p><strong>month</strong> (<em>int</em>) – Month for which the spectral radiance is to be computed. Must be
present in ‘self.Site_obj.simulation_times_data’.</p></li>
<li><p><strong>day</strong> (<em>int</em>) – Day for which the spectral radiance is to be computed. Must be
present in ‘self.Site_obj.simulation_times_data’.</p></li>
<li><p><strong>nel</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of samples for dicretizing the sky vault with regards to
the elevation coordinate. Default is 46.</p></li>
<li><p><strong>naz</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of samples for dicretizing the sky vault with regards to
the azimuth coordinate. Default is 181.</p></li>
<li><p><strong>num_iterations</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of iterations to use when filling NaN data. Default is 150.</p></li>
<li><p><strong>use_site_horizon</strong> (<em>bool</em>) – Include horizon effects. Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Produces</p>
<dl>
<dt>self.radiances<span class="classifier">dict</span></dt><dd><p>Dictionary containing result variables. It has the following Key-Value
pairs:</p>
<blockquote>
<div><dl class="simple">
<dt>“Az”<span class="classifier">float or numpy.array of floats with shape (nel, naz)</span></dt><dd><p>Grid of azimuth coordinates (in degrees) of the sky elements for which the
spectral radiances was calculated. Its values should vary along axis 1.
In any case, all values should be between 0 and 360 (inclusive).</p>
</dd>
<dt>“El”<span class="classifier">float or numpy.array of floats with shape (nel, naz)</span></dt><dd><p>Grid of elevation coordinates (in degrees) of the sky elements for which the
spectral radiances was calculated. Its values should vary along axis 0.
In any case, all values should be between 0 and 90 (inclusive).</p>
</dd>
<dt>“Siv”<span class="classifier">numpy.array of floats with shape (nt,)</span></dt><dd><p>Igawa’s ‘Sky Index’ parameter across time.</p>
</dd>
<dt>“Kc”<span class="classifier">numpy.array of floats with shape (nt,)</span></dt><dd><p>Igawa’s ‘Clear Sky Index’ parameter across time.</p>
</dd>
<dt>“Cle”<span class="classifier">numpy.array of floats with shape (nt,)</span></dt><dd><p>Igawa’s ‘Cloudless Index’ parameter across time.</p>
</dd>
<dt>“wavelengths”<span class="classifier">numpy.array of floats with shape (122,)</span></dt><dd><p>Wavelengths in nanometers.</p>
</dd>
<dt>“DatetimeIndex_obj”<span class="classifier">pandas.Series of pandas.Timestamp objects.</span></dt><dd><p>Series of Timestamp values detailing the times at which each of the
samples of the time-dependent variables were taken. We denote its
length as nt.</p>
</dd>
<dt>“spectral_direct”<span class="classifier">List with length nt of numpy.arrays of floats with shape (nel,naz,122)</span></dt><dd><p>Direct component of spectral radiance across time. It has
units of W/m^2/sr/nm.</p>
</dd>
<dt>“spectral_diffuse”<span class="classifier">List with length nt of numpy.arrays of floats with shape (nel,naz,122)</span></dt><dd><p>Diffuse component of spectral radiance across time. It has
units of W/m^2/sr/nm.</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>1) Initial time and final time of simulation are taken to be
<em>self.Site_obj_simulation_time_data[(year, month, day)][0]</em> and
<em>self.Site_obj_simulation_time_data[(year, month, day)][-1]</em> (respectively).</p>
<ol class="arabic simple" start="2">
<li><p>Angular resolution in the Elevation coordinate is equal to 90/(nel - 1).</p></li>
<li><p>Angular resolution in the Azimuth coordinate is equal to 360/(naz - 1).</p></li>
</ol>
<p>4) The time resolution used is the same as that of
<em>self.Site_obj.simulation_times_data</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Sky.Sky.discretise">
<span class="sig-name descname"><span class="pre">discretise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_divisions</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Sky.Sky.discretise" title="Permalink to this definition">#</a></dt>
<dd><p>Discretise the Sky Vault into non-congruent square-like patches of
similar area, according to the procedure proposed in the paper “A
general rule for disk and hemisphere partition into equal-area cells”
(see reference [1]).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>num_divisions</strong> (<em>int</em>) – Number of patches into which the Sky Vault will be discretised.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Produces</p>
<dl>
<dt>self.zone_data<span class="classifier">dict of dicts</span></dt><dd><p>Dictionary containing information about the discretization zones.
Each key of <em>self.zone_data</em> corresponds to a unique zone number.
The component dictionaries (stored at <em>self.zone_data[zone_num]</em>)
have the following Key-Value pairs:</p>
<blockquote>
<div><dl class="simple">
<dt>“num_patches”<span class="classifier">int</span></dt><dd><p>Number of sky patches contained inside the sky zone.</p>
</dd>
<dt>“inf_zen”<span class="classifier">float</span></dt><dd><p>Inferior zenith angle bound delimiting the sky zone,
in degrees.</p>
</dd>
<dt>“sup_zen”<span class="classifier">float</span></dt><dd><p>Superior zenith angle bound delimiting the sky zone,
in degrees.</p>
</dd>
<dt>“inf_rad”<span class="classifier">float</span></dt><dd><p>Inferior radius bound delimiting the sky zone’s plane
projection [adm].</p>
</dd>
<dt>“sup_rad”<span class="classifier">float</span></dt><dd><p>Superior radius bound delimiting the sky zone’s plane
projection [adm].</p>
</dd>
<dt>“azimuths”<span class="classifier">numpy.array of floats</span></dt><dd><p>Array containing the azimuth angle intervals delimiting
each sky patch inside the zone, in degrees.</p>
</dd>
<dt>“patch_area”<span class="classifier">float</span></dt><dd><p>Solid angle/area, taken up by each sky patch inside the
sky zone, in steradians.</p>
</dd>
<dt>“zone_area”<span class="classifier">float</span></dt><dd><p>Total solid angle/area of the whole sky zone, in steradians.</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>self.patch_data<span class="classifier">dict of dicts</span></dt><dd><p>Dictionary containing information about the discretization patches.
Each key of <em>self.patch_data</em> is a 2-tuple of ints corresponding to
the patch (zone number, local patch number). The component dictionaries
(stored at <em>self.patch_data[(zone_num, local_patch_num)]</em>) have the
following Key-Value pairs:</p>
<blockquote>
<div><dl class="simple">
<dt>“inf_zen”<span class="classifier">float</span></dt><dd><p>Inferior zenith angle bound delimiting the sky patch,
in degrees.</p>
</dd>
<dt>“sup_zen”<span class="classifier">float</span></dt><dd><p>Superior zenith angle bound delimiting the sky patch,
in degrees.</p>
</dd>
<dt>“inf_az”<span class="classifier">float</span></dt><dd><p>Inferior azimuth angle bound delimiting the sky patch,
in degrees.</p>
</dd>
<dt>“sup_az”<span class="classifier">float</span></dt><dd><p>Superior azimuth angle bound delimiting the sky patch,
in degrees.</p>
</dd>
<dt>“patch_area”<span class="classifier">float</span></dt><dd><p>Solid angle/area, taken up by the sky patch, in steradians.</p>
</dd>
<dt>“unit_vector”<span class="classifier">np.array of floats with shape (3,)</span></dt><dd><p>Unit solid angle vector of the center of the sky patch.
It is basically a unit vector with tail at the origin and
which points to the center position of the sky patch.
“unit_vector”[i], with i = 0,1,2; gives the unit vector’s
x,y,z component respecitvely.</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Doing calling this method after initialization will also errase all other radiation quantities
computed up to that point.</p>
<p class="rubric">References</p>
<p>[1] Benoit Beckers, Pierre Beckers, A general rule for disk and hemisphere partition into equal-area cells,
Computational Geometry, Volume 45, Issue 7, 2012, Pages 275-283, ISSN 0925-7721, <a class="reference external" href="https://doi.org/10.1016/j.comgeo.2012.01.011">https://doi.org/10.1016/j.comgeo.2012.01.011</a>.
(<a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0925772112000296">https://www.sciencedirect.com/science/article/pii/S0925772112000296</a>)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Sky.Sky.disk_point_to_zone_patch">
<span class="sig-name descname"><span class="pre">disk_point_to_zone_patch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">az</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Sky.Sky.disk_point_to_zone_patch" title="Permalink to this definition">#</a></dt>
<dd><p>Bin disk point into the correct sky patch. That is, given a disk point
represented by a tuple of (radius, azimuth) values, return the sky patch,
represented by a tuple of (zone_num, local_patch_num), to which said
disk point belongs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rad</strong> (<em>float</em>) – Radius of disk point [adm]. Must be between 0 and 1.</p></li>
<li><p><strong>az</strong> (<em>float</em>) – Azimuth of disk point in degrees. Must be between 0 and 360.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>zone_num</strong> (<em>int</em>) – Sky zone to which the disk point belongs.</p></li>
<li><p><strong>local_patch_num</strong> (<em>int</em>) – Sky patch (int) (identified by its local patch number in reference
to the sky zone) to which the disk point belongs, or “not found”
if search failed.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Sky.Sky.plot_disk_patches">
<span class="sig-name descname"><span class="pre">plot_disk_patches</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(12,</span> <span class="pre">12)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Sky.Sky.plot_disk_patches" title="Permalink to this definition">#</a></dt>
<dd><p>Visualize discretized Sky Vault in 2D.</p>
<section id="paramters">
<h3>Paramters<a class="headerlink" href="#paramters" title="Permalink to this heading">#</a></h3>
<dl class="simple">
<dt>figsize<span class="classifier">2-tuple of int</span></dt><dd><p>Size of figure.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>1) This method requires that the sky-vault already be discretised
to be calculated. Check out <a class="reference internal" href="#solrad.Sky.Sky.discretise" title="solrad.Sky.Sky.discretise"><code class="xref py py-meth docutils literal notranslate"><span class="pre">discretise()</span></code></a></p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Sky.Sky.plot_exposures">
<span class="sig-name descname"><span class="pre">plot_exposures</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">config</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Sky.Sky.plot_exposures" title="Permalink to this definition">#</a></dt>
<dd><p>Plot radiant exposures.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>config</strong> (<em>dict</em><em> or </em><em>None</em>) – <p>Dict of plot configuration options. If None (the default), it uses
the default confifuration plot options. If dict, it should include
one or more of the following key-value pairs:</p>
<blockquote>
<div><dl class="simple">
<dt>“projection”<span class="classifier">{‘disk’, ‘sphere’}, optional</span></dt><dd><p>Type of plot projection. Supported are: “disk” The
plots the radiant exposure in a 2D plot,
while the second uses a 3D plot. Default is “disk”.</p>
</dd>
<dt>”mode”<span class="classifier">{‘direct’, ‘diffuse’, ‘global’}, optional</span></dt><dd><p>Component of radiant exposure to plot. Default is ‘global’.</p>
</dd>
<dt>”figsize”<span class="classifier">2-tuple of int</span></dt><dd><p>Figure size. Default is (13,13).</p>
</dd>
<dt>”unit”<span class="classifier">{“Wh/m^2”, “kWh/m^2”, “kJ/m^2”, “MJ/m^2}</span></dt><dd><p>Units with which to display the radiant exposure.
In order, these mean: ‘Watt-hours per meter squared’,
‘kilo Watt-hours per meter squared’, ‘kilo Joules per meter squared’,
and ‘Mega Joules per meter squared’. Default is “Wh/m^2”.</p>
</dd>
<dt>”n”<span class="classifier">int</span></dt><dd><p>Number of samples per axis to use for plot. A greater number
means a more detailed plot (i.e, greater resolution) but it is
resource intensive. Default is 1000.</p>
</dd>
<dt>”view”<span class="classifier">2-tuple of int</span></dt><dd><p>Elevation, azimuth of plot camara in degrees. It applies
only for “sphere” plot. Default is (45, 120).</p>
</dd>
</dl>
</div></blockquote>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Produces</p>
<p>None</p>
<p class="rubric">Notes</p>
<p>1) This method requires the radiant exposure vectors
to be calculated. Check out <a class="reference internal" href="#solrad.Sky.Sky.compute_exposure_vectors_for_a_date_interval" title="solrad.Sky.Sky.compute_exposure_vectors_for_a_date_interval"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_exposure_vectors_for_a_date_interval()</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Sky.Sky.plot_radiance_for_a_date">
<span class="sig-name descname"><span class="pre">plot_radiance_for_a_date</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">component</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'disk'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(16,</span> <span class="pre">12)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">view_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(45,</span> <span class="pre">180)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Sky.Sky.plot_radiance_for_a_date" title="Permalink to this definition">#</a></dt>
<dd><p>Plot radiance for a specific component at a given time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>component</strong> (<em>str</em>) – The radiance component to plot (e.g., “direct”, “diffuse”).</p></li>
<li><p><strong>nt</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – The time index for which to plot the radiance. If None, plots for all times.</p></li>
<li><p><strong>projection</strong> (<em>{'disk'</em><em>, </em><em>'sphere'}</em><em>, </em><em>optional</em>) – The type of projection for the plot. Options are “disk” (polar) or “sphere” (3D). Default is “disk”.</p></li>
<li><p><strong>figsize</strong> (<em>tuple</em><em>, </em><em>optional</em>) – Figure size. Default is (16, 12).</p></li>
<li><p><strong>view_init</strong> (<em>tuple</em><em>, </em><em>optional</em>) – Elevation and azimuth of the axes in degrees. Default is (45, 180).</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>1) This method requires the attribute <em>self.radiances</em> to
already be defined. For this, please check out
<a class="reference internal" href="#solrad.Sky.Sky.compute_radiances_for_a_date" title="solrad.Sky.Sky.compute_radiances_for_a_date"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_radiances_for_a_date()</span></code></a>.</p>
<p>2) The method generates plots of radiance for the specified component at the given time.
It supports two types of projections: “disk” (polar plot) and “sphere” (3D plot).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Sky.Sky.plot_spectral_radiance_for_a_date">
<span class="sig-name descname"><span class="pre">plot_spectral_radiance_for_a_date</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">component</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">config</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Sky.Sky.plot_spectral_radiance_for_a_date" title="Permalink to this definition">#</a></dt>
<dd><p>Plot spectral radiance for a specific component at a given time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>component</strong> (<em>{'direct'</em><em>, </em><em>'diffuse}</em>) – The component spectral radiance to plot.</p></li>
<li><p><strong>nt</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – The time index for which to plot the spectral radiance. If None, plots for all times.</p></li>
<li><p><strong>config</strong> (<em>dict</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – <p>Configuration parameters for the plot. If None (the default), it uses
default parameters. If provided, it may contain the following
key-value pairs:</p>
<dl class="simple">
<dt>‘figsize’: tuple, optional, default: (16, 12)</dt><dd><p>Figure size.</p>
</dd>
<dt>’wavelength_idxs’: numpy.ndarray, optional</dt><dd><p>2D array specifying the wavelength indices to plot.</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>1) This method requires the attribute <em>self.radiances</em> to
already be defined. For this, please check out
<a class="reference internal" href="#solrad.Sky.Sky.compute_radiances_for_a_date" title="solrad.Sky.Sky.compute_radiances_for_a_date"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_radiances_for_a_date()</span></code></a>.</p>
<p>2) The method generates polar plots of spectral radiance for the specified component at the given time.
The plots show color-contoured radiance values at different azimuth and elevation angles.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Sky.Sky.plot_sphere_patches">
<span class="sig-name descname"><span class="pre">plot_sphere_patches</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(12,</span> <span class="pre">12)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis_view</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(25,</span> <span class="pre">30)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Sky.Sky.plot_sphere_patches" title="Permalink to this definition">#</a></dt>
<dd><p>Visualize discretized Sky Vault in 3D.</p>
<section id="id1">
<h3>Paramters<a class="headerlink" href="#id1" title="Permalink to this heading">#</a></h3>
<dl class="simple">
<dt>figsize<span class="classifier">2-tuple of int</span></dt><dd><p>Size of figure.</p>
</dd>
<dt>axis_view = 2-tuple of int</dt><dd><p>Plot’s elevation, azimuth in degrees.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>1) This method requires that the sky-vault already be discretised
to be calculated. Check out <a class="reference internal" href="#solrad.Sky.Sky.discretise" title="solrad.Sky.Sky.discretise"><code class="xref py py-meth docutils literal notranslate"><span class="pre">discretise()</span></code></a></p>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Sky.Sky.rad_to_zone">
<span class="sig-name descname"><span class="pre">rad_to_zone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Sky.Sky.rad_to_zone" title="Permalink to this definition">#</a></dt>
<dd><p>Bin radius value into the correct sky zone via binary search.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rad</strong> (<em>float</em>) – radius value [adm]. Must be between 0 and 1.</p></li>
<li><p><strong>start</strong> (<em>int</em><em> or </em><em>None</em>) – Lower search bound for zone. If None, it defaults to the lowest
bound possible.</p></li>
<li><p><strong>end</strong> (<em>int</em><em> or </em><em>None</em>) – Upper search bound for zone. If None, it defaults to the highest
bound possible.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>zone_num</strong> – Sky zone (int) to which the radius coordinate belongs, or “not found”
if search failed.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Sky.Sky.sky_point_to_zone_patch">
<span class="sig-name descname"><span class="pre">sky_point_to_zone_patch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zen</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">az</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Sky.Sky.sky_point_to_zone_patch" title="Permalink to this definition">#</a></dt>
<dd><p>Bin sky point into the correct sky patch. That is, given a sky point
represented by a tuple of (zenith, azimuth) values, return the sky patch,
represented by a tuple of (zone_num, local_patch_num), to which said
sky point belongs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>zen</strong> (<em>float</em>) – Zenith of sky point in degrees. Must be between 0 and 90.</p></li>
<li><p><strong>az</strong> (<em>float</em>) – Azimuth of sky point in degrees. Must be between 0 and 360.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>zone_num</strong> (<em>int or str</em>) – Sky zone (int) to which the sky point belongs, or “not found” if
search failed.</p></li>
<li><p><strong>local_patch_num</strong> (<em>int or str</em>) – Sky patch (int) (identified by its local patch number in reference
to the sky zone) to which the sky point belongs, or “not found” if
search failed.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="solrad.Sky.Sky.zenith_to_zone">
<span class="sig-name descname"><span class="pre">zenith_to_zone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zen</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.Sky.Sky.zenith_to_zone" title="Permalink to this definition">#</a></dt>
<dd><p>Bin zenith value into the correct sky zone via binary search.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>zen</strong> (<em>float</em>) – Zenith value in degrees. Must be between 0 and 90.</p></li>
<li><p><strong>start</strong> (<em>int</em><em> or </em><em>None</em>) – Lower search bound for zone. If None, it defaults to the lowest
bound possible.</p></li>
<li><p><strong>end</strong> (<em>int</em><em> or </em><em>None</em>) – Upper search bound for zone. If None, it defaults to the highest
bound possible.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>zone_num</strong> – Sky zone (int) to which the zenith coordinate belongs, or “not found”
if search failed.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int or str</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-solrad.auxiliary_funcs">
<span id="solrad-auxiliary-funcs-module"></span><h2>solrad.auxiliary_funcs module<a class="headerlink" href="#module-solrad.auxiliary_funcs" title="Permalink to this heading">#</a></h2>
<p>Simple module for containing auxiliary functions that are commonly used in
other modules.</p>
<dl class="py function">
<dt class="sig sig-object py" id="solrad.auxiliary_funcs.fill_CDS_globe_nans_using_laplace">
<span class="sig-prename descclassname"><span class="pre">solrad.auxiliary_funcs.</span></span><span class="sig-name descname"><span class="pre">fill_CDS_globe_nans_using_laplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.auxiliary_funcs.fill_CDS_globe_nans_using_laplace" title="Permalink to this definition">#</a></dt>
<dd><p>Depending on the specific database used, some files downloaded from the
Climate Data Store (CDS) may contain missing values. This is a problem
as the NaN values complicate the computation of other relevant quantities,
as well as the easy interpolation of the desired dataset via scipy’s
RegularGridInterpolator function, which is something crucial for
later on procedures. This function attempts to solve this problem
by filling the missing values with the average of their neighbours,
iteratively. The process, broadly speaking, is:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Store the indices of all nan values of the input array.</p></li>
<li><p>Make a copy of the array.</p></li>
<li><p>Fill all nan values with zeros in the copied array.</p></li>
<li><p>Loop over all the elements of the copied array that used to be NaN
values and set the value of each element equal to the average of the
values of its neighbours. Do this as many times as required to
achieve the desired level of convergence.</p></li>
</ol>
</div></blockquote>
<p>Some specific, yet important, things to note are:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Updated values of an element x during iteration i should not be
accesible to other elements until iteration i is finished. That is,
the new/updated value of element x should not be used in the
computation of the new value of element y, until the next iteration;
as such, during the same iteration, element y’s new value is computed
using the un-updated value of element x.</p></li>
<li><p>This code is intended to only be used on arrays which store a scalar
quantity over the whole globe. This is because the boundary
conditions used here are that of the surface of a sphere (see
the ‘Notes’ section.).</p></li>
</ol>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data</strong> (<em>2D numpy.array</em><em> of </em><em>floats</em>) – Array of scalar data with NaN values sprinkled throughout. The array
should contain values corresponding to the whole globe, with the
axis 0, accounting for the variation of said values with respect to the
latitude, while the axis 1 accounts for the variation with respect to
the longitude. Axes 0 and 1 must have the same constant spacing, meaning
that axis 1 should be twice the length of axis 0. That is, <em>data</em> must
be defined over an equally-spaced regular rectangular grid of
latitude vs longitude. Finally, regarding the coordinate system: let
<em>data</em> be a Nx2N numpy.array of floats. Then <code class="docutils literal notranslate"><span class="pre">data[0,:]</span></code> is the
circle of constant latitude equal to -90° (i.e, the geographic south
pole), <code class="docutils literal notranslate"><span class="pre">data[-1,:]</span></code> is the circle of constant latitude equal to 90°
(i.e, the geographic north pole), <code class="docutils literal notranslate"><span class="pre">data[:,0]</span></code> is the arc of constant
longitude equal to -180° and <code class="docutils literal notranslate"><span class="pre">data[:,-1]</span></code> is the arc of constant
longitude equal to 180°.</p>
</dd>
</dl>
<dl class="simple">
<dt>iterations: int</dt><dd><p>Number of iterations that the code should perform before stopping (must
be non-negative). The greater the number of iterations, the greater
the chance that convergence has been reached. However, the time of
computation also increases. Default is 20000.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>new_data</strong> – Array of scalar data with the NaN values having been filled with
numerical values based on the average value of their non-NaN
neighbours, as per the procedure explained above.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>2D numpy.array of floats</p>
</dd>
<dt class="field-odd">Warns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>1) Warning</strong> – “WARNING: Length of axis 1 is not equal to 2 times the length
of axis 0. This function requires for the data to
be equally spaced and encompass the whole earth.
That is only possible if <code class="docutils literal notranslate"><span class="pre">data.shape[1]</span> <span class="pre">==</span> <span class="pre">2*data.shape[0]</span></code>.
If these conditions are not satisfied, results may be incorrect or misleading.”</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ol class="arabic">
<li><p>This function is equivalent to discretely solving laplace’s equation on
the surface of a sphere. In this case, the domain of solution are the
NaN filled elements, while the boundary conditions are given by all
the non-NaN values.</p></li>
<li><p>Since we are operating on the surface of a sphere, two additional
particular boundary conditions should be satisfied:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>The values of the array should ‘wrap’ along the longitudinal
direction. That is, for an infinitely fine mesh: <code class="docutils literal notranslate"><span class="pre">data[i,0]</span> <span class="pre">==</span>
<span class="pre">data[i,-1]</span></code>, for all i.</p></li>
<li><p>The values of the array at the each geographic pole should be
the same for all longitudes. That is, for an infinitely fine mesh:
<code class="docutils literal notranslate"><span class="pre">data[0,:]</span> <span class="pre">and</span> <span class="pre">data[-1,:]</span></code> are constant arrays.</p></li>
</ol>
</div></blockquote>
<p>However, for finitely fine meshes we implement these conditions slightly
differently. The way it is done is on how we compute the averages. Namely:
<code class="docutils literal notranslate"><span class="pre">data[i,j]</span> <span class="pre">=</span> <span class="pre">0.25*(</span> <span class="pre">data[i-1,j]</span> <span class="pre">+</span> <span class="pre">data[i+1,j]</span> <span class="pre">+</span> <span class="pre">data[i,j-1]</span> <span class="pre">+</span>
<span class="pre">data[i,j+1]</span> <span class="pre">)</span></code>, for most cases. But when:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">j</span> <span class="pre">=</span>&#160; <span class="pre">0,</span>&#160; <span class="pre">data[i,j-1]</span></code> equals <code class="docutils literal notranslate"><span class="pre">data[i,</span> <span class="pre">-1]</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">j</span> <span class="pre">=</span> <span class="pre">-1,</span>&#160; <span class="pre">data[i,j+1]</span></code> equals <code class="docutils literal notranslate"><span class="pre">data[i,</span> <span class="pre">0]</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">0,</span>&#160;&#160; <span class="pre">data[i-1,j]</span></code> equals <code class="docutils literal notranslate"><span class="pre">data[0,</span> <span class="pre">bcj]</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">-1,</span>&#160; <span class="pre">data[i+1,j]</span></code> equals <code class="docutils literal notranslate"><span class="pre">data[-1,</span> <span class="pre">bcj]</span></code></p></li>
</ol>
</div></blockquote>
</li>
</ol>
<p>Where bcj is and index such that <code class="docutils literal notranslate"><span class="pre">lon[bcj]</span> <span class="pre">==</span> <span class="pre">lon[j]</span> <span class="pre">+</span> <span class="pre">180</span></code>,  if <code class="docutils literal notranslate"><span class="pre">lon[j]</span> <span class="pre">&lt;</span> <span class="pre">0</span> <span class="pre">and</span>
<span class="pre">lon[bcj]</span> <span class="pre">==</span> <span class="pre">lon[j]</span> <span class="pre">-</span> <span class="pre">180</span></code>,  <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">lon[j]</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code>. Where
<code class="docutils literal notranslate"><span class="pre">lon</span> <span class="pre">=</span> <span class="pre">numpy.linspace(-180,</span> <span class="pre">180,</span> <span class="pre">data.shape[1])</span></code></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="solrad.auxiliary_funcs.fill_nans_using_laplace_1D">
<span class="sig-prename descclassname"><span class="pre">solrad.auxiliary_funcs.</span></span><span class="sig-name descname"><span class="pre">fill_nans_using_laplace_1D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.auxiliary_funcs.fill_nans_using_laplace_1D" title="Permalink to this definition">#</a></dt>
<dd><p>Fill NaN values of a flat numpy.array using the average value of its
non-NaN neighbours. This procedure is iterative and, as such, the
function performs the averaging until the specified number of iterations
is reached.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr</strong> (<em>numpy.array</em><em> of </em><em>floats</em>) – Array of scalar data with NaN values sprinkled throughout.</p></li>
<li><p><strong>iterations</strong> (<em>int</em>) – Number of iterations that the code should perform before stopping (must
be non-negative). The greater the number of iterations, the greater
the chance that convergence has been reached. However, the time of
computation also increases. Default is 500.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>filled_nans_arr</strong> – Array of scalar data with NaN values having been filled using the
the average of their non-NaN neighbours.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.array of floats</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ol class="arabic simple">
<li><p>This procedure is very similar to discretely solving the 1D version of
laplace’s equation. In this case, the domain of solution are the
NaN filled elements, while the boundary conditions are given by the
neighbouring non-NaN values. The boundary conditions here would be, more
or less, zero outward-flux at the endpoints. Although, to be honest, the
code takes inspiration from the laplace procedure and is not too
mathematically rigorous.</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="solrad.auxiliary_funcs.load_obj_with_pickle">
<span class="sig-prename descclassname"><span class="pre">solrad.auxiliary_funcs.</span></span><span class="sig-name descname"><span class="pre">load_obj_with_pickle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.auxiliary_funcs.load_obj_with_pickle" title="Permalink to this definition">#</a></dt>
<dd><p>Load any Class instance saved with pickle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>path</strong> (<em>path-str</em>) – Path of the .pkl file corresponding to Class obj that is to be loaded.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>class_obj</strong> – Class instance/object loaded using pickle.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Class obj.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="solrad.auxiliary_funcs.save_obj_with_pickle">
<span class="sig-prename descclassname"><span class="pre">solrad.auxiliary_funcs.</span></span><span class="sig-name descname"><span class="pre">save_obj_with_pickle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">class_obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.auxiliary_funcs.save_obj_with_pickle" title="Permalink to this definition">#</a></dt>
<dd><p>Save any Class instance using pickle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>class_obj</strong> (<em>Class obj.</em>) – Class instance/object to save using pickle.</p></li>
<li><p><strong>path</strong> (<em>path-str</em>) – Path of the .pkl file corresponding to Class obj that is to be saved.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-solrad.geotime">
<span id="solrad-geotime-module"></span><h2>solrad.geotime module<a class="headerlink" href="#module-solrad.geotime" title="Permalink to this heading">#</a></h2>
<p>This is a module containing functions, methods and classes related to the
computation of time and date quantities.</p>
<dl class="py function">
<dt class="sig sig-object py" id="solrad.geotime.compute_sunrise_sunset">
<span class="sig-prename descclassname"><span class="pre">solrad.geotime.</span></span><span class="sig-name descname"><span class="pre">compute_sunrise_sunset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">latitude</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">longitude</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.geotime.compute_sunrise_sunset" title="Permalink to this definition">#</a></dt>
<dd><p>Compute sunrise and sunset times for a given location and time period, mainly using the NREL SPA algorithm [1].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>latitude</strong> (<em>float</em>) – The latitude of the location in degrees. Must be a number between -90 and 90.</p></li>
<li><p><strong>longitude</strong> (<em>float</em>) – The longitude of the location in degrees. Must be a number between -180 and 180.</p></li>
<li><p><strong>tz</strong> (<em>str</em>) – Timezone information of the location in the format of +/-HHMM.</p></li>
<li><p><strong>start</strong> (<em>str</em><em> or </em><em>pandas.DatetimeIndex</em>) – The starting date or datetime index for which to compute sunrise and sunset times.
If providing a string, it should be in the format ‘YYYY-MM-DD’.</p></li>
<li><p><strong>end</strong> (<em>None</em><em> or </em><em>str</em><em>, </em><em>default is None</em>) – If providing a string, it is ending date for which to compute sunrise and sunset times (in the format ‘YYYY-MM-DD’)
and can only be used if ‘start’ is also a string. If None, only the sunrise and sunset times for the start date will be computed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A DataFrame containing the computed sunrise, sunset, and day duration times for the specified location and time period.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandas.DataFrame</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Return DataFrame with computed sunrise and sunset times (using local time) from January 1st 2023, to January 10th 2023, for the city of Medellín, Colombia</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compute_sunrise_sunset</span><span class="p">(</span><span class="mf">6.25184</span><span class="p">,</span> <span class="o">-</span><span class="mf">75.56359</span><span class="p">,</span> <span class="s1">&#39;-05:00&#39;</span><span class="p">,</span> <span class="s1">&#39;2023-01-01&#39;</span><span class="p">,</span> <span class="s1">&#39;2023-01-10&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Return DataFrame with computed sunrise and sunset times (using local time) for June 1st 2023, for the city of Sydney, Australia.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compute_sunrise_sunset</span><span class="p">(</span><span class="o">-</span><span class="mf">33.86785</span><span class="p">,</span> <span class="mf">151.20732</span><span class="p">,</span> <span class="s1">&#39;+11:00&#39;</span><span class="p">,</span> <span class="s1">&#39;2023-06-01&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Return DataFrame with computed sunrise and sunset times (using local time) for January 1st 2023, January 2nd 2023 and January 3rd 2023, for Medellín, Colombia.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">([</span><span class="s1">&#39;2023-01-01&#39;</span><span class="p">,</span> <span class="s1">&#39;2023-01-02&#39;</span><span class="p">,</span> <span class="s1">&#39;2023-01-03&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compute_sunrise_sunset</span><span class="p">(</span><span class="mf">6.25184</span><span class="p">,</span> <span class="o">-</span><span class="mf">75.56359</span><span class="p">,</span> <span class="s1">&#39;-05:00&#39;</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Return DataFrame with computed sunrise and sunset times (using local time) for the whole year of 2023 for a place inside the antartic circle.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compute_sunrise_sunset</span><span class="p">(</span><span class="o">-</span><span class="mi">82</span><span class="p">,</span> <span class="o">-</span><span class="mf">75.56359</span><span class="p">,</span> <span class="s1">&#39;-05:00&#39;</span><span class="p">,</span> <span class="s2">&quot;2023-01-01&quot;</span><span class="p">,</span> <span class="s2">&quot;2023-12-31&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ol class="arabic simple">
<li><p>Latitude of -90° corresponds to the geographic South pole, while a
latitude of 90° corresponds to the geographic North Pole.</p></li>
<li><p>A negative longitude correspondes to a point west of the greenwhich
meridian, while a positive longitude means it is east of the greenwhich
meridian.</p></li>
<li><p>A sunrise/sunset equal to “PD” means that the place in question is experiencing a polar day. Meanwhile,
a sunrise/sunset equalt to “PN” stands for polar night.</p></li>
<li><p>This algorithm is based on the NREL SPA algorithm . As such, it calculates sunrise and sunset times without
taking the altitude of the location into account. A higher altitude on a location translates to an earlier sunrise and
and a later sunset compared to that same location if it were situated at sea level. Nevertheless, the effects of altitude
are quite small. For every 1500 meters in elevation, a site’s sunrise occurs 1 minute earlier and its sunset occurs
1 minute later than normal [2].</p></li>
<li><p>This function also does not take into account the effect of mountains or surrounding terrain/structures on the time
when the sun first becomes visible to an observer.</p></li>
</ol>
<p class="rubric">References</p>
<p>[1] <a class="reference external" href="https://pvlib-python.readthedocs.io/en/stable/reference/generated/pvlib.solarposition.sun_rise_set_transit_spa.html">https://pvlib-python.readthedocs.io/en/stable/reference/generated/pvlib.solarposition.sun_rise_set_transit_spa.html</a></p>
<p>[2] <a class="reference external" href="https://www.chicagotribune.com/weather/ct-wea-0928-asktom-20160927-column.html">https://www.chicagotribune.com/weather/ct-wea-0928-asktom-20160927-column.html</a></p>
<p>[3] <a class="reference external" href="https://pypi.org/project/suntimes/">https://pypi.org/project/suntimes/</a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="solrad.geotime.geo_date_range">
<span class="sig-prename descclassname"><span class="pre">solrad.geotime.</span></span><span class="sig-name descname"><span class="pre">geo_date_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">latitude</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">longitude</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_hms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_hms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_polar_nights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inclusive</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.geotime.geo_date_range" title="Permalink to this definition">#</a></dt>
<dd><p>Generate a date range based on geographical coordinates and specified time parameters, with optional filtering for each day
based on user input or sunrise and sunset times.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>latitude</strong> (<em>float</em>) – The latitude of the location in degrees. Must be a number between -90 and 90.</p></li>
<li><p><strong>longitude</strong> (<em>float</em>) – The longitude of the location in degrees. Must be a number between -180 and 180.</p></li>
<li><p><strong>tz</strong> (<em>str</em>) – Timezone information of the location in the format of +/-HH:MM.</p></li>
<li><p><strong>start_time</strong> (<em>str</em>) – The starting date and time in the format ‘YYYY-MM-DD HH:MM:SS’.</p></li>
<li><p><strong>end_time</strong> (<em>str</em>) – The ending date and time in the format ‘YYYY-MM-DD HH:MM:SS’.</p></li>
<li><p><strong>freq</strong> (<em>str</em>) – The frequency at which the date range should be generated.
Any frequency accepted by pandas.date_range is valid for geo_date_range.</p></li>
<li><p><strong>min_hms</strong> (<em>str</em><em> or </em><em>None</em>) – A string representing the minimum hour-minute-second (HH:MM:SS) value for a Timestamp within each day’s time series.
If the hms values are below this threshold, they are removed. It can also be set to None to ignore this condition,
or to “sunrise” to use the computed sunrise time for the location as the value for <em>min_hms</em>.</p></li>
<li><p><strong>max_hms</strong> (<em>str</em><em> or </em><em>None</em>) – A string representing the maximum hour-minute-second (HH:MM:SS) value for a Timestamp within each day’s time series.
If the hms values are above this threshold, they are removed. It can also be set to None to ignore this condition,
or to “sunset” to use the computed sunset time for the location as the value for <em>max_hms</em>.</p></li>
<li><p><strong>skip_polar_nights</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to skip polar night periods during filtering. Defaults to True.</p></li>
<li><p><strong>inclusive</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to forcibly include the end_time in the generated date range, in case it’s left out. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>res</strong> – A dictionary containing the filtered date ranges/time series, separated by day, based on the specified parameters.
Its strucure is as follows: Each key is a 3-tuple of (year : int, month : int, day :int) and each corresponding value is a
pandas.DatetimeIndex object containing the time series associated to that date.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function depends on the ‘compute_sunrise_sunset’ function to compute the sunrise and sunset times if required.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generates a date range from &#39;2023-1-1 00:00:00&#39; to &#39;2023-12-31 23:59:59.999&#39; UTC-5 time, using a frequency of 5 min.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># No filtering of the day hours is carried out.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">latitude</span> <span class="o">=</span> <span class="mf">6.230833</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">longitude</span> <span class="o">=</span> <span class="o">-</span><span class="mf">75.56359</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tz</span> <span class="o">=</span> <span class="s1">&#39;-05:00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">start_time</span> <span class="o">=</span> <span class="s2">&quot;2023-1-1 00:00:00&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">end_time</span>   <span class="o">=</span> <span class="s2">&quot;2023-12-31 23:59:59.999&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="s2">&quot;5min&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_hms</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max_hms</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skip_polar_nights</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inclusive</span> <span class="o">=</span> <span class="kc">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">geo_date_range</span><span class="p">(</span><span class="n">latitude</span><span class="p">,</span> <span class="n">longitude</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">min_hms</span><span class="p">,</span> <span class="n">max_hms</span><span class="p">,</span> <span class="n">skip_polar_nights</span><span class="p">,</span> <span class="n">inclusive</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generates a date range from &#39;2023-1-1 00:00:00&#39; to &#39;2023-12-31 23:59:59.999&#39; UTC-5 time, using a frequency of 5 min.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Filtering of the day hours is carried out using sunrise and sunset times calculated for Medellín, Colombia.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">latitude</span> <span class="o">=</span> <span class="mf">6.230833</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">longitude</span> <span class="o">=</span> <span class="o">-</span><span class="mf">75.56359</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tz</span> <span class="o">=</span> <span class="s1">&#39;-05:00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">start_time</span> <span class="o">=</span> <span class="s2">&quot;2023-1-1 00:00:00&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">end_time</span>   <span class="o">=</span> <span class="s2">&quot;2023-12-31 23:59:59.999&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="s2">&quot;5min&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_hms</span> <span class="o">=</span> <span class="s2">&quot;sunrise&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max_hms</span> <span class="o">=</span> <span class="s2">&quot;sunset&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skip_polar_nights</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inclusive</span> <span class="o">=</span> <span class="kc">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">geo_date_range</span><span class="p">(</span><span class="n">latitude</span><span class="p">,</span> <span class="n">longitude</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">min_hms</span><span class="p">,</span> <span class="n">max_hms</span><span class="p">,</span> <span class="n">skip_polar_nights</span><span class="p">,</span> <span class="n">inclusive</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generates a date range from &#39;2023-1-1 00:00:00&#39; to &#39;2023-12-31 23:59:59.999&#39; UTC-5 time, using a frequency of 5 min.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Filtering of the day hours is carried out using the range specified by the user.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">latitude</span> <span class="o">=</span> <span class="mf">6.230833</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">longitude</span> <span class="o">=</span> <span class="o">-</span><span class="mf">75.56359</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tz</span> <span class="o">=</span> <span class="s1">&#39;-05:00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">start_time</span> <span class="o">=</span> <span class="s2">&quot;2023-1-1 00:00:00&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">end_time</span>   <span class="o">=</span> <span class="s2">&quot;2023-12-31 23:59:59.999&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">freq</span> <span class="o">=</span> <span class="s2">&quot;5min&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_hms</span> <span class="o">=</span> <span class="s2">&quot;06:23:50&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max_hms</span> <span class="o">=</span> <span class="s2">&quot;17:50:00&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skip_polar_nights</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inclusive</span> <span class="o">=</span> <span class="kc">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">geo_date_range</span><span class="p">(</span><span class="n">latitude</span><span class="p">,</span> <span class="n">longitude</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">min_hms</span><span class="p">,</span> <span class="n">max_hms</span><span class="p">,</span> <span class="n">skip_polar_nights</span><span class="p">,</span> <span class="n">inclusive</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="solrad.geotime.timestamp_hms_to_float">
<span class="sig-prename descclassname"><span class="pre">solrad.geotime.</span></span><span class="sig-name descname"><span class="pre">timestamp_hms_to_float</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">timestamp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'h'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.geotime.timestamp_hms_to_float" title="Permalink to this definition">#</a></dt>
<dd><p>Convert Timestamp Hour:Minutes:Seconds information to float.</p>
<p>Example: timestamp_hms_to_float(timestamp, unit = “h”), where
timestamp = pd.Timestamp(“2023-03-08 14:25:36”) returns 14.426667. That is,
it turns the 14h 25min 36s of the timestamp to an equivalent number
of hours. Had we used timestamp_hms_to_float(timestamp, unit = “s”),
the result would have been 51936. That is, the equivalent of 14h 25min 36s
in seconds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timestamp</strong> (<em>pandas.Timestamp object</em>) – Timestamp to convert to float.</p></li>
<li><p><strong>unit</strong> (<em>str</em><em>, </em><em>optional</em>) – Time unit to which the timestamp is to be converted. It can either be
‘d’ (day), ‘h’ (hour), ‘m’ (minute) or ‘s’ (second). Default is ‘h’.</p></li>
<li><p><strong>tz_name</strong> (<em>str</em>) – Time zone string accepted by pandas.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>res</strong> – timestamp converted to float to the specified unit.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="solrad.geotime.utc_hour_to_tz_name">
<span class="sig-prename descclassname"><span class="pre">solrad.geotime.</span></span><span class="sig-name descname"><span class="pre">utc_hour_to_tz_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">utc_hour</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#solrad.geotime.utc_hour_to_tz_name" title="Permalink to this definition">#</a></dt>
<dd><p>Turns float representing the time zone into a string representing the time
zone which is accepted by pandas.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>utc_hour</strong> (<em>float</em>) – Timezone number. Must be anumber between -12 and 12.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>tz_name</strong> – Time zone string accepted by pandas.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ol class="arabic simple">
<li><p>For more information about the time zone strings accepted by pandas, see
the link: <a class="reference external" href="https://pvlib-python.readthedocs.io/en/v0.3.0/timetimezones.html">https://pvlib-python.readthedocs.io/en/v0.3.0/timetimezones.html</a></p></li>
</ol>
</dd></dl>

</section>
<section id="module-solrad">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-solrad" title="Permalink to this heading">#</a></h2>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="solrad.atmosphere.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">solrad.atmosphere package</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="modules.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">src</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2023, Andrés Yesid Moreno Villa
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">solrad package</a><ul>
<li><a class="reference internal" href="#subpackages">Subpackages</a></li>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-solrad.Site">solrad.Site module</a><ul>
<li><a class="reference internal" href="#solrad.Site.Site"><code class="docutils literal notranslate"><span class="pre">Site</span></code></a><ul>
<li><a class="reference internal" href="#solrad.Site.Site.compute_aerosol_asymmetry_factor_using_SF_model"><code class="docutils literal notranslate"><span class="pre">Site.compute_aerosol_asymmetry_factor_using_SF_model()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Site.Site.compute_angstrom_turbidity_exponent_500nm_using_SF_model"><code class="docutils literal notranslate"><span class="pre">Site.compute_angstrom_turbidity_exponent_500nm_using_SF_model()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Site.Site.compute_aod_500nm_using_satelite_data"><code class="docutils literal notranslate"><span class="pre">Site.compute_aod_500nm_using_satelite_data()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Site.Site.compute_cummulative_time_integral_of_irradiances"><code class="docutils literal notranslate"><span class="pre">Site.compute_cummulative_time_integral_of_irradiances()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Site.Site.compute_extraterrestrial_normal_irradiance"><code class="docutils literal notranslate"><span class="pre">Site.compute_extraterrestrial_normal_irradiance()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Site.Site.compute_ozone_column_using_satelite_data"><code class="docutils literal notranslate"><span class="pre">Site.compute_ozone_column_using_satelite_data()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Site.Site.compute_ozone_column_using_van_Heuklon_model"><code class="docutils literal notranslate"><span class="pre">Site.compute_ozone_column_using_van_Heuklon_model()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Site.Site.compute_single_scattering_albedo_using_SF_model"><code class="docutils literal notranslate"><span class="pre">Site.compute_single_scattering_albedo_using_SF_model()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Site.Site.compute_spectrally_averaged_aerosol_asymmetry_factor"><code class="docutils literal notranslate"><span class="pre">Site.compute_spectrally_averaged_aerosol_asymmetry_factor()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Site.Site.compute_sun_data"><code class="docutils literal notranslate"><span class="pre">Site.compute_sun_data()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Site.Site.compute_water_column_using_gueymard94_model"><code class="docutils literal notranslate"><span class="pre">Site.compute_water_column_using_gueymard94_model()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Site.Site.compute_water_column_using_satelite_data"><code class="docutils literal notranslate"><span class="pre">Site.compute_water_column_using_satelite_data()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Site.Site.define_simulation_time_data"><code class="docutils literal notranslate"><span class="pre">Site.define_simulation_time_data()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Site.Site.plot_data"><code class="docutils literal notranslate"><span class="pre">Site.plot_data()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Site.Site.plot_horizon"><code class="docutils literal notranslate"><span class="pre">Site.plot_horizon()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Site.Site.reset_horizon"><code class="docutils literal notranslate"><span class="pre">Site.reset_horizon()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Site.Site.set_climate_data_from_pvgis_tmy_data"><code class="docutils literal notranslate"><span class="pre">Site.set_climate_data_from_pvgis_tmy_data()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Site.Site.set_horizon_from_arrays"><code class="docutils literal notranslate"><span class="pre">Site.set_horizon_from_arrays()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Site.Site.set_horizon_from_func"><code class="docutils literal notranslate"><span class="pre">Site.set_horizon_from_func()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Site.Site.set_horizon_from_pvgis"><code class="docutils literal notranslate"><span class="pre">Site.set_horizon_from_pvgis()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Site.Site.time_interpolate_variable"><code class="docutils literal notranslate"><span class="pre">Site.time_interpolate_variable()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-solrad.Sky">solrad.Sky module</a><ul>
<li><a class="reference internal" href="#solrad.Sky.Sky"><code class="docutils literal notranslate"><span class="pre">Sky</span></code></a><ul>
<li><a class="reference internal" href="#solrad.Sky.Sky.azimuth_to_patch"><code class="docutils literal notranslate"><span class="pre">Sky.azimuth_to_patch()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Sky.Sky.compute_absorbed_energy_by_unit_plane"><code class="docutils literal notranslate"><span class="pre">Sky.compute_absorbed_energy_by_unit_plane()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Sky.Sky.compute_exposure_vectors_for_a_date_interval"><code class="docutils literal notranslate"><span class="pre">Sky.compute_exposure_vectors_for_a_date_interval()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Sky.Sky.compute_optimal_plane_orientation"><code class="docutils literal notranslate"><span class="pre">Sky.compute_optimal_plane_orientation()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Sky.Sky.compute_radiance_for_a_date"><code class="docutils literal notranslate"><span class="pre">Sky.compute_radiance_for_a_date()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Sky.Sky.compute_radiances_for_a_date"><code class="docutils literal notranslate"><span class="pre">Sky.compute_radiances_for_a_date()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Sky.Sky.compute_spectral_radiance_for_a_date"><code class="docutils literal notranslate"><span class="pre">Sky.compute_spectral_radiance_for_a_date()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Sky.Sky.discretise"><code class="docutils literal notranslate"><span class="pre">Sky.discretise()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Sky.Sky.disk_point_to_zone_patch"><code class="docutils literal notranslate"><span class="pre">Sky.disk_point_to_zone_patch()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Sky.Sky.plot_disk_patches"><code class="docutils literal notranslate"><span class="pre">Sky.plot_disk_patches()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Sky.Sky.plot_exposures"><code class="docutils literal notranslate"><span class="pre">Sky.plot_exposures()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Sky.Sky.plot_radiance_for_a_date"><code class="docutils literal notranslate"><span class="pre">Sky.plot_radiance_for_a_date()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Sky.Sky.plot_spectral_radiance_for_a_date"><code class="docutils literal notranslate"><span class="pre">Sky.plot_spectral_radiance_for_a_date()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Sky.Sky.plot_sphere_patches"><code class="docutils literal notranslate"><span class="pre">Sky.plot_sphere_patches()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Sky.Sky.rad_to_zone"><code class="docutils literal notranslate"><span class="pre">Sky.rad_to_zone()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Sky.Sky.sky_point_to_zone_patch"><code class="docutils literal notranslate"><span class="pre">Sky.sky_point_to_zone_patch()</span></code></a></li>
<li><a class="reference internal" href="#solrad.Sky.Sky.zenith_to_zone"><code class="docutils literal notranslate"><span class="pre">Sky.zenith_to_zone()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-solrad.auxiliary_funcs">solrad.auxiliary_funcs module</a><ul>
<li><a class="reference internal" href="#solrad.auxiliary_funcs.fill_CDS_globe_nans_using_laplace"><code class="docutils literal notranslate"><span class="pre">fill_CDS_globe_nans_using_laplace()</span></code></a></li>
<li><a class="reference internal" href="#solrad.auxiliary_funcs.fill_nans_using_laplace_1D"><code class="docutils literal notranslate"><span class="pre">fill_nans_using_laplace_1D()</span></code></a></li>
<li><a class="reference internal" href="#solrad.auxiliary_funcs.load_obj_with_pickle"><code class="docutils literal notranslate"><span class="pre">load_obj_with_pickle()</span></code></a></li>
<li><a class="reference internal" href="#solrad.auxiliary_funcs.save_obj_with_pickle"><code class="docutils literal notranslate"><span class="pre">save_obj_with_pickle()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-solrad.geotime">solrad.geotime module</a><ul>
<li><a class="reference internal" href="#solrad.geotime.compute_sunrise_sunset"><code class="docutils literal notranslate"><span class="pre">compute_sunrise_sunset()</span></code></a></li>
<li><a class="reference internal" href="#solrad.geotime.geo_date_range"><code class="docutils literal notranslate"><span class="pre">geo_date_range()</span></code></a></li>
<li><a class="reference internal" href="#solrad.geotime.timestamp_hms_to_float"><code class="docutils literal notranslate"><span class="pre">timestamp_hms_to_float()</span></code></a></li>
<li><a class="reference internal" href="#solrad.geotime.utc_hour_to_tz_name"><code class="docutils literal notranslate"><span class="pre">utc_hour_to_tz_name()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-solrad">Module contents</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/scripts/furo.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    </body>
</html>