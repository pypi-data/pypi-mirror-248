# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
import base64
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import NotSupported
from ccxt.base.errors import ExchangeNotAvailable


class probit (Exchange):

    def describe(self):
        return self.deep_extend(super(probit, self).describe(), {
            'id': 'probit',
            'name': 'ProBit',
            'countries': ['SC', 'KR'],
            'rateLimit': 250,  # ms
            'has': {
                'CORS': True,
                'fetchTime': True,
                'fetchMarkets': True,
                'fetchCurrencies': True,
                'fetchTickers': True,
                'fetchTicker': True,
                'fetchOHLCV': True,
                'fetchOrderBook': True,
                'fetchTrades': True,
                'fetchBalance': True,
                'createOrder': True,
                'createLimitOrder': True,
                'createMarketOrder': True,
                'cancelOrder': True,
                'fetchOrder': True,
                'fetchOpenOrders': True,
                'fetchClosedOrders': True,
                'fetchMyTrades': True,
                'fetchDepositAddress': True,
                'withdraw': True,
            },
            'timeframes': {
                '1m': '1m',
                '3m': '3m',
                '5m': '5m',
                '10m': '10m',
                '15m': '15m',
                '30m': '30m',
                '1h': '1h',
                '4h': '4h',
                '6h': '6h',
                '12h': '12h',
                '1d': '1D',
                '1w': '1W',
            },
            'version': 'v1',
            'urls': {
                'logo': 'https://static.probit.com/landing/assets/images/probit-logo-global.png',
                'api': {
                    #'account': 'https://accounts.probit.com',
                    'exchange': 'https://api.coinstore.com',
                },
                'www': 'https://www.coinstore.com',
                'doc': [
                    'https://docs-en.probit.com',
                    'https://docs-ko.probit.com',
                ],
                'fees': 'https://www.coinstore.com/#/fee',
            },
            'api': {
                'public': {
                    'get': ['api/v1/market/tickers'],
                    'post': ['v2/public/config/spot/symbols'],
                },
                'private': {
                    'post': ['api/spot/accountList', 'api/trade/order/place', 'api/trade/order/cancelAll'],
                    'get': ['api/v2/trade/order/active'],
                },
                #'auth': {
                 #   'post': ['token'],
                #},
            },
            'fees': {
                'trading': {
                    'tierBased': False,
                    'percentage': True,
                    'maker': 0.002 / 100,
                    'taker': 0.002 / 100,
                },
            },
            'exceptions': {
                'INVALID_ARGUMENT': BadRequest,
                'TRADING_UNAVAILABLE': ExchangeNotAvailable,
                'NOT_ENOUGH_BALANCE': InsufficientFunds,
                'NOT_ALLOWED_COMBINATION': BadRequest,
                'INVALID_ORDER': InvalidOrder,
            },
            'requiredCredentials': {
                'apiKey': True,
                'secret': True,
            },
            'options': {
                'defaultLimitOrderTimeInForce': 'gtc',
                'defaultMarketOrderTimeInForce': 'ioc',
            },
        })

    def fetch_markets(self, params={}):
        response = self.publicPostV2PublicConfigSpotSymbols()
        markets = self.safe_value(response, 'data')
        result = []
        for i in range(0, len(markets)):
            market = markets[i]
            base = market['base_currency_id']
            quote = market['quote_currency_id']
            symbol = base + '/' + quote
            closed = market['closed']

            price_precision = len(market['min_price']) - 2
            if price_precision < 0:
                price_precision = 0

            result.append({
                'id': market['id'],
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': base,
                'quoteId': quote,
                'active': not closed,
                'precision': {
                    'amount': market['quantity_precision'],
                    'cost': market['cost_precision'],
                    'price': price_precision,
                },
                'limits': {
                    'amount': {
                        'min': market['min_quantity'],
                        'max': market['max_quantity'],
                    },
                    'price': {
                        'min': market['min_price'],
                        'max': market['max_price'],
                    },
                    'cost': {
                        'min': market['min_cost'],
                        'max': market['max_cost'],
                    },
                },
                'info': market,
            })
        return result
    def fetch_balance(self, params={}):
        self.load_markets()
        response = self.privatePostApiSpotAccountList()
        balances = self.safe_value(response, 'data')
        result = {'info': balances}
        for i in range(0, len(balances)):
            balance = balances[i]
            currencyId = balance['currency_id']
            account = self.account()
            total = self.safe_float(balance, 'total')
            available = self.safe_float(balance, 'available')
            hold = self.sum(total, -available)
            account['total'] = total
            account['free'] = available
            account['used'] = hold
            result[currencyId] = account
        return self.parse_balance(result)
        
    def create_order(self, symbol, type, side, amount, price=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        req = {
            'market_id': market['id'],
            'type': type,
            'side': side,
        }
        clientOrderId = self.safe_string(params, 'clientOrderId')
        if clientOrderId:
            req['client_order_id'] = clientOrderId
        timeInForce = self.safe_string(params, 'timeInForce')
        if type == 'limit':
            if not timeInForce:
                timeInForce = self.options['defaultLimitOrderTimeInForce']
            req['time_in_force'] = timeInForce
            req['limit_price'] = self.price_to_precision(symbol, price)
            req['quantity'] = self.amount_to_precision(symbol, amount)
        elif type == 'market':
            if not timeInForce:
                timeInForce = self.options['defaultMarketOrderTimeInForce']
            req['time_in_force'] = timeInForce
            if side == 'sell':
                req['quantity'] = self.amount_to_precision(symbol, amount)
            elif side == 'buy':
                req['cost'] = self.cost_to_precision(symbol, amount)
        resp = self.privatePostApiTradeOrderPlace(self.extend(req, params))
        return self.parse_order(self.safe_value(resp, 'data'), symbol)

    def cancel_order(self, id, symbol=None, params={}):
        market = self.market(symbol)
        request = {
            'market_id': market['id'],
            'order_id': str(id),
        }
        resp = self.privatePostApiTradeOrderCancelAll(self.extend(request, params))
        return self.parse_order(self.safe_value(resp, 'data'), symbol)

   
    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        url = self.urls['api']['exchange'] + '/' + self.version + '/'
        if api == 'auth':
            url = self.urls['api']['account'] + '/'
        query = self.omit(params, self.extract_params(path))
        if api == 'public':
            url += self.implode_params(path, params)
            if query:
                url += '?' + self.urlencode(query)
        elif api == 'private':
            self.check_required_credentials()
            expires = self.safe_integer(self.options, 'expires')

            # Login before expire: 1 minutes
            if not expires or (expires - 1 * 60 * 1000) < self.milliseconds():
                self.sign_in()
                # raise AuthenticationError(self.id + ' accessToken expired, call signIn() method')

            url += self.implode_params(path, params)
            if method == 'GET':
                if query:
                    url += '?' + self.urlencode(query)
            elif query:
                body = self.json(query)
            headers = {
                'Authorization': 'Bearer ' + self.options['accessToken'],
                'Content-Type': 'application/json',
            }
        elif api == 'auth':
            self.check_required_credentials()
            url += self.implode_params(path, params)
            encoded = self.encode(self.apiKey + ':' + self.secret)
            basicAuth = base64.b64encode(encoded)
            headers = {
                'Authorization': 'Basic ' + self.decode(basicAuth),
                'Content-Type': 'application/json',
            }
            if method == 'GET':
                if query:
                    url += '?' + self.urlencode(query)
            elif query:
                body = self.json(query)
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def sign_in(self, params={}):
        self.check_required_credentials()
        if not self.apiKey or not self.secret:
            raise AuthenticationError(self.id + ' signIn() requires self.apiKey and self.secret credentials')
        body = {
            'grant_type': 'client_credentials',
        }
        tokenResponse = self.authPostToken(body)
        expiresIn = self.safe_integer(tokenResponse, 'expires_in')
        accessToken = self.safe_string(tokenResponse, 'access_token')
        self.options['accessToken'] = accessToken
        self.options['expires'] = self.sum(self.milliseconds(), expiresIn * 1000)
        self.options['tokenType'] = self.safe_string(tokenResponse, 'token_type')
        return tokenResponse

    def handle_errors(self, httpCode, reason, url, method, headers, body, response, request_headers, request_body):
        if response is None:
            return  # fallback to default error handler

        if 'errorCode' in response:
            errorCode = self.safe_string(response, 'errorCode')
            message = self.safe_string(response, 'message')
            if errorCode is not None:
                feedback = self.json(response)
                exceptions = self.exceptions
                if message in exceptions:
                    raise exceptions[message](feedback)
                elif errorCode in exceptions:
                    raise exceptions[errorCode](feedback)
                else:
                    raise ExchangeError(feedback)
