# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_util.ipynb.

# %% auto 0
__all__ = ['DataFrameLike', 'DataFrameLikeQ', 'wrapidx', 'detdf', 'dfds', 'getidx', 'getdfidx', 'getdfloc', 'getdfiloc',
           'getdficat', 'mergebools', 'idxisin', 'safeidx', 'safeloc', 'safeiloc', 'ascat', 'getcol', 'getcatcodes',
           'getcolcodes', 'ascidx']

# %% ../nbs/02_util.ipynb 6
#| export


# %% ../nbs/02_util.ipynb 8
from typing import Union, Tuple, TypeAlias, Optional

# %% ../nbs/02_util.ipynb 11
#| export

# %% ../nbs/02_util.ipynb 13
try: import numpy as np, pandas as pd
except ImportError: ...

# %% ../nbs/02_util.ipynb 15
#| export


# %% ../nbs/02_util.ipynb 17
#| export


# %% ../nbs/02_util.ipynb 19
from atyp import DataFrame, Dataset, DataFrameQ, DatasetQ, IndexQ, IndexLike, IndexLikeQ
from atyp import (DataFrameQ, DatasetQ, IndexQ, IndexLikeQ, IterBool, NPArray)

from chck import (
    isseries, isdf,  isdfds, isidxlike, isboolidx,
    isiter, isnone, istuple, iscatidx
)

from atup import argtup
from fpos import arg1st
from getr import (
    getdf, getindex as index, getloc as loc, getiloc as iloc, geticat as icat,
    getcategories
)

# %% ../nbs/02_util.ipynb 20
from nlit import CATEGORY, CATEGORIES
from getr import getindex, getcodes
from hasr import hasindex, hasastype, hascategories, hascat, hascodes

# %% ../nbs/02_util.ipynb 22
from .mock import dummydf

# %% ../nbs/02_util.ipynb 26
DataFrameLike: TypeAlias = Union[Dataset, DataFrame]
DataFrameLikeQ: TypeAlias = Optional[DataFrameLike]

# %% ../nbs/02_util.ipynb 27
def wrapidx(idx: IndexLikeQ = None) -> IndexLike:
    '''Wrap idx in a tuple if it's not already a tuple or an index-like object'''
    idxlen = len(argtup(idx))
    if idxlen == 1 and not (isidxlike(idx) or istuple(idx)):
        idx = list((idx, ))
    return idx

# %% ../nbs/02_util.ipynb 28
def detdf(*args: DataFrameLike) -> DataFrameQ:
    '''
    Determine the df from any of the args if the current `arg` is a `df` or `ds.df`

    `dfds` searches for the first pandas DataFrame found in any of the `args` or `arg.df` 
    (if and only if `arg` is a pytorch `Dataset`) and returns it

    Notes
    -----
    df : `pd.DataFrame`
    ds : `torch.utils.data.dataset.Dataset`
    '''
    arg = arg1st(*args, flag=lambda e: isdf(e) or isdfds(e) or isseries(e), default=None)
    if isseries(arg): return arg.to_frame()
    return getdf(arg)

def dfds(df: DataFrameQ = None, ds: DatasetQ = None, *args: DataFrameLike) -> DataFrameQ:
    '''Get the `df` from either `df` or `ds.df` where `df`'''        
    return detdf(df, ds, *args)

# %% ../nbs/02_util.ipynb 29
def getidx(dl: DataFrameLike = None, *args: DataFrameLike) -> IndexQ:
    '''Get the df's index from either `df` or `ds.df`'''
    return index(dfds(dl, *args))

# %% ../nbs/02_util.ipynb 30
def getdfidx(dl: DataFrameLike = None, *args: DataFrameLike) -> IndexQ:
    '''Get the df's index from either `df` or `ds.df`'''
    return index(dfds(dl, *args))

def getdfloc(dl: DataFrameLike, *args: DataFrameLike) -> IndexQ:
    '''Get the df's `LocIndexer` from either `df` or `ds.df`'''
    return loc(detdf(dl, *args))

def getdfiloc(dl: DataFrameLike, *args: DataFrameLike) -> IndexQ:
    '''Get the df's `iLocIndexer` from either `df` or `ds.df`'''
    return iloc(detdf(dl, *args))

def getdficat(dl: DataFrameLike, *args: DataFrameLike) -> IndexQ:
    '''Get the df's `iLocIndexer` from either `df` or `ds.df`'''
    return icat(detdf(dl, *args))

# %% ../nbs/02_util.ipynb 31
def mergebools(idx: IterBool, dl: DataFrameLike = None, *args: DataFrameLike) -> NPArray:
    '''Merge boolean indexes.'''
    if not isiter(idx): return np.zeros_like(getdfidx(dl, *args), dtype=bool)
    elif isboolidx(idx): return np.logical_or.reduce(np.vstack(idx))
    return np.logical_or.reduce(idx)

# %% ../nbs/02_util.ipynb 33
def idxisin(idx: IndexLikeQ = None, dl: DataFrameLike = None, *args: DataFrameLike, vals: IndexLikeQ = None) -> IndexLike:
    '''Filter vals for those in df's index'''
    idx = wrapidx(idx)
    if vals is None: vals = getdfidx(dl, *args)
    return type(idx)(list(filter(lambda x: x in vals, idx)))

# %% ../nbs/02_util.ipynb 35
def safeidx(idx: IndexLikeQ = None, dl: DataFrameLike = None, *args: DataFrameLike) -> IndexQ:
    '''Check that idx exists or get the df's index from either `df` or `ds.df`'''
    if isnone(idx) or not isidxlike(idx): return getdfidx(dl, *args)
    return idx

def safeloc(idx: IndexLikeQ = None, dl: DataFrameLike = None, *args: DataFrameLike) -> IndexQ:
    '''Check that idx exists then apply it to the `LocIndexer` from either `df` or `ds.df`'''
    idx = safeidx(idx, dl, *args) if isnone(idx) else idx
    return getdfloc(dl, *args)[idx]

def safeiloc(idx: IndexLikeQ = None, dl: DataFrameLike = None, *args: DataFrameLike) -> IndexQ:
    '''Check that idx exists then apply it to the `iLocIndexer` from either `df` or `ds.df`'''
    idx = safeidx(idx, dl, *args) if isnone(idx) else idx
    return getdfiloc(dl, *args)[idx]

# %% ../nbs/02_util.ipynb 37
def ascat(il: IndexLike | DataFrameLike) -> pd.Categorical:
    if hasastype(il): return il.astype(CATEGORY)
    if hasindex(il): return getindex(il).astype(CATEGORY)
    if hascategories(il): return il
    
    try: return pd.Categorical(il)
    except: ...
    return il

# %% ../nbs/02_util.ipynb 38
def getcol(dl: DataFrameLike, col: str, *args: DataFrameLike):
    df = detdf(dl, *args)
    return df.get(col)

def getcatcodes(idx: IndexLike):
    if iscatidx(idx): return idx.codes
    return getcodes(idx)

def getcolcodes(dl: DataFrameLike, col: str, *args: DataFrameLike):
    srs = getcol(dl, col, *args)
    return getcodes(srs)

# %% ../nbs/02_util.ipynb 39
def ascidx(idx: IndexLike | DataFrameLike) -> pd.Categorical:
    if isdf(idx): idx = getindex(idx)    
    if isseries(idx) and hascat(idx): return idx
    if hasastype(idx): return idx.astype(CATEGORY)
    if hascategories(idx): return idx
    return pd.Categorical(idx)

# %% ../nbs/02_util.ipynb 41
#| export
